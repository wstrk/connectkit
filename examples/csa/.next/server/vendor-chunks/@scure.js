"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@scure/base/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@scure/base/lib/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nconst base58 = /* @__PURE__ */ genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = /* @__PURE__ */ genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = /* @__PURE__ */ genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = /* @__PURE__ */ (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode,\n        decode,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32(\"bech32\");\nconst bech32m = /* @__PURE__ */ genBech32(\"bech32m\");\nconst utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0UsR0FDbEUsWUFBWTtBQUNaOztDQUVDLEdBQ00sU0FBU0EsYUFBYUMsQ0FBQztJQUMxQixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsSUFDdEIsTUFBTSxJQUFJRyxNQUFNLENBQUMsZUFBZSxFQUFFSCxFQUFFLENBQUM7QUFDN0M7QUFDQSxTQUFTSSxRQUFRQyxDQUFDO0lBQ2QsT0FBUUEsYUFBYUMsY0FDaEJELEtBQUssUUFBUSxPQUFPQSxNQUFNLFlBQVlBLEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3RFO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxNQUFNLEdBQUdDLElBQUk7SUFDbEIsTUFBTUMsS0FBSyxDQUFDTixJQUFNQTtJQUNsQiwrQ0FBK0M7SUFDL0MsTUFBTU8sT0FBTyxDQUFDUCxHQUFHUSxJQUFNLENBQUNDLElBQU1ULEVBQUVRLEVBQUVDO0lBQ2xDLDZEQUE2RDtJQUM3RCxNQUFNQyxTQUFTTCxLQUFLTSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUYsTUFBTSxFQUFFRyxXQUFXLENBQUNOLE1BQU1EO0lBQzNELHlEQUF5RDtJQUN6RCxNQUFNUSxTQUFTVCxLQUFLTSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUUsTUFBTSxFQUFFQyxNQUFNLENBQUNSLE1BQU1EO0lBQ3RELE9BQU87UUFBRUk7UUFBUUk7SUFBTztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNFLFNBQVNBLFFBQVE7SUFDdEIsT0FBTztRQUNITixRQUFRLENBQUNPO1lBQ0wsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLFdBQVlBLE9BQU9HLE1BQU0sSUFBSSxPQUFPSCxNQUFNLENBQUMsRUFBRSxLQUFLLFVBQ2pFLE1BQU0sSUFBSW5CLE1BQU07WUFDcEIsT0FBT21C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QUUsT0FBTzNDLEVBQUUsYUFBYSxFQUFFQSxFQUFFeEQsTUFBTSxDQUFDLENBQUM7SUFDOUYsT0FBT3dELEVBQUU2QyxXQUFXO0FBQ3hCLElBQUk7QUFDSixrQkFBa0I7QUFDbEIsTUFBTWEsU0FBUztJQUNYSjtJQUFNRztJQUFLN0Q7SUFBUUM7SUFBUU07SUFBUUM7SUFBV0k7SUFBUUk7QUFDMUQ7QUFDQSxNQUFNK0MsaUJBQWlCO0FBQ2hCLE1BQU1DLGdCQUFnQixDQUFDQyxNQUFNOUU7SUFDaEMsSUFBSSxPQUFPOEUsU0FBUyxZQUFZLENBQUNILE9BQU9JLGNBQWMsQ0FBQ0QsT0FDbkQsTUFBTSxJQUFJbEIsVUFBVWdCO0lBQ3hCLElBQUksQ0FBQ3hJLFFBQVE0RCxRQUNULE1BQU0sSUFBSTRELFVBQVU7SUFDeEIsT0FBT2UsTUFBTSxDQUFDRyxLQUFLLENBQUMvSCxNQUFNLENBQUNpRDtBQUMvQixFQUFFO0FBQ0ssTUFBTWlDLE1BQU00QyxjQUFjLENBQUMsbUNBQW1DO0FBQzlELE1BQU1HLGdCQUFnQixDQUFDRixNQUFNN0M7SUFDaEMsSUFBSSxDQUFDMEMsT0FBT0ksY0FBYyxDQUFDRCxPQUN2QixNQUFNLElBQUlsQixVQUFVZ0I7SUFDeEIsSUFBSSxPQUFPM0MsUUFBUSxVQUNmLE1BQU0sSUFBSTJCLFVBQVU7SUFDeEIsT0FBT2UsTUFBTSxDQUFDRyxLQUFLLENBQUMzSCxNQUFNLENBQUM4RTtBQUMvQixFQUFFO0FBQ0ssTUFBTWpDLFFBQVFnRixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3NhLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzPzg1ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllc1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gLyogQF9fUFVSRV9fICovIChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG4vLyBsZWdhY3kgZXhwb3J0LCBiYWQgbmFtZVxuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gLyogQF9fUFVSRV9fICovIGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSAyICoqIDMwXSwgMzAsIDUsIGZhbHNlKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIHN0ciA9IGxvd2VyZWQ7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBfd29yZHMgPSBzdHIuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKF93b3Jkcy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShfd29yZHMpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFfd29yZHMuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlLCBkZWNvZGVUb0J5dGVzLCBkZWNvZGVVbnNhZmUsIGZyb21Xb3JkcywgZnJvbVdvcmRzVW5zYWZlLCB0b1dvcmRzIH07XG59XG5leHBvcnQgY29uc3QgYmVjaDMyID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gJ0ludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXInO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOlsiYXNzZXJ0TnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNoYWluIiwiYXJncyIsImlkIiwid3JhcCIsImIiLCJjIiwiZW5jb2RlIiwibWFwIiwieCIsInJlZHVjZVJpZ2h0IiwiZGVjb2RlIiwicmVkdWNlIiwiYWxwaGFiZXQiLCJkaWdpdHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpIiwiaW5wdXQiLCJsZXR0ZXIiLCJpbmRleCIsImluZGV4T2YiLCJqb2luIiwic2VwYXJhdG9yIiwiZnJvbSIsInRvIiwic3BsaXQiLCJwYWRkaW5nIiwiYml0cyIsImNociIsImRhdGEiLCJwdXNoIiwiZW5kIiwic2xpY2UiLCJub3JtYWxpemUiLCJmbiIsImNvbnZlcnRSYWRpeCIsInBvcyIsInJlcyIsImZvckVhY2giLCJkIiwiY2FycnkiLCJkb25lIiwiZGlnaXQiLCJkaWdpdEJhc2UiLCJyb3VuZGVkIiwiTWF0aCIsImZsb29yIiwicmV2ZXJzZSIsImdjZCIsInJhZGl4MmNhcnJ5IiwiY29udmVydFJhZGl4MiIsIm1hc2siLCJyYWRpeCIsIm51bSIsImJ5dGVzIiwicmFkaXgyIiwicmV2UGFkZGluZyIsInVuc2FmZVdyYXBwZXIiLCJhcHBseSIsImUiLCJjaGVja3N1bSIsImxlbiIsInNldCIsInBheWxvYWQiLCJuZXdDaGVja3N1bSIsIm9sZENoZWNrc3VtIiwidXRpbHMiLCJiYXNlMTYiLCJiYXNlMzIiLCJiYXNlMzJoZXgiLCJiYXNlMzJjcm9ja2ZvcmQiLCJzIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiYmFzZTY0IiwiYmFzZTY0dXJsIiwiYmFzZTY0dXJsbm9wYWQiLCJnZW5CYXNlNTgiLCJhYmMiLCJiYXNlNTgiLCJiYXNlNThmbGlja3IiLCJiYXNlNTh4cnAiLCJYTVJfQkxPQ0tfTEVOIiwiYmFzZTU4eG1yIiwiYmxvY2siLCJzdWJhcnJheSIsInBhZFN0YXJ0Iiwic3RyIiwiYmxvY2tMZW4iLCJqIiwiY29uY2F0IiwiY3JlYXRlQmFzZTU4Y2hlY2siLCJzaGEyNTYiLCJiYXNlNThjaGVjayIsIkJFQ0hfQUxQSEFCRVQiLCJQT0xZTU9EX0dFTkVSQVRPUlMiLCJiZWNoMzJQb2x5bW9kIiwicHJlIiwiY2hrIiwiYmVjaENoZWNrc3VtIiwicHJlZml4Iiwid29yZHMiLCJlbmNvZGluZ0NvbnN0IiwiY2hhckNvZGVBdCIsInYiLCJnZW5CZWNoMzIiLCJlbmNvZGluZyIsIkVOQ09ESU5HX0NPTlNUIiwiX3dvcmRzIiwiZnJvbVdvcmRzIiwidG9Xb3JkcyIsImZyb21Xb3Jkc1Vuc2FmZSIsImxpbWl0IiwiYWN0dWFsTGVuZ3RoIiwiVHlwZUVycm9yIiwibG93ZXJlZCIsInRvTG93ZXJDYXNlIiwic3VtIiwic2VwSW5kZXgiLCJsYXN0SW5kZXhPZiIsImVuZHNXaXRoIiwiZGVjb2RlVW5zYWZlIiwiZGVjb2RlVG9CeXRlcyIsImJlY2gzMiIsImJlY2gzMm0iLCJ1dGY4IiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsImhleCIsIkNPREVSUyIsImNvZGVyVHlwZUVycm9yIiwiYnl0ZXNUb1N0cmluZyIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInN0cmluZ1RvQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@scure/starknet/lib/esm/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@scure/starknet/lib/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Fp251: () => (/* binding */ Fp251),\n/* harmony export */   MAX_VALUE: () => (/* binding */ MAX_VALUE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ ProjectivePoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   _poseidonMDS: () => (/* binding */ _poseidonMDS),\n/* harmony export */   _starkCurve: () => (/* binding */ _starkCurve),\n/* harmony export */   computeHashOnElements: () => (/* binding */ computeHashOnElements),\n/* harmony export */   ethSigToPrivate: () => (/* binding */ ethSigToPrivate),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   getStarkKey: () => (/* binding */ getStarkKey),\n/* harmony export */   grindKey: () => (/* binding */ grindKey),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   pedersen: () => (/* binding */ pedersen),\n/* harmony export */   poseidonBasic: () => (/* binding */ poseidonBasic),\n/* harmony export */   poseidonCreate: () => (/* binding */ poseidonCreate),\n/* harmony export */   poseidonHash: () => (/* binding */ poseidonHash),\n/* harmony export */   poseidonHashFunc: () => (/* binding */ poseidonHashFunc),\n/* harmony export */   poseidonHashMany: () => (/* binding */ poseidonHashMany),\n/* harmony export */   poseidonHashSingle: () => (/* binding */ poseidonHashSingle),\n/* harmony export */   poseidonSmall: () => (/* binding */ poseidonSmall),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/../../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(ssr)/../../node_modules/@noble/curves/esm/_shortw_utils.js\");\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt(\"3618502788666131213697322783095070105526743751716087489154079457884512865583\");\nconst MAX_VALUE = BigInt(\"0x800000000000000000000000000000000000000000000000000000000000000\");\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while(bytes[0] === 0)bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === \"string\") {\n        hex = strip0x(hex);\n        if (hex.length & 1) hex = \"0\" + hex;\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1),\n    b: BigInt(\"3141592653589793238462643383279502884197169399375105820974944592307816406665\"),\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"0x800000000000011000000000000000000000000000000000000000000000001\")),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt(\"874739451078007766457464989774322083649278607533249481151382481072868806602\"),\n    Gy: BigInt(\"152666792071518830868575557812948353041420400780739481342941381225525861407\"),\n    h: BigInt(1),\n    lowS: false,\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    bits2int,\n    bits2int_modN: (bytes)=>{\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63) bytes = hex0xToBytes(hex + \"0\");\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    }\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes(\"\", typeof hex === \"string\" ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, \"0\");\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE) throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE) throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE) throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        } catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err)) throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, \"\");\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for(let i = 0;; i++){\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit) return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000) throw new Error(\"grindKey is broken: tried 100k vals\");\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130) throw new Error(\"Wrong ethereum signature\");\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n)=>Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for(let i = 0; i < 248; i++){\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for(let i = 0; i < 4; i++){\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === \"bigint\") {\n        value = arg;\n    } else if (typeof arg === \"number\") {\n        if (!Number.isSafeInteger(arg)) throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    } else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER)) throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for(let j = 0; j < 252; j++){\n        const pt = constants[j];\n        if (pt.equals(point)) throw new Error(\"Same point\");\n        if ((x & 1n) !== 0n) point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nconst computeHashOnElements = (data, fn = pedersen)=>[\n        0,\n        ...data,\n        data.length\n    ].reduce((x, y)=>fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"3618502788666131213697322783095070105623107215331596699973092056135872020481\"));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for(let i = 0; i < m; i++){\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([\n        ...x_values,\n        ...y_values\n    ]).size !== 2 * m) throw new Error(\"X and Y values are not distinct\");\n    return x_values.map((x)=>y_values.map((y)=>Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [\n        3,\n        1,\n        1\n    ],\n    [\n        1,\n        -1,\n        1\n    ],\n    [\n        1,\n        1,\n        -2\n    ]\n].map((i)=>i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity)) throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for(let i = 0; i < rounds; i++){\n        const row = [];\n        for(let j = 0; j < m; j++)row.push(poseidonRoundConstant(opts.Fp, \"Hades\", m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt)) throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, \"HadesMDS\", m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({\n    Fp: Fp251,\n    rate: 2,\n    capacity: 1,\n    roundsFull: 8,\n    roundsPartial: 83\n}, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([\n        x,\n        y,\n        2n\n    ])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([\n        x,\n        0n,\n        1n\n    ])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values)) throw new Error(\"bigint array expected in values\");\n    const padded = Array.from(values);\n    padded.push(1n);\n    while(padded.length % rate !== 0)padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for(let i = 0; i < padded.length; i += rate){\n        for(let j = 0; j < rate; j++)state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDRjtBQUNJO0FBQ2lDO0FBQ3hCO0FBQ1c7QUFDcEI7QUFDSTtBQUN0RCxNQUFNWSxjQUFjQyxPQUFPO0FBQ3BCLE1BQU1DLFlBQVlELE9BQU8scUVBQXFFO0FBQ3JHLE1BQU1FLGFBQWE7QUFDbkIsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixNQUFPQSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQ2hCQSxRQUFRQSxNQUFNQyxRQUFRLENBQUM7SUFDM0IsTUFBTUMsUUFBUUYsTUFBTUcsTUFBTSxHQUFHLElBQUlMO0lBQ2pDLE1BQU1NLE1BQU1YLHlFQUFpQixDQUFDTztJQUM5QixPQUFPRSxRQUFRLElBQUlFLE9BQU9SLE9BQU9NLFNBQVNFO0FBQzlDO0FBQ0EsU0FBU0UsYUFBYUMsR0FBRztJQUNyQixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QkEsTUFBTUMsUUFBUUQ7UUFDZCxJQUFJQSxJQUFJSixNQUFNLEdBQUcsR0FDYkksTUFBTSxNQUFNQTtJQUNwQjtJQUNBLE9BQU9kLG9FQUFZLENBQUNjO0FBQ3hCO0FBQ0EsTUFBTUcsUUFBUW5CLCtFQUFXQSxDQUFDO0lBQ3RCb0IsR0FBR2YsT0FBTztJQUNWZ0IsR0FBR2hCLE9BQU87SUFDVmlCLElBQUkzQixxRUFBS0EsQ0FBQ1UsT0FBTztJQUNqQmtCLEdBQUduQjtJQUNIRztJQUNBaUIsSUFBSW5CLE9BQU87SUFDWG9CLElBQUlwQixPQUFPO0lBQ1hxQixHQUFHckIsT0FBTztJQUNWc0IsTUFBTTtJQUNOLEdBQUd4QixtRUFBT0EsQ0FBQ1Ysd0RBQU1BLENBQUM7SUFDbEJlO0lBQ0FvQixlQUFlLENBQUNuQjtRQUNaLE1BQU1PLE1BQU1kLHlFQUFpQixDQUFDTyxPQUFPb0IsUUFBUSxDQUFDO1FBQzlDLElB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UUFBUSxJQUFJSixNQUFNL0IsR0FBR29DLElBQUksQ0FBQyxFQUFFO0lBQ2hDLElBQUssSUFBSWxHLElBQUksR0FBR0EsSUFBSStGLE9BQU96SixNQUFNLEVBQUUwRCxLQUFLMEUsS0FBTTtRQUMxQyxJQUFLLElBQUlsQyxJQUFJLEdBQUdBLElBQUlrQyxNQUFNbEMsSUFDdEJ5RCxLQUFLLENBQUN6RCxFQUFFLElBQUl1RCxNQUFNLENBQUMvRixJQUFJd0MsRUFBRTtRQUM3QnlELFFBQVFoRCxHQUFHZ0Q7SUFDZjtJQUNBLE9BQU9BLEtBQUssQ0FBQyxFQUFFO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3NhLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbGliL2VzbS9pbmRleC5qcz8wMDA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgdXRmOFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQsIGludmVydCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG5pbXBvcnQgeyBwb3NlaWRvbiB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvcG9zZWlkb24nO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MsIERFUiB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MnO1xuaW1wb3J0ICogYXMgdSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCB7IGdldEhhc2ggfSBmcm9tICdAbm9ibGUvY3VydmVzL19zaG9ydHdfdXRpbHMnO1xuY29uc3QgQ1VSVkVfT1JERVIgPSBCaWdJbnQoJzM2MTg1MDI3ODg2NjYxMzEyMTM2OTczMjI3ODMwOTUwNzAxMDU1MjY3NDM3NTE3MTYwODc0ODkxNTQwNzk0NTc4ODQ1MTI4NjU1ODMnKTtcbmV4cG9ydCBjb25zdCBNQVhfVkFMVUUgPSBCaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG5jb25zdCBuQml0TGVuZ3RoID0gMjUyO1xuZnVuY3Rpb24gYml0czJpbnQoYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXNbMF0gPT09IDApXG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gbkJpdExlbmd0aDtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xufVxuZnVuY3Rpb24gaGV4MHhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBzdHJpcDB4KGhleCk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcbiAgICB9XG4gICAgcmV0dXJuIHUuaGV4VG9CeXRlcyhoZXgpO1xufVxuY29uc3QgY3VydmUgPSB3ZWllcnN0cmFzcyh7XG4gICAgYTogQmlnSW50KDEpLFxuICAgIGI6IEJpZ0ludCgnMzE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjY2NScpLFxuICAgIEZwOiBGaWVsZChCaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJykpLFxuICAgIG46IENVUlZFX09SREVSLFxuICAgIG5CaXRMZW5ndGgsXG4gICAgR3g6IEJpZ0ludCgnODc0NzM5NDUxMDc4MDA3NzY2NDU3NDY0OTg5Nzc0MzIyMDgzNjQ5Mjc4NjA3NTMzMjQ5NDgxMTUxMzgyNDgxMDcyODY4ODA2NjAyJyksXG4gICAgR3k6IEJpZ0ludCgnMTUyNjY2NzkyMDcxNTE4ODMwODY4NTc1NTU3ODEyOTQ4MzUzMDQxNDIwNDAwNzgwNzM5NDgxMzQyOTQxMzgxMjI1NTI1ODYxNDA3JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IGZhbHNlLFxuICAgIC4uLmdldEhhc2goc2hhMjU2KSxcbiAgICBiaXRzMmludCxcbiAgICBiaXRzMmludF9tb2ROOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDYzKVxuICAgICAgICAgICAgYnl0ZXMgPSBoZXgweFRvQnl0ZXMoaGV4ICsgJzAnKTtcbiAgICAgICAgcmV0dXJuIG1vZChiaXRzMmludChieXRlcyksIENVUlZFX09SREVSKTtcbiAgICB9LFxufSk7XG5leHBvcnQgY29uc3QgX3N0YXJrQ3VydmUgPSBjdXJ2ZTtcbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiB1LmVuc3VyZUJ5dGVzKCcnLCB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGhleDB4VG9CeXRlcyhoZXgpIDogaGV4KTtcbn1cbmZ1bmN0aW9uIG5vcm1Qcml2S2V5KHByaXZLZXkpIHtcbiAgICByZXR1cm4gdS5ieXRlc1RvSGV4KGVuc3VyZUJ5dGVzKHByaXZLZXkpKS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdktleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0UHVibGljS2V5KG5vcm1Qcml2S2V5KHByaXZLZXkpLCBpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2S2V5QSwgcHViS2V5Qikge1xuICAgIHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQobm9ybVByaXZLZXkocHJpdktleUEpLCBwdWJLZXlCKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnbmF0dXJlO1xuICAgIGlmIChyIDwgMG4gfHwgciA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnbmF0dXJlLnIgc2hvdWxkIGJlIFsxLCAke01BWF9WQUxVRX0pYCk7XG4gICAgY29uc3QgdyA9IGludmVydChzLCBDVVJWRV9PUkRFUik7XG4gICAgaWYgKHcgPCAwbiB8fCB3ID49IE1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnYoU2lnbmF0dXJlLnMpIHNob3VsZCBiZSBbMSwgJHtNQVhfVkFMVUV9KWApO1xufVxuZnVuY3Rpb24gY2hlY2tNZXNzYWdlKG1zZ0hhc2gpIHtcbiAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIGNvbnN0IG51bSA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICBpZiAobnVtID49IE1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtc2dIYXNoIHNob3VsZCBiZSBbMCwgJHtNQVhfVkFMVUV9KWApO1xuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpIHtcbiAgICBjb25zdCBzaWcgPSBjdXJ2ZS5zaWduKGNoZWNrTWVzc2FnZShtc2dIYXNoKSwgbm9ybVByaXZLZXkocHJpdktleSksIG9wdHMpO1xuICAgIGNoZWNrU2lnbmF0dXJlKHNpZyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJLZXkpIHtcbiAgICBpZiAoIShzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tREVSKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3QoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGN1cnZlLnZlcmlmeShzaWduYXR1cmUsIGNoZWNrTWVzc2FnZShtc2dIYXNoKSwgZW5zdXJlQnl0ZXMocHViS2V5KSk7XG59XG5jb25zdCB7IENVUlZFLCBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSwgdXRpbHMgfSA9IGN1cnZlO1xuZXhwb3J0IHsgQ1VSVkUsIFByb2plY3RpdmVQb2ludCwgU2lnbmF0dXJlLCB1dGlscyB9O1xuZnVuY3Rpb24gZXh0cmFjdFgoYnl0ZXMpIHtcbiAgICBjb25zdCBoZXggPSB1LmJ5dGVzVG9IZXgoYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgIGNvbnN0IHN0cmlwcGVkID0gaGV4LnJlcGxhY2UoL14wKy9nbSwgJycpO1xuICAgIHJldHVybiBgMHgke3N0cmlwcGVkfWA7XG59XG5mdW5jdGlvbiBzdHJpcDB4KGhleCkge1xuICAgIHJldHVybiBoZXgucmVwbGFjZSgvXjB4L2ksICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBncmluZEtleShzZWVkKSB7XG4gICAgY29uc3QgX3NlZWQgPSBlbnN1cmVCeXRlcyhzZWVkKTtcbiAgICBjb25zdCBzaGEyNTZtYXNrID0gMm4gKiogMjU2bjtcbiAgICBjb25zdCBsaW1pdCA9IHNoYTI1Nm1hc2sgLSBtb2Qoc2hhMjU2bWFzaywgQ1VSVkVfT1JERVIpO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNoYTI1Nk51bSh1LmNvbmNhdEJ5dGVzKF9zZWVkLCB1Lm51bWJlclRvVmFyQnl0ZXNCRShCaWdJbnQoaSkpKSk7XG4gICAgICAgIGlmIChrZXkgPCBsaW1pdClcbiAgICAgICAgICAgIHJldHVybiBtb2Qoa2V5LCBDVVJWRV9PUkRFUikudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaSA9PT0gMTAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmluZEtleSBpcyBicm9rZW46IHRyaWVkIDEwMGsgdmFscycpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFya0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIGV4dHJhY3RYKGdldFB1YmxpY0tleShwcml2YXRlS2V5LCB0cnVlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXRoU2lnVG9Qcml2YXRlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHN0cmlwMHgoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGV0aGVyZXVtIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiBncmluZEtleShzaWduYXR1cmUuc3Vic3RyaW5nKDAsIDY0KSk7XG59XG5jb25zdCBNQVNLXzMxID0gMm4gKiogMzFuIC0gMW47XG5jb25zdCBpbnQzMSA9IChuKSA9PiBOdW1iZXIobiAmIE1BU0tfMzEpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRQYXRoKGxheWVyLCBhcHBsaWNhdGlvbiwgZXRoZXJldW1BZGRyZXNzLCBpbmRleCkge1xuICAgIGNvbnN0IGxheWVyTnVtID0gaW50MzEoc2hhMjU2TnVtKGxheWVyKSk7XG4gICAgY29uc3QgYXBwbGljYXRpb25OdW0gPSBpbnQzMShzaGEyNTZOdW0oYXBwbGljYXRpb24pKTtcbiAgICBjb25zdCBldGggPSB1LmhleFRvTnVtYmVyKHN0cmlwMHgoZXRoZXJldW1BZGRyZXNzKSk7XG4gICAgcmV0dXJuIGBtLzI2NDUnLyR7bGF5ZXJOdW19Jy8ke2FwcGxpY2F0aW9uTnVtfScvJHtpbnQzMShldGgpfScvJHtpbnQzMShldGggPj4gMzFuKX0nLyR7aW5kZXh9YDtcbn1cbmNvbnN0IFBFREVSU0VOX1BPSU5UUyA9IFtcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODRuLCAxNzEzOTMxMzI5NTQwNjYwMzc3MDIzNDA2MTA5MTk5NDEwNDE0ODEwNzA1ODY3MjYwODAyMDc4MTg3MDgyMzQ1NTI5MjA3Njk0OTg2biwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoOTk2NzgxMjA1ODMzMDA4Nzc0NTE0NTAwMDgyMzc2NzgzMjQ5MTAyMzk2MDIzNjYzNDU0ODEzNDQ3NDIzMTQ3OTc3Mzk3MjMyNzYzbiwgMTY2ODUwMzY3Njc4NjM3NzcyNTgwNTQ4OTM0NDc3MTAyMzkyMTA3OTEyNjU1MjAxOTE2MDE1NjkyMDYzNDYxOTI1NTk3MDQ4NTc4MW4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIyNTE1NjMyNzQ0ODk3NTA1MzUxMTc4ODY0MjY1MzMyMjI0MzUyOTQwNDY0MjgzNDczMjkyMDM2MjcwMjEyNDkxNjk2MTYxODQxODRuLCAxNzk4NzE2MDA3NTYyNzI4OTA1Mjk1NDgwNjc5Nzg5NTI2MzIyMTc1ODY4MzI4MDYyNDIwMjM3NDE5MTQzNTkzMDIxNjc0OTkyOTczbiwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0N24sIDExMzQxMDI3NjczMDA2NDQ4NjI1NTEwMjA5Mzg0NjU0MDEzMzc4NDg2NTI4NjkyOTA1MjQyNjkzMTQ3NDEwNjM5NjEzNTA3MjE1Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDZuLCA3NzY0OTY0NTM2MzMyOTgxNzU0ODM5ODUzOTg2NDg3NTg1ODY1MjU5MzM4MTI1MzY2NTMwODk0MDE5MDUyOTIwNjM3MDg4MTY0MjJuLCAxbiksXG5dO1xuZnVuY3Rpb24gcGVkZXJzZW5QcmVjb21wdXRlKHAxLCBwMikge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gcDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNDg7IGkrKykge1xuICAgICAgICBvdXQucHVzaChwKTtcbiAgICAgICAgcCA9IHAuZG91YmxlKCk7XG4gICAgfVxuICAgIHAgPSBwMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBvdXQucHVzaChwKTtcbiAgICAgICAgcCA9IHAuZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5jb25zdCBQRURFUlNFTl9QT0lOVFMxID0gcGVkZXJzZW5QcmVjb21wdXRlKFBFREVSU0VOX1BPSU5UU1sxXSwgUEVERVJTRU5fUE9JTlRTWzJdKTtcbmNvbnN0IFBFREVSU0VOX1BPSU5UUzIgPSBwZWRlcnNlblByZWNvbXB1dGUoUEVERVJTRU5fUE9JTlRTWzNdLCBQRURFUlNFTl9QT0lOVFNbNF0pO1xuZnVuY3Rpb24gcGVkZXJzZW5BcmcoYXJnKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnYmlnaW50Jykge1xuICAgICAgICB2YWx1ZSA9IGFyZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihhcmcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBlZGVyc2VuQXJnOiAke2FyZ31gKTtcbiAgICAgICAgdmFsdWUgPSBCaWdJbnQoYXJnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdS5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoYXJnKSk7XG4gICAgfVxuICAgIGlmICghKDBuIDw9IHZhbHVlICYmIHZhbHVlIDwgY3VydmUuQ1VSVkUuRnAuT1JERVIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBlZGVyc2VuQXJnIHNob3VsZCBiZSAwIDw9IHZhbHVlIDwgQ1VSVkUuUDogJHt2YWx1ZX1gKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwZWRlcnNlblNpbmdsZShwb2ludCwgdmFsdWUsIGNvbnN0YW50cykge1xuICAgIGxldCB4ID0gcGVkZXJzZW5BcmcodmFsdWUpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjUyOyBqKyspIHtcbiAgICAgICAgY29uc3QgcHQgPSBjb25zdGFudHNbal07XG4gICAgICAgIGlmIChwdC5lcXVhbHMocG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYW1lIHBvaW50Jyk7XG4gICAgICAgIGlmICgoeCAmIDFuKSAhPT0gMG4pXG4gICAgICAgICAgICBwb2ludCA9IHBvaW50LmFkZChwdCk7XG4gICAgICAgIHggPj49IDFuO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVkZXJzZW4oeCwgeSkge1xuICAgIGxldCBwb2ludCA9IFBFREVSU0VOX1BPSU5UU1swXTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB4LCBQRURFUlNFTl9QT0lOVFMxKTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB5LCBQRURFUlNFTl9QT0lOVFMyKTtcbiAgICByZXR1cm4gZXh0cmFjdFgocG9pbnQudG9SYXdCeXRlcyh0cnVlKSk7XG59XG5leHBvcnQgY29uc3QgY29tcHV0ZUhhc2hPbkVsZW1lbnRzID0gKGRhdGEsIGZuID0gcGVkZXJzZW4pID0+IFswLCAuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBmbih4LCB5KSk7XG5jb25zdCBNQVNLXzI1MCA9IHUuYml0TWFzaygyNTApO1xuZXhwb3J0IGNvbnN0IGtlY2NhayA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRShrZWNjYWtfMjU2KGRhdGEpKSAmIE1BU0tfMjUwO1xuY29uc3Qgc2hhMjU2TnVtID0gKGRhdGEpID0+IHUuYnl0ZXNUb051bWJlckJFKHNoYTI1NihkYXRhKSk7XG5leHBvcnQgY29uc3QgRnAyNTEgPSBGaWVsZChCaWdJbnQoJzM2MTg1MDI3ODg2NjYxMzEyMTM2OTczMjI3ODMwOTUwNzAxMDU2MjMxMDcyMTUzMzE1OTY2OTk5NzMwOTIwNTYxMzU4NzIwMjA0ODEnKSk7XG5mdW5jdGlvbiBwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIG5hbWUsIGlkeCkge1xuICAgIGNvbnN0IHZhbCA9IEZwLmZyb21CeXRlcyhzaGEyNTYodXRmOFRvQnl0ZXMoYCR7bmFtZX0ke2lkeH1gKSkpO1xuICAgIHJldHVybiBGcC5jcmVhdGUodmFsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfcG9zZWlkb25NRFMoRnAsIG5hbWUsIG0sIGF0dGVtcHQgPSAwKSB7XG4gICAgY29uc3QgeF92YWx1ZXMgPSBbXTtcbiAgICBjb25zdCB5X3ZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgIHhfdmFsdWVzLnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBgJHtuYW1lfXhgLCBhdHRlbXB0ICogbSArIGkpKTtcbiAgICAgICAgeV92YWx1ZXMucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIGAke25hbWV9eWAsIGF0dGVtcHQgKiBtICsgaSkpO1xuICAgIH1cbiAgICBpZiAobmV3IFNldChbLi4ueF92YWx1ZXMsIC4uLnlfdmFsdWVzXSkuc2l6ZSAhPT0gMiAqIG0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWCBhbmQgWSB2YWx1ZXMgYXJlIG5vdCBkaXN0aW5jdCcpO1xuICAgIHJldHVybiB4X3ZhbHVlcy5tYXAoKHgpID0+IHlfdmFsdWVzLm1hcCgoeSkgPT4gRnAuaW52KEZwLnN1Yih4LCB5KSkpKTtcbn1cbmNvbnN0IE1EU19TTUFMTCA9IFtcbiAgICBbMywgMSwgMV0sXG4gICAgWzEsIC0xLCAxXSxcbiAgICBbMSwgMSwgLTJdLFxuXS5tYXAoKGkpID0+IGkubWFwKEJpZ0ludCkpO1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uQmFzaWMob3B0cywgbWRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChvcHRzLkZwKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMucmF0ZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMuY2FwYWNpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2VpZG9uIG9wdHM6ICR7b3B0c31gKTtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBjb25zdCByb3VuZHMgPSBvcHRzLnJvdW5kc0Z1bGwgKyBvcHRzLnJvdW5kc1BhcnRpYWw7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKylcbiAgICAgICAgICAgIHJvdy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChvcHRzLkZwLCAnSGFkZXMnLCBtICogaSArIGopKTtcbiAgICAgICAgcm91bmRDb25zdGFudHMucHVzaChyb3cpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBwb3NlaWRvbih7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHQ6IG0sXG4gICAgICAgIHNib3hQb3dlcjogMyxcbiAgICAgICAgcmV2ZXJzZVBhcnRpYWxQb3dJZHg6IHRydWUsXG4gICAgICAgIG1kcyxcbiAgICAgICAgcm91bmRDb25zdGFudHMsXG4gICAgfSk7XG4gICAgcmVzLm0gPSBtO1xuICAgIHJlcy5yYXRlID0gb3B0cy5yYXRlO1xuICAgIHJlcy5jYXBhY2l0eSA9IG9wdHMuY2FwYWNpdHk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkNyZWF0ZShvcHRzLCBtZHNBdHRlbXB0ID0gMCkge1xuICAgIGNvbnN0IG0gPSBvcHRzLnJhdGUgKyBvcHRzLmNhcGFjaXR5O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobWRzQXR0ZW1wdCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgbWRzQXR0ZW1wdD0ke21kc0F0dGVtcHR9YCk7XG4gICAgcmV0dXJuIHBvc2VpZG9uQmFzaWMob3B0cywgX3Bvc2VpZG9uTURTKG9wdHMuRnAsICdIYWRlc01EUycsIG0sIG1kc0F0dGVtcHQpKTtcbn1cbmV4cG9ydCBjb25zdCBwb3NlaWRvblNtYWxsID0gcG9zZWlkb25CYXNpYyh7IEZwOiBGcDI1MSwgcmF0ZTogMiwgY2FwYWNpdHk6IDEsIHJvdW5kc0Z1bGw6IDgsIHJvdW5kc1BhcnRpYWw6IDgzIH0sIE1EU19TTUFMTCk7XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoKHgsIHksIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIHJldHVybiBmbihbeCwgeSwgMm5dKVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hGdW5jKHgsIHksIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIHJldHVybiB1Lm51bWJlclRvVmFyQnl0ZXNCRShwb3NlaWRvbkhhc2godS5ieXRlc1RvTnVtYmVyQkUoeCksIHUuYnl0ZXNUb051bWJlckJFKHkpLCBmbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaFNpbmdsZSh4LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gZm4oW3gsIDBuLCAxbl0pWzBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaE1hbnkodmFsdWVzLCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICBjb25zdCB7IG0sIHJhdGUgfSA9IGZuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBhcnJheSBleHBlY3RlZCBpbiB2YWx1ZXMnKTtcbiAgICBjb25zdCBwYWRkZWQgPSBBcnJheS5mcm9tKHZhbHVlcyk7XG4gICAgcGFkZGVkLnB1c2goMW4pO1xuICAgIHdoaWxlIChwYWRkZWQubGVuZ3RoICUgcmF0ZSAhPT0gMClcbiAgICAgICAgcGFkZGVkLnB1c2goMG4pO1xuICAgIGxldCBzdGF0ZSA9IG5ldyBBcnJheShtKS5maWxsKDBuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZC5sZW5ndGg7IGkgKz0gcmF0ZSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhdGU7IGorKylcbiAgICAgICAgICAgIHN0YXRlW2pdICs9IHBhZGRlZFtpICsgal07XG4gICAgICAgIHN0YXRlID0gZm4oc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVbMF07XG59XG4iXSwibmFtZXMiOlsia2VjY2FrXzI1NiIsInNoYTI1NiIsInV0ZjhUb0J5dGVzIiwiRmllbGQiLCJtb2QiLCJ2YWxpZGF0ZUZpZWxkIiwiaW52ZXJ0IiwicG9zZWlkb24iLCJ3ZWllcnN0cmFzcyIsIkRFUiIsInUiLCJnZXRIYXNoIiwiQ1VSVkVfT1JERVIiLCJCaWdJbnQiLCJNQVhfVkFMVUUiLCJuQml0TGVuZ3RoIiwiYml0czJpbnQiLCJieXRlcyIsInN1YmFycmF5IiwiZGVsdGEiLCJsZW5ndGgiLCJudW0iLCJieXRlc1RvTnVtYmVyQkUiLCJoZXgweFRvQnl0ZXMiLCJoZXgiLCJzdHJpcDB4IiwiaGV4VG9CeXRlcyIsImN1cnZlIiwiYSIsImIiLCJGcCIsIm4iLCJHeCIsIkd5IiwiaCIsImxvd1MiLCJiaXRzMmludF9tb2ROIiwidG9TdHJpbmciLCJfc3RhcmtDdXJ2ZSIsImVuc3VyZUJ5dGVzIiwibm9ybVByaXZLZXkiLCJwcml2S2V5IiwiYnl0ZXNUb0hleCIsInBhZFN0YXJ0IiwiZ2V0UHVibGljS2V5IiwiaXNDb21wcmVzc2VkIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdktleUEiLCJwdWJLZXlCIiwiY2hlY2tTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJyIiwicyIsIkVycm9yIiwidyIsImNoZWNrTWVzc2FnZSIsIm1zZ0hhc2giLCJzaWduIiwib3B0cyIsInNpZyIsInZlcmlmeSIsInB1YktleSIsIlNpZ25hdHVyZSIsImZyb21ERVIiLCJkZXJFcnJvciIsIkVyciIsImZyb21Db21wYWN0IiwiQ1VSVkUiLCJQcm9qZWN0aXZlUG9pbnQiLCJ1dGlscyIsImV4dHJhY3RYIiwic3RyaXBwZWQiLCJyZXBsYWNlIiwiZ3JpbmRLZXkiLCJzZWVkIiwiX3NlZWQiLCJzaGEyNTZtYXNrIiwibGltaXQiLCJpIiwia2V5Iiwic2hhMjU2TnVtIiwiY29uY2F0Qnl0ZXMiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJnZXRTdGFya0tleSIsInByaXZhdGVLZXkiLCJldGhTaWdUb1ByaXZhdGUiLCJzdWJzdHJpbmciLCJNQVNLXzMxIiwiaW50MzEiLCJOdW1iZXIiLCJnZXRBY2NvdW50UGF0aCIsImxheWVyIiwiYXBwbGljYXRpb24iLCJldGhlcmV1bUFkZHJlc3MiLCJpbmRleCIsImxheWVyTnVtIiwiYXBwbGljYXRpb25OdW0iLCJldGgiLCJoZXhUb051bWJlciIsIlBFREVSU0VOX1BPSU5UUyIsInBlZGVyc2VuUHJlY29tcHV0ZSIsInAxIiwicDIiLCJvdXQiLCJwIiwicHVzaCIsImRvdWJsZSIsIlBFREVSU0VOX1BPSU5UUzEiLCJQRURFUlNFTl9QT0lOVFMyIiwicGVkZXJzZW5BcmciLCJhcmciLCJ2YWx1ZSIsImlzU2FmZUludGVnZXIiLCJPUkRFUiIsInBlZGVyc2VuU2luZ2xlIiwicG9pbnQiLCJjb25zdGFudHMiLCJ4IiwiaiIsInB0IiwiZXF1YWxzIiwiYWRkIiwicGVkZXJzZW4iLCJ5IiwidG9SYXdCeXRlcyIsImNvbXB1dGVIYXNoT25FbGVtZW50cyIsImRhdGEiLCJmbiIsInJlZHVjZSIsIk1BU0tfMjUwIiwiYml0TWFzayIsImtlY2NhayIsIkZwMjUxIiwicG9zZWlkb25Sb3VuZENvbnN0YW50IiwibmFtZSIsImlkeCIsInZhbCIsImZyb21CeXRlcyIsImNyZWF0ZSIsIl9wb3NlaWRvbk1EUyIsIm0iLCJhdHRlbXB0IiwieF92YWx1ZXMiLCJ5X3ZhbHVlcyIsIlNldCIsInNpemUiLCJtYXAiLCJpbnYiLCJzdWIiLCJNRFNfU01BTEwiLCJwb3NlaWRvbkJhc2ljIiwibWRzIiwicmF0ZSIsImNhcGFjaXR5Iiwicm91bmRzIiwicm91bmRzRnVsbCIsInJvdW5kc1BhcnRpYWwiLCJyb3VuZENvbnN0YW50cyIsInJvdyIsInJlcyIsInQiLCJzYm94UG93ZXIiLCJyZXZlcnNlUGFydGlhbFBvd0lkeCIsInBvc2VpZG9uQ3JlYXRlIiwibWRzQXR0ZW1wdCIsInBvc2VpZG9uU21hbGwiLCJwb3NlaWRvbkhhc2giLCJwb3NlaWRvbkhhc2hGdW5jIiwicG9zZWlkb25IYXNoU2luZ2xlIiwicG9zZWlkb25IYXNoTWFueSIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInBhZGRlZCIsImZyb20iLCJzdGF0ZSIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@scure/starknet/lib/esm/index.js\n");

/***/ })

};
;