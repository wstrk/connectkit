"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/../../node_modules/starknet/dist/index.mjs":
/*!**************************************************!*\
  !*** ../../node_modules/starknet/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ rpc_exports),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Sequencer: () => (/* binding */ sequencer_exports),\n/* harmony export */   SequencerProvider: () => (/* binding */ SequencerProvider),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* binding */ TypedDataRevision),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getDefaultNodeUrl: () => (/* binding */ getDefaultNodeUrl),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/base */ \"(ssr)/../../node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/../../node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lossless-json */ \"(ssr)/../../node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/../../node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pako */ \"(ssr)/../../node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/../../node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! url-join */ \"(ssr)/../../node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    ADDR_BOUND: ()=>ADDR_BOUND,\n    API_VERSION: ()=>API_VERSION,\n    BN_FEE_TRANSACTION_VERSION_1: ()=>BN_FEE_TRANSACTION_VERSION_1,\n    BN_FEE_TRANSACTION_VERSION_2: ()=>BN_FEE_TRANSACTION_VERSION_2,\n    BN_TRANSACTION_VERSION_1: ()=>BN_TRANSACTION_VERSION_1,\n    BN_TRANSACTION_VERSION_2: ()=>BN_TRANSACTION_VERSION_2,\n    BaseUrl: ()=>BaseUrl,\n    HEX_STR_TRANSACTION_VERSION_1: ()=>HEX_STR_TRANSACTION_VERSION_1,\n    HEX_STR_TRANSACTION_VERSION_2: ()=>HEX_STR_TRANSACTION_VERSION_2,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MAX_STORAGE_ITEM_SIZE: ()=>MAX_STORAGE_ITEM_SIZE,\n    NetworkName: ()=>NetworkName,\n    RPC_DEFAULT_VERSION: ()=>RPC_DEFAULT_VERSION,\n    RPC_NODES: ()=>RPC_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\n\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar HEX_STR_TRANSACTION_VERSION_1 = \"0x1\";\nvar HEX_STR_TRANSACTION_VERSION_2 = \"0x2\";\nvar BN_TRANSACTION_VERSION_1 = 1n;\nvar BN_TRANSACTION_VERSION_2 = 2n;\nvar BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1;\nvar BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n    BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n    NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId4)=>{\n    StarknetChainId4[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId4[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n    StarknetChainId4[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n    return StarknetChainId4;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_5\";\nvar RPC_NODES = {\n    SN_GOERLI: [\n        `https://starknet-testnet.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/goerli-juno/`\n    ],\n    SN_MAIN: [\n        `https://starknet-mainnet.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/mainnet-juno/`\n    ],\n    SN_SEPOLIA: [\n        `https://starknet-sepolia.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/sepolia-juno/`\n    ]\n};\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Literal: ()=>Literal,\n    RPC: ()=>rpc_exports,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    Sequencer: ()=>sequencer_exports,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    TypedDataRevision: ()=>TypedDataRevision,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2)=>{\n    SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n    return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2)=>{\n    Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    return Literal2;\n})(Literal || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"pending\"] = \"pending\";\n    BlockTag2[\"latest\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/typedData.ts\nvar TypedDataRevision = /* @__PURE__ */ ((TypedDataRevision2)=>{\n    TypedDataRevision2[\"Active\"] = \"1\";\n    TypedDataRevision2[\"Legacy\"] = \"0\";\n    return TypedDataRevision2;\n})(TypedDataRevision || {});\n// src/types/api/rpc.ts\nvar rpc_exports = {};\n__export(rpc_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    Errors: ()=>errors_exports,\n    JRPC: ()=>jsonrpc_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2)=>{\n    EDataAvailabilityMode2[\"L1\"] = \"L1\";\n    EDataAvailabilityMode2[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\n// src/types/api/sequencer.ts\nvar sequencer_exports = {};\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isHex: ()=>isHex,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\n\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n    return res;\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex)=>hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toHex(x));\n}\nvar isStringWholeNumber = (value)=>/^\\d+$/.test(value);\nfunction getDecimalString(value) {\n    if (isHex(value)) {\n        return hexToDecimalString(value);\n    }\n    if (isStringWholeNumber(value)) {\n        return value;\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n    return value.map((el)=>getHexString(el));\n}\nvar toCairoBool = (value)=>(+value).toString();\nfunction hexToBytes(value) {\n    if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n    let adaptedValue = removeHexPrefix(value);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(adaptedValue);\n}\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\n\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash = BigInt(keccakHex(str));\n    return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n    return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLiteral: ()=>isTypeLiteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256\n});\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nfunction uint256ToBN(uint2562) {\n    return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);\n}\nfunction isUint256(bn) {\n    return toBigInt(bn) <= UINT_256_MAX;\n}\nfunction bnToUint256(bn) {\n    const bi = toBigInt(bn);\n    if (!isUint256(bi)) throw new Error(\"Number is too large\");\n    return {\n        low: addHexPrefix((bi & UINT_128_MAX).toString(16)),\n        high: addHexPrefix((bi >> 128n).toString(16))\n    };\n}\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeLiteral = (type)=>Object.values(Literal).includes(type);\nvar isTypeUint256 = (type)=>type === \"core::integer::u256\";\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo } = getAbiContractVersion(abi);\n    if (cairo === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    const bn = BigInt(it);\n    if (!isUint256(bn)) throw new Error(\"Number is too large\");\n    return {\n        // eslint-disable-next-line no-bitwise\n        low: (bn & UINT_128_MAX).toString(10),\n        // eslint-disable-next-line no-bitwise\n        high: (bn >> 128n).toString(10)\n    };\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isText(it)) {\n        if (!isShortString(it)) throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);\n        const encoded = encodeShortString(it);\n        return BigInt(encoded).toString();\n    }\n    if (typeof it === \"string\" && isHex(it)) {\n        return BigInt(it).toString();\n    }\n    if (typeof it === \"string\" && isStringWholeNumber(it)) {\n        return it;\n    }\n    if (typeof it === \"boolean\") {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have at least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    const recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeUint256(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (typeof myArray === \"string\") {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case isTypeUint256(type):\n            const el_uint256 = uint256(val);\n            return [\n                felt(el_uint256.low),\n                felt(el_uint256.high)\n            ];\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseUint256(element) {\n    if (typeof element === \"object\") {\n        const { low, high } = element;\n        return [\n            felt(low),\n            felt(high)\n        ];\n    }\n    const el_uint256 = uint256(element);\n    return [\n        felt(el_uint256.low),\n        felt(el_uint256.high)\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (isTypeUint256(type)) {\n            return parseUint256(element);\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (isTypeUint256(type)) {\n        return parseUint256(element);\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (typeof value === \"string\") {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case isTypeUint256(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return uint256ToBN({\n                low,\n                high\n            });\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (isTypeUint256(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return uint256ToBN({\n            low,\n            high\n        });\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num)=>{\n            if (num === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\", `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (typeof parameter === \"string\" && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateUint = (parameter, input)=>{\n    if (typeof parameter === \"number\") {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    const param = typeof parameter === \"object\" ? uint256ToBN(parameter) : toBigInt(parameter);\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(typeof parameter === \"boolean\", `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAddress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLiteral(baseType):\n            parameter.forEach((param)=>validateUint(param, input));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLiteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class {\n    constructor(abi){\n        this.structs = CallData.getAbiStruct(abi);\n        this.enums = CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    else if (isLongText(value)) value = splitLongString(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n    /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */ decodeParameters(typeCairo, response) {\n        const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [\n            typeCairo\n        ];\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const decodedArray = typeCairoArray.map((typeParam)=>responseParser(responseIterator, {\n                name: \"\",\n                type: typeParam\n            }, this.structs, this.enums));\n        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n    }\n};\n// src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computePedersenHash: ()=>computePedersenHash,\n    computePedersenHashOnElements: ()=>computePedersenHashOnElements,\n    computePoseidonHash: ()=>computePoseidonHash,\n    computePoseidonHashOnElements: ()=>computePoseidonHashOnElements,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    default: ()=>computeHintedClassHash,\n    feeTransactionVersion: ()=>feeTransactionVersion,\n    feeTransactionVersion_2: ()=>feeTransactionVersion_2,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    getVersionsByType: ()=>getVersionsByType,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__,\n    starknetKeccak: ()=>starknetKeccak,\n    transactionVersion: ()=>transactionVersion,\n    transactionVersion_2: ()=>transactionVersion_2\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__,\n    weierstrass: ()=>_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__\n});\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x)=>{\n    if (!lossless_json__WEBPACK_IMPORTED_MODULE_5__.isInteger(x)) return parseFloat(x);\n    const v = parseInt(x, 10);\n    return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash.ts\n\nvar transactionVersion = BN_TRANSACTION_VERSION_1;\nvar transactionVersion_2 = BN_TRANSACTION_VERSION_2;\nvar feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1;\nvar feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: feeTransactionVersion,\n        v2: feeTransactionVersion_2\n    } : {\n        v1: transactionVersion,\n        v2: transactionVersion_2\n    };\n}\nfunction computePedersenHash(a, b) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n    return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements;\nfunction computePoseidonHashOnElements(data) {\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(data.map((x)=>BigInt(x))));\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName = \"constructor\") {\n    return calculateTransactionHashCommon(\"0x6465706c6f79\" /* DEPLOY */ , version, contractAddress, getSelectorFromName(constructorName), constructorCalldata, 0, chainId);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    const hash = computeHashOnElements([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n    return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements(compiledContract.program.data);\n    return computeHashOnElements([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray\n});\n\n\nfunction compressProgram(jsonProgram) {\n    const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_6__.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_6__.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey();\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n    const overHeadPercent = Math.round((1 + overhead) * 100);\n    return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/fetchPonyfill.ts\n\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    createSierraContractClass: ()=>createSierraContractClass,\n    parseContract: ()=>parseContract,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    parseGetBlockResponse(res) {\n        return {\n            timestamp: res.timestamp,\n            block_hash: \"block_hash\" in res ? res.block_hash : \"\",\n            block_number: \"block_number\" in res ? res.block_number : -1,\n            new_root: \"new_root\" in res ? res.new_root : \"\",\n            parent_hash: res.parent_hash,\n            status: \"status\" in res ? res.status : \"PENDING\" /* PENDING */ ,\n            transactions: res.transactions\n        };\n    }\n    parseGetTransactionResponse(res) {\n        return {\n            calldata: \"calldata\" in res ? res.calldata : [],\n            contract_address: \"contract_address\" in res ? res.contract_address : \"\",\n            sender_address: \"sender_address\" in res ? res.sender_address : \"\",\n            max_fee: \"max_fee\" in res ? res.max_fee : \"\",\n            nonce: \"nonce\" in res ? res.nonce : \"\",\n            signature: \"signature\" in res ? res.signature : [],\n            transaction_hash: res.transaction_hash,\n            version: res.version\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        return {\n            overall_fee: toBigInt(res[0].overall_fee),\n            gas_consumed: toBigInt(res[0].gas_consumed),\n            gas_price: toBigInt(res[0].gas_price)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price)\n            }));\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res\n        };\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n        };\n    }\n};\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n            return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\n// src/provider/starknetId.ts\nasync function getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const hexDomain = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"address_to_domain\",\n            calldata: CallData.compile({\n                address\n            })\n        });\n        const decimalDomain = hexDomain.result.map((element)=>BigInt(element)).slice(1);\n        const stringDomain = useDecoded(decimalDomain);\n        if (!stringDomain) {\n            throw Error(\"Starkname not found\");\n        }\n        return stringDomain;\n    } catch (e) {\n        if (e instanceof Error && e.message === \"Starkname not found\") {\n            throw e;\n        }\n        throw Error(\"Could not get stark name\");\n    }\n}\nasync function getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const addressData = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"domain_to_address\",\n            calldata: CallData.compile({\n                domain: [\n                    useEncoded(name.replace(\".stark\", \"\")).toString(10)\n                ]\n            })\n        });\n        return addressData.result[0];\n    } catch  {\n        throw Error(\"Could not get address from stark name\");\n    }\n}\n// src/provider/utils.ts\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    setIdentifier(__identifier) {\n        if (typeof __identifier === \"string\" && isHex(__identifier)) {\n            this.hash = __identifier;\n        } else if (typeof __identifier === \"bigint\") {\n            this.hash = toHex(__identifier);\n        } else if (typeof __identifier === \"number\") {\n            this.number = __identifier;\n        } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n            this.tag = __identifier;\n        } else {\n            this.tag = \"pending\" /* pending */ ;\n        }\n    }\n    constructor(_identifier){\n        this.hash = null;\n        this.number = null;\n        this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    // TODO: fix any\n    get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n    get sequencerIdentifier() {\n        return this.hash !== null ? {\n            blockHash: this.hash\n        } : {\n            blockNumber: this.number ?? this.tag\n        };\n    }\n};\n// src/provider/rpc.ts\nvar getDefaultNodeUrl = (networkName, mute = false, version = RPC_DEFAULT_VERSION)=>{\n    if (!mute) console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    const nodes = RPC_NODES[networkName ?? \"SN_GOERLI\" /* SN_GOERLI */ ];\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return `${nodes[randIdx]}${version}`;\n};\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* pending */ ,\n    retries: 200\n};\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.responseParser = new RPCResponseParser();\n        /**\n   * @deprecated renamed to getBlockLatestAccepted(); (will be removed in next minor version)\n   */ this.getBlockHashAndNumber = this.getBlockLatestAccepted;\n        /**\n   * @deprecated renamed to getBlockStateUpdate();\n   */ this.getStateUpdate = this.getBlockStateUpdate;\n        /**\n   * Returns the execution traces of all transactions included in the given block\n   * @deprecated renamed to getBlockTransactionsTraces()\n   */ this.traceBlockTransactions = this.getBlockTransactionsTraces;\n        /**\n   * Get the number of transactions in a block given a block id\n   * @deprecated renamed to getBlockTransactionCount()\n   * @returns Number of transactions\n   */ this.getTransactionCount = this.getBlockTransactionCount;\n        /**\n   * @deprecated renamed to getTransactionTrace();\n   * For a given executed transaction, return the trace of its execution, including internal calls\n   */ this.traceTransaction = this.getTransactionTrace;\n        /**\n   * @deprecated renamed to simulateTransaction();\n   */ this.getSimulateTransaction = this.simulateTransaction;\n        const { nodeUrl, retries, headers, blockIdentifier, chainId, rpcVersion } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default, rpcVersion);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default, rpcVersion);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n        return this.chainId;\n    }\n    /**\n   * NEW: Returns the version of the Starknet JSON-RPC specification being used\n   */ async getSpecVersion() {\n        return this.fetchEndpoint(\"starknet_specVersion\");\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * @deprecated use getBlockWithTxHashes or getBlockWithTxs (will be removed on sequencer deprecation)\n   */ async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * @deprecated redundant use getBlockLatestAccepted();\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    async getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    async getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    async getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlock(\"pending\" /* pending */ );\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    /**\n   * @deprecated use getTransactionByHash or getTransactionByBlockIdAndIndex (will be removed on sequencer deprecation)\n   */ async getTransaction(txHash) {\n        return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);\n    }\n    async getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    async getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * NEW: Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async simulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipFeeCharge = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        }).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            rpc_exports.ETransactionStatus.REJECTED\n        ];\n        const successStates = options?.successStates ?? [\n            rpc_exports.ETransactionExecutionStatus.SUCCEEDED,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCode(_contractAddress, _blockIdentifier) {\n        throw new Error(\"RPC does not implement getCode function\");\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        if (skipValidate) {\n            console.warn(\"getEstimateFeeBulk RPC does not support skipValidate\");\n        }\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id\n        }).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n            invoke_transaction: {\n                sender_address: functionInvocation.contractAddress,\n                calldata: CallData.toHex(functionInvocation.calldata),\n                type: rpc_exports.ETransactionType.INVOKE,\n                max_fee: toHex(details.maxFee || 0),\n                version: \"0x1\",\n                signature: signatureToHexArray(functionInvocation.signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpc_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: HEX_STR_TRANSACTION_VERSION_1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        }\n        return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n            declare_transaction: {\n                type: rpc_exports.ETransactionType.DECLARE,\n                contract_class: {\n                    sierra_program: decompressProgram(contract.sierra_program),\n                    contract_class_version: contract.contract_class_version,\n                    entry_points_by_type: contract.entry_points_by_type,\n                    abi: contract.abi\n                },\n                compiled_class_hash: compiledClassHash || \"\",\n                version: HEX_STR_TRANSACTION_VERSION_2,\n                max_fee: toHex(details.maxFee || 0),\n                signature: signatureToHexArray(signature),\n                sender_address: senderAddress,\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n            deploy_account_transaction: {\n                constructor_calldata: CallData.toHex(constructorCalldata || []),\n                class_hash: toHex(classHash),\n                contract_address_salt: toHex(addressSalt || 0),\n                type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(details.version || 0),\n                signature: signatureToHexArray(signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const result = await this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n        return this.responseParser.parseCallContractResponse(result);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: toHex(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    /**\n   * StarknetId Endpoint (get name from address)\n   */ async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    /**\n   * StarknetId Endpoint (get address from name)\n   */ async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToHexArray(invocation.signature),\n            nonce: toHex(invocation.nonce),\n            max_fee: toHex(invocation.maxFee || 0)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: rpc_exports.ETransactionType.INVOKE,\n                // Diff between sequencer and rpc invoke type\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // compiled_class_hash\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/sequencer.ts\n\n// src/utils/responseParser/index.ts\nvar ResponseParser = class {\n};\n// src/utils/responseParser/sequencer.ts\nvar SequencerAPIResponseParser = class extends ResponseParser {\n    parseGetBlockResponse(res) {\n        return {\n            ...res,\n            new_root: res.state_root,\n            parent_hash: res.parent_block_hash,\n            transactions: Object.values(res.transactions).map((value)=>\"transaction_hash\" in value && value.transaction_hash).filter(Boolean)\n        };\n    }\n    parseGetTransactionResponse(res) {\n        if (res.status === \"NOT_RECEIVED\" /* NOT_RECEIVED */  && res.finality_status === \"NOT_RECEIVED\" /* NOT_RECEIVED */ ) {\n            throw new LibraryError();\n        }\n        return {\n            ...res,\n            calldata: \"calldata\" in res.transaction ? res.transaction.calldata : [],\n            contract_class: \"contract_class\" in res.transaction ? res.transaction.contract_class : void 0,\n            entry_point_selector: \"entry_point_selector\" in res.transaction ? res.transaction.entry_point_selector : void 0,\n            max_fee: \"max_fee\" in res.transaction ? res.transaction.max_fee : void 0,\n            nonce: res.transaction.nonce,\n            sender_address: \"sender_address\" in res.transaction ? res.transaction.sender_address : void 0,\n            signature: \"signature\" in res.transaction ? res.transaction.signature : void 0,\n            transaction_hash: \"transaction_hash\" in res.transaction ? res.transaction.transaction_hash : void 0,\n            version: \"version\" in res.transaction ? res.transaction.version : void 0\n        };\n    }\n    parseGetTransactionReceiptResponse(res) {\n        return {\n            ...res,\n            messages_sent: res.l2_to_l1_messages,\n            ...\"revert_error\" in res && {\n                revert_reason: res.revert_error\n            }\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        if (\"overall_fee\" in res) {\n            let gasInfo = {};\n            try {\n                gasInfo = {\n                    gas_consumed: toBigInt(res.gas_usage),\n                    gas_price: toBigInt(res.gas_price)\n                };\n            } catch  {}\n            return {\n                overall_fee: toBigInt(res.overall_fee),\n                ...gasInfo\n            };\n        }\n        return {\n            overall_fee: toBigInt(res.amount)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return [].concat(res).map((item)=>{\n            if (\"overall_fee\" in item) {\n                let gasInfo = {};\n                try {\n                    gasInfo = {\n                        gas_consumed: toBigInt(item.gas_usage),\n                        gas_price: toBigInt(item.gas_price)\n                    };\n                } catch  {}\n                return {\n                    overall_fee: toBigInt(item.overall_fee),\n                    ...gasInfo\n                };\n            }\n            return {\n                overall_fee: toBigInt(item.amount)\n            };\n        });\n    }\n    parseSimulateTransactionResponse(res) {\n        const suggestedMaxFee = \"overall_fee\" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;\n        return [\n            {\n                transaction_trace: res.trace,\n                fee_estimation: res.fee_estimation,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))\n            }\n        ];\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res.result\n        };\n    }\n    parseInvokeFunctionResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash\n        };\n    }\n    parseDeployContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            contract_address: res.address\n        };\n    }\n    parseDeclareContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            class_hash: res.class_hash\n        };\n    }\n    parseGetStateUpdateResponse(res) {\n        const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce])=>({\n                contract_address,\n                nonce\n            }));\n        const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(([address, storage_entries])=>({\n                address,\n                storage_entries\n            }));\n        return {\n            ...res,\n            state_diff: {\n                ...res.state_diff,\n                storage_diffs,\n                nonces\n            }\n        };\n    }\n    parseContractClassResponse(res) {\n        const response = isSierra(res) ? res : parseContract(res);\n        return {\n            ...response,\n            abi: typeof response.abi === \"string\" ? JSON.parse(response.abi) : response.abi\n        };\n    }\n};\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/provider/sequencer.ts\nfunction isEmptyQueryObject(obj) {\n    return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v])=>k === \"blockIdentifier\" && v === null);\n}\nvar defaultOptions2 = {\n    network: \"SN_GOERLI\" /* SN_GOERLI */ ,\n    blockIdentifier: \"pending\" /* pending */ \n};\nvar SequencerProvider = class {\n    constructor(optionsOrProvider = defaultOptions2){\n        this.responseParser = new SequencerAPIResponseParser();\n        if (\"network\" in optionsOrProvider) {\n            this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\");\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\");\n        } else {\n            this.baseUrl = optionsOrProvider.baseUrl;\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\", optionsOrProvider.feederGatewayUrl);\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\", optionsOrProvider.gatewayUrl);\n        }\n        this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);\n        this.headers = optionsOrProvider.headers;\n        this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier;\n    }\n    static getNetworkFromName(name) {\n        switch(name){\n            case \"SN_MAIN\" /* SN_MAIN */ :\n            case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n                return \"https://alpha-mainnet.starknet.io\" /* SN_MAIN */ ;\n            case \"SN_GOERLI\" /* SN_GOERLI */ :\n            case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n                return \"https://alpha4.starknet.io\" /* SN_GOERLI */ ;\n            default:\n                throw new Error(\"Could not detect base url from NetworkName\");\n        }\n    }\n    static getChainIdFromBaseUrl(baseUrl) {\n        try {\n            const url = new URL(baseUrl);\n            if (url.host.includes(\"mainnet.starknet.io\")) {\n                return \"0x534e5f4d41494e\" /* SN_MAIN */ ;\n            }\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        } catch  {\n            console.error(`Could not parse baseUrl: ${baseUrl}`);\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        }\n    }\n    getFetchUrl(endpoint) {\n        const gatewayUrlEndpoints = [\n            \"add_transaction\"\n        ];\n        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;\n    }\n    getFetchMethod(endpoint) {\n        const postMethodEndpoints = [\n            \"add_transaction\",\n            \"call_contract\",\n            \"estimate_fee\",\n            \"estimate_message_fee\",\n            \"estimate_fee_bulk\",\n            \"simulate_transaction\"\n        ];\n        return postMethodEndpoints.includes(endpoint) ? \"POST\" : \"GET\";\n    }\n    getQueryString(query) {\n        if (isEmptyQueryObject(query)) {\n            return \"\";\n        }\n        const queryString = Object.entries(query).map(([key, value])=>{\n            if (key === \"blockIdentifier\") {\n                const block = new Block(value);\n                return `${block.queryIdentifier}`;\n            }\n            return `${key}=${value}`;\n        }).join(\"&\");\n        return `?${queryString}`;\n    }\n    getHeaders(method) {\n        if (method === \"POST\") {\n            return {\n                \"Content-Type\": \"application/json\",\n                ...this.headers\n            };\n        }\n        return this.headers;\n    }\n    // typesafe fetch\n    async fetchEndpoint(endpoint, ...[query, request]) {\n        const baseUrl = this.getFetchUrl(endpoint);\n        const method = this.getFetchMethod(endpoint);\n        const queryString = this.getQueryString(query);\n        const url = url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, endpoint, queryString);\n        return this.fetch(url, {\n            method,\n            body: request\n        });\n    }\n    async fetch(endpoint, options) {\n        const url = buildUrl(this.baseUrl, \"\", endpoint);\n        const method = options?.method ?? \"GET\";\n        const headers = this.getHeaders(method);\n        const body = stringify2(options?.body);\n        try {\n            const response = await fetchPonyfill_default(url, {\n                method,\n                body,\n                headers\n            });\n            const textResponse = await response.text();\n            if (!response.ok) {\n                let responseBody;\n                try {\n                    responseBody = parse2(textResponse);\n                } catch  {\n                    throw new HttpError(response.statusText, response.status);\n                }\n                throw new GatewayError(responseBody.message, responseBody.code);\n            }\n            const parseChoice = options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2;\n            return parseChoice(textResponse);\n        } catch (error) {\n            if (error instanceof Error && !(error instanceof LibraryError)) throw Error(`Could not ${method} from endpoint \\`${url}\\`: ${error.message}`);\n            throw error;\n        }\n    }\n    async getChainId() {\n        return Promise.resolve(this.chainId);\n    }\n    async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"call_contract\", {\n            blockIdentifier\n        }, {\n            // TODO - determine best choice once both are fully supported in devnet\n            // signature: [],\n            // sender_address: contractAddress,\n            contract_address: contractAddress,\n            entry_point_selector: getSelectorFromName(entryPointSelector),\n            calldata: CallData.compile(calldata)\n        }).then(this.responseParser.parseCallContractResponse);\n    }\n    async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_block\", {\n            blockIdentifier\n        }).then(this.responseParser.parseGetBlockResponse);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_nonce\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const parsedKey = toBigInt(key).toString(10);\n        return this.fetchEndpoint(\"get_storage_at\", {\n            blockIdentifier,\n            contractAddress,\n            key: parsedKey\n        });\n    }\n    async getTransaction(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction\", {\n            transactionHash: txHashHex\n        }).then((result)=>{\n            if (Object.values(result).length === 1) throw new LibraryError(result.status);\n            return this.responseParser.parseGetTransactionResponse(result);\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_receipt\", {\n            transactionHash: txHashHex\n        }).then(this.responseParser.parseGetTransactionReceiptResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_full_contract\", {\n            blockIdentifier,\n            contractAddress\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_hash_at\", {\n            blockIdentifier,\n            contractAddress\n        });\n    }\n    async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_by_hash\", {\n            classHash,\n            blockIdentifier\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_compiled_class_by_class_hash\", {\n            classHash,\n            blockIdentifier\n        });\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClassByHash(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion requires contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            sender_address: functionInvocation.contractAddress,\n            calldata: CallData.compile(functionInvocation.calldata ?? []),\n            signature: signatureToDecimalArray(functionInvocation.signature),\n            nonce: toHex(details.nonce),\n            max_fee: toHex(details.maxFee || 0),\n            version: \"0x1\"\n        }).then(this.responseParser.parseInvokeFunctionResponse);\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            contract_address_salt: addressSalt ?? randomAddress(),\n            constructor_calldata: CallData.compile(constructorCalldata ?? []),\n            class_hash: toHex(classHash),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(details.version || 0),\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature)\n        }).then(this.responseParser.parseDeployContractResponse);\n    }\n    async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"add_transaction\", void 0, {\n                type: \"DECLARE\" /* DECLARE */ ,\n                contract_class: contract,\n                nonce: toHex(details.nonce),\n                signature: signatureToDecimalArray(signature),\n                sender_address: senderAddress,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(transactionVersion)\n            }).then(this.responseParser.parseDeclareContractResponse);\n        }\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            sender_address: senderAddress,\n            compiled_class_hash: compiledClassHash,\n            contract_class: contract,\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(transactionVersion_2)\n        }).then(this.responseParser.parseDeclareContractResponse);\n    }\n    async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        const transactions = invocations.map((it)=>this.buildTransaction(it, \"fee\"));\n        return this.fetchEndpoint(\"estimate_fee_bulk\", {\n            blockIdentifier,\n            skipValidate\n        }, transactions).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_code\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        let res;\n        let completed = false;\n        let retries = 0;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            \"REJECTED\" /* REJECTED */ ,\n            \"NOT_RECEIVED\" /* NOT_RECEIVED */ ,\n            \"REVERTED\" /* REVERTED */ \n        ];\n        const successStates = options?.successStates ?? [\n            \"SUCCEEDED\" /* SUCCEEDED */ ,\n            \"ACCEPTED_ON_L1\" /* ACCEPTED_ON_L1 */ ,\n            \"ACCEPTED_ON_L2\" /* ACCEPTED_ON_L2 */ \n        ];\n        while(!completed){\n            await wait(retryInterval);\n            res = await this.getTransactionStatus(txHash);\n            if (\"NOT_RECEIVED\" /* NOT_RECEIVED */  === res.finality_status && retries < 3) {\n                retries += 1;\n            } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {\n                completed = true;\n            } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {\n                let message;\n                if (res.tx_failure_reason) {\n                    message = `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}`;\n                } else if (res.tx_revert_reason) {\n                    message = `${res.tx_status}: ${res.tx_revert_reason}`;\n                } else {\n                    message = res.tx_status;\n                }\n                const error = new Error(message);\n                error.response = res;\n                throw error;\n            }\n        }\n        const txReceipt = await this.getTransactionReceipt(txHash);\n        return txReceipt;\n    }\n    /**\n   * Gets the status of a transaction.\n   * @param txHash BigNumberish\n   * @returns GetTransactionStatusResponse - the transaction status object\n   */ async getTransactionStatus(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_status\", {\n            transactionHash: txHashHex\n        });\n    }\n    /**\n   * Gets the smart contract address on the goerli testnet.\n   * @returns GetContractAddressesResponse - starknet smart contract addresses\n   */ async getContractAddresses() {\n        return this.fetchEndpoint(\"get_contract_addresses\");\n    }\n    /**\n   * Gets the transaction trace from a tx id.\n   * @param txHash BigNumberish\n   * @returns TransactionTraceResponse - the transaction trace\n   */ async getTransactionTrace(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_trace\", {\n            transactionHash: txHashHex\n        });\n    }\n    async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {\n        const validCallL1Handler = {\n            from_address: getDecimalString(from_address),\n            to_address: getHexString(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        return this.fetchEndpoint(\"estimate_message_fee\", {\n            blockIdentifier\n        }, validCallL1Handler);\n    }\n    /**\n   * Simulate transaction using Sequencer provider\n   * WARNING!: Sequencer will process only first element from invocations array\n   *\n   * @param invocations Array of invocations, but only first invocation will be processed\n   * @param blockIdentifier block identifier, default 'latest'\n   * @param skipValidate Skip Account __validate__ method\n   * @returns\n   */ async getSimulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipExecute = false }) {\n        if (invocations.length > 1) {\n            console.warn(\"Sequencer simulate process only first element from invocations list\");\n        }\n        if (skipExecute) {\n            console.warn(\"Sequencer can't skip account __execute__\");\n        }\n        const transaction = this.buildTransaction(invocations[0]);\n        return this.fetchEndpoint(\"simulate_transaction\", {\n            blockIdentifier,\n            skipValidate: skipValidate ?? false\n        }, transaction).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async getStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_state_update\", {\n            ...args\n        }).then(this.responseParser.parseGetStateUpdateResponse);\n    }\n    // consider adding an optional trace retrieval parameter to the getBlock method\n    async getBlockTraces(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_block_traces\", {\n            ...args\n        });\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    /**\n   * Build Single AccountTransaction from Single AccountInvocation\n   * @param invocation AccountInvocationItem\n   * @param versionType 'fee' | 'transaction' - used to determine default versions\n   * @returns AccountTransactionItem\n   */ buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToDecimalArray(invocation.signature),\n            nonce: toHex(invocation.nonce)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: invocation.type,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.compile(invocation.calldata ?? []),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    // fee from getDeclareEstimateFee use t.v. instead of feet.v.\n                    ...details\n                };\n            }\n            return {\n                type: invocation.type,\n                contract_class: invocation.contract,\n                compiled_class_hash: invocation.compiledClassHash,\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                // fee on getDeclareEstimateFee use t.v. instead of feet.v.\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.compile(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"Sequencer buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/default.ts\nvar Provider = class {\n    constructor(providerOrOptions){\n        if (providerOrOptions instanceof Provider) {\n            this.provider = providerOrOptions.provider;\n        } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {\n            this.provider = providerOrOptions;\n        } else if (providerOrOptions && \"rpc\" in providerOrOptions) {\n            this.provider = new RpcProvider(providerOrOptions.rpc);\n        } else if (providerOrOptions && \"sequencer\" in providerOrOptions) {\n            this.provider = new SequencerProvider(providerOrOptions.sequencer);\n        } else {\n            this.provider = new RpcProvider();\n        }\n    }\n    async getChainId() {\n        return this.provider.getChainId();\n    }\n    async getBlock(blockIdentifier) {\n        return this.provider.getBlock(blockIdentifier);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassAt(contractAddress, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    getClassByHash(classHash) {\n        return this.provider.getClassByHash(classHash);\n    }\n    async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {\n        return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {\n        return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.provider.getEstimateFeeBulk(invocations, options);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.provider.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.provider.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getTransaction(txHash) {\n        return this.provider.getTransaction(txHash);\n    }\n    async getTransactionReceipt(txHash) {\n        return this.provider.getTransactionReceipt(txHash);\n    }\n    async callContract(request, blockIdentifier) {\n        return this.provider.callContract(request, blockIdentifier);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.provider.invokeFunction(functionInvocation, details);\n    }\n    async deployAccountContract(payload, details) {\n        return this.provider.deployAccountContract(payload, details);\n    }\n    async declareContract(transaction, details) {\n        return this.provider.declareContract(transaction, details);\n    }\n    async getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    async getCode(contractAddress, blockIdentifier) {\n        return this.provider.getCode(contractAddress, blockIdentifier);\n    }\n    async waitForTransaction(txHash, options) {\n        return this.provider.waitForTransaction(txHash, options);\n    }\n    async getSimulateTransaction(invocations, options) {\n        return this.provider.getSimulateTransaction(invocations, options);\n    }\n    async getStateUpdate(blockIdentifier) {\n        return this.provider.getStateUpdate(blockIdentifier);\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    async getContractVersion(contractAddress, classHash, options) {\n        return this.provider.getContractVersion(contractAddress, classHash, options);\n    }\n};\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    TypedDataRevision: ()=>TypedDataRevision,\n    byteArrayFromString: ()=>byteArrayFromString,\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class {\n    constructor(leafHashes, hashMethod = computePedersenHash){\n        this.branches = [];\n        this.hashMethod = hashMethod;\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n            } else {\n                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Create hash from ordered a and b, Pedersen hash default\n   * @returns format: hex-string\n   */ static hash(a, b, hashMethod = computePedersenHash) {\n        const [aSorted, bSorted] = [\n            BigInt(a),\n            BigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return hashMethod(aSorted, bSorted);\n    }\n    /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n// src/utils/typedData.ts\nvar presetTypes = {\n    u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n    TokenAmount: JSON.parse('[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'),\n    NftId: JSON.parse('[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]')\n};\nvar revisionConfiguration = {\n    [\"1\" /* Active */ ]: {\n        domain: \"StarknetDomain\",\n        hashMethod: computePoseidonHashOnElements,\n        hashMerkleMethod: computePoseidonHash,\n        escapeTypeString: (s)=>`\"${s}\"`,\n        presetTypes\n    },\n    [\"0\" /* Legacy */ ]: {\n        domain: \"StarkNetDomain\",\n        hashMethod: computePedersenHashOnElements,\n        hashMerkleMethod: computePedersenHash,\n        escapeTypeString: (s)=>s,\n        presetTypes: {}\n    }\n};\nfunction byteArrayFromString(targetString) {\n    const shortStrings = splitLongString(targetString);\n    const remainder = shortStrings[shortStrings.length - 1];\n    const shortStringsEncoded = shortStrings.map(encodeShortString);\n    const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\n        \"0x00\",\n        0\n    ] : [\n        shortStringsEncoded.pop(),\n        remainder.length\n    ];\n    return {\n        data: shortStringsEncoded.length === 0 ? [\n            \"0x00\"\n        ] : shortStringsEncoded,\n        pending_word: pendingWord,\n        pending_word_len: pendingWordLength\n    };\n}\nfunction identifyRevision({ types, domain }) {\n    if (revisionConfiguration[\"1\" /* Active */ ].domain in types && domain.revision === \"1\" /* Active */ ) return \"1\" /* Active */ ;\n    if (revisionConfiguration[\"0\" /* Legacy */ ].domain in types && (domain.revision ?? \"0\" /* Legacy */ ) === \"0\" /* Legacy */ ) return \"0\" /* Legacy */ ;\n    return void 0;\n}\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (typeof value === \"string\") {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nfunction validateTypedData(data) {\n    const typedData = data;\n    return Boolean(typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData));\n}\nfunction prepareSelector(selector) {\n    return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = \"0\" /* Legacy */ ) {\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    } else if (revision === \"1\" /* Active */ ) {\n        if (type === \"enum\") {\n            type = contains;\n        } else if (type.match(/^\\(.*\\)$/)) {\n            type = type.slice(1, -1);\n        }\n    }\n    if (dependencies.includes(type) || !types[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types, t.type, previous, t.contains, revision).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n}\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nfunction encodeType(types, type, revision = \"0\" /* Legacy */ ) {\n    const [primary, ...dependencies] = getDependencies(types, type, void 0, void 0, revision);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    const esc = revisionConfiguration[revision].escapeTypeString;\n    return newTypes.map((dependency)=>{\n        const dependencyElements = types[dependency].map((t)=>{\n            const targetType = t.type === \"enum\" && revision === \"1\" /* Active */  ? t.contains : t.type;\n            const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e)=>e ? esc(e) : e).join(\",\")})` : esc(targetType);\n            return `${esc(t.name)}:${typeString}`;\n        });\n        return `${esc(dependency)}(${dependencyElements})`;\n    }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = \"0\" /* Legacy */ ) {\n    return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = \"0\" /* Legacy */ ) {\n    if (types[type]) {\n        return [\n            type,\n            getStructHash(types, type, data, revision)\n        ];\n    }\n    if (revisionConfiguration[revision].presetTypes[type]) {\n        return [\n            type,\n            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision)\n        ];\n    }\n    if (type.endsWith(\"*\")) {\n        const hashes = data.map((entry)=>encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]);\n        return [\n            type,\n            revisionConfiguration[revision].hashMethod(hashes)\n        ];\n    }\n    switch(type){\n        case \"enum\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const [variantKey, variantData] = Object.entries(data)[0];\n                    const parentType = types[ctx.parent][0];\n                    const enumType = types[parentType.contains];\n                    const variantType = enumType.find((t)=>t.name === variantKey);\n                    const variantIndex = enumType.indexOf(variantType);\n                    const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index)=>{\n                        if (!subtype) return subtype;\n                        const subtypeData = variantData[index];\n                        return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n                    });\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod([\n                            variantIndex,\n                            ...encodedSubtypes\n                        ])\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"merkletree\":\n            {\n                const merkleTreeType = getMerkleTreeType(types, ctx);\n                const structHashes = data.map((struct)=>{\n                    return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n                });\n                const { root } = new MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod);\n                return [\n                    \"felt\",\n                    root\n                ];\n            }\n        case \"selector\":\n            {\n                return [\n                    \"felt\",\n                    prepareSelector(data)\n                ];\n            }\n        case \"string\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const byteArray = byteArrayFromString(data);\n                    const elements = [\n                        byteArray.data.length,\n                        ...byteArray.data,\n                        byteArray.pending_word,\n                        byteArray.pending_word_len\n                    ];\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod(elements)\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"felt\":\n        case \"bool\":\n        case \"u128\":\n        case \"i128\":\n        case \"ContractAddress\":\n        case \"ClassHash\":\n        case \"timestamp\":\n        case \"shortstring\":\n            return [\n                type,\n                getHex(data)\n            ];\n        default:\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    throw new Error(`Unsupported type: ${type}`);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n    }\n}\nfunction encodeData(types, type, data, revision = \"0\" /* Legacy */ ) {\n    const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n    const [returnTypes, values] = targetType.reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const ctx = {\n            parent: type,\n            key: field.name\n        };\n        const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types, type, revision)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n}\nfunction getStructHash(types, type, data, revision = \"0\" /* Legacy */ ) {\n    return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n    if (!validateTypedData(typedData)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const revision = identifyRevision(typedData);\n    const { domain, hashMethod } = revisionConfiguration[revision];\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData.types, domain, typedData.domain, revision),\n        account,\n        getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n    ];\n    return hashMethod(message);\n}\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey(this.pk);\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signTransaction(transactions, transactionsDetail, abis) {\n        if (abis && abis.length !== transactions.length) {\n            throw new Error(\"ABI must be provided for each transaction or no transaction\");\n        }\n        const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n        const msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce }) {\n        const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash }) {\n        const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n};\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends Provider {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toBigInt(feeTransactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        const response = await super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload({\n            classHash: providedClassHash,\n            contract,\n            casm,\n            compiledClassHash\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeclareEstimateFee(declareContractTransaction, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { blockIdentifier, skipValidate } = {}) {\n        const version = toBigInt(feeTransactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress: providedContractAddress\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeployFee(payload, transactionsDetail) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, transactionsDetail);\n    }\n    async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                feeTransactionVersion,\n                feeTransactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        const response = await super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate\n        });\n        return [].concat(response).map((elem)=>{\n            const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);\n            return {\n                ...elem,\n                suggestedMaxFee\n            };\n        });\n    }\n    async buildInvocation(call, signerDetails) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = await this.signer.signTransaction(call, signerDetails);\n        return {\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async execute(calls, abis = void 0, transactionsDetail = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: calls\n        }, transactionsDetail);\n        const version = toBigInt(transactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n        const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const details = {};\n        details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, transactionsDetail);\n        details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;\n        details.chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {\n            ...details,\n            walletAddress: this.address,\n            cairoVersion: void 0\n        });\n        return this.declareContract(declareContractTransaction, details);\n    }\n    async deploy(payload, details) {\n        const params = [].concat(payload).map((it)=>{\n            const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            const deploySalt = salt ?? randomAddress();\n            return {\n                call: {\n                    contractAddress: UDC.ADDRESS,\n                    entrypoint: UDC.ENTRYPOINT,\n                    calldata: [\n                        classHash,\n                        deploySalt,\n                        toCairoBool(unique),\n                        compiledConstructorCallData.length,\n                        ...compiledConstructorCallData\n                    ]\n                },\n                address: calculateContractAddressFromHash(unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n            };\n        });\n        const calls = params.map((it)=>it.call);\n        const addresses = params.map((it)=>it.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, transactionsDetail = {}) {\n        const version = toBigInt(transactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, transactionsDetail);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    async signMessage(typedData) {\n        return this.signer.signMessage(typedData, this.address);\n    }\n    async hashMessage(typedData) {\n        return getMessageHash(typedData, this.address);\n    }\n    async verifyMessageHash(hash, signature) {\n        try {\n            await this.callContract({\n                contractAddress: this.address,\n                entrypoint: \"isValidSignature\",\n                calldata: CallData.compile({\n                    hash: toBigInt(hash).toString(),\n                    signature: formatSignature(signature)\n                })\n            });\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    async verifyMessage(typedData, signature) {\n        const hash = await this.hashMessage(typedData);\n        return this.verifyMessageHash(hash, signature);\n    }\n    async getSuggestedMaxFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    suggestedMaxFee: ZERO,\n                    overall_fee: ZERO\n                };\n                break;\n        }\n        return feeEstimate.suggestedMaxFee;\n    }\n    /**\n   * will be renamed to buildDeclareContractTransaction\n   */ async buildDeclarePayload(payload, { nonce, chainId, version, walletAddress, maxFee }) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        const signature = await this.signer.signDeclareTransaction({\n            classHash,\n            compiledClassHash,\n            senderAddress: walletAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return {\n            senderAddress: walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { nonce, chainId, version, maxFee }) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            contractAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        });\n        return {\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                transactionVersion,\n                transactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {\n        const version = versions[0];\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction, index)=>{\n            const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n            const signerDetails = {\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                version,\n                chainId,\n                cairoVersion\n            };\n            const common = {\n                type: transaction.type,\n                version,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier\n            };\n            if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DECLARE\" /* DECLARE */ ) {\n                signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    version: signerDetails.version\n                };\n            }\n            if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new Provider({\n    rpc: {\n        default: true\n    }\n});\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    parseEvents: ()=>parseEvents\n});\nfunction getAbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        const abiEvent = abiEvents[recEvent.keys[0]];\n        if (!abiEvent) {\n            return acc;\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        recEvent.keys.shift();\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((x)=>{\n            if (!parseResponse) {\n                return x.result;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, x.result, formatResponse);\n            }\n            return this.callData.parse(method, x.result);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typedv1(tAbi) {\n        return this;\n    }\n    typedv2(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n    return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n    assertInRange(address, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/index.ts\nvar number = num_exports;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmTCxVQUFVSSxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFFQSxtQkFBbUI7QUFDbkIsSUFBSUMsb0JBQW9CLENBQUM7QUFDekJOLFNBQVNNLG1CQUFtQjtJQUMxQkMsWUFBWSxJQUFNQTtJQUNsQkMsYUFBYSxJQUFNQTtJQUNuQkMsOEJBQThCLElBQU1BO0lBQ3BDQyw4QkFBOEIsSUFBTUE7SUFDcENDLDBCQUEwQixJQUFNQTtJQUNoQ0MsMEJBQTBCLElBQU1BO0lBQ2hDQyxTQUFTLElBQU1BO0lBQ2ZDLCtCQUErQixJQUFNQTtJQUNyQ0MsK0JBQStCLElBQU1BO0lBQ3JDQyxZQUFZLElBQU1BO0lBQ2xCQyxVQUFVLElBQU1BO0lBQ2hCQyx1QkFBdUIsSUFBTUE7SUFDN0JDLGFBQWEsSUFBTUE7SUFDbkJDLHFCQUFxQixJQUFNQTtJQUMzQkMsV0FBVyxJQUFNQTtJQUNqQkMsaUJBQWlCLElBQU1BO0lBQ3ZCQyxzQkFBc0IsSUFBTUE7SUFDNUJDLHVCQUF1QixJQUFNQTtJQUM3QkMsS0FBSyxJQUFNQTtJQUNYQyxNQUFNLElBQU1BO0FBQ2Q7QUFFQSxzQkFBc0I7QUFDdEIsSUFBSUMsaUJBQWlCLENBQUM7QUFDdEIzQixTQUFTMkIsZ0JBQWdCO0lBQ3ZCWCxZQUFZLElBQU1BO0lBQ2xCWSxjQUFjLElBQU1BO0lBQ3BCQyxxQkFBcUIsSUFBTUE7SUFDM0JDLGVBQWUsSUFBTUE7SUFDckJDLGVB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QUFLLEVBQUc7UUFDeEMsSUFBSWsxQixNQUFNLENBQUNsMUIsS0FBSyxFQUFFLElBQUksS0FBSyxHQUFHO1lBQzVCaTFCLEtBQUssQ0FBQ2oxQixFQUFFLEdBQUdpMUIsS0FBSyxDQUFDajFCLEVBQUUsQ0FBQ3hQLFdBQVc7UUFDakM7UUFDQSxJQUFJLENBQUMwa0MsTUFBTSxDQUFDbDFCLEtBQUssRUFBRSxHQUFHLEVBQUMsS0FBTSxHQUFHO1lBQzlCaTFCLEtBQUssQ0FBQ2oxQixJQUFJLEVBQUUsR0FBR2kxQixLQUFLLENBQUNqMUIsSUFBSSxFQUFFLENBQUN4UCxXQUFXO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPakQsYUFBYTBuQyxNQUFNMWtDLElBQUksQ0FBQztBQUNqQztBQUNBLFNBQVM0a0Msd0JBQXdCemQsT0FBTztJQUN0QyxPQUFPc2QsbUJBQW1CdGQsYUFBYUE7QUFDekM7QUFFQSxlQUFlO0FBQ2YsSUFBSWMsU0FBU2prQjtBQXdFWCxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJrbmV0LXJlYWN0Ly4uLy4uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4Lm1qcz9mYjExIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBjb25zdGFudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29uc3RhbnRzX2V4cG9ydHMsIHtcbiAgQUREUl9CT1VORDogKCkgPT4gQUREUl9CT1VORCxcbiAgQVBJX1ZFUlNJT046ICgpID0+IEFQSV9WRVJTSU9OLFxuICBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xLFxuICBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE6ICgpID0+IEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gIEJhc2VVcmw6ICgpID0+IEJhc2VVcmwsXG4gIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzI6ICgpID0+IEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBJU19CUk9XU0VSOiAoKSA9PiBJU19CUk9XU0VSLFxuICBNQVNLXzI1MDogKCkgPT4gTUFTS18yNTAsXG4gIE1BWF9TVE9SQUdFX0lURU1fU0laRTogKCkgPT4gTUFYX1NUT1JBR0VfSVRFTV9TSVpFLFxuICBOZXR3b3JrTmFtZTogKCkgPT4gTmV0d29ya05hbWUsXG4gIFJQQ19ERUZBVUxUX1ZFUlNJT046ICgpID0+IFJQQ19ERUZBVUxUX1ZFUlNJT04sXG4gIFJQQ19OT0RFUzogKCkgPT4gUlBDX05PREVTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk9cbn0pO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBTVFJJTkdfWkVSTyA9IFwiMFwiO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb1N0cmluZyhhcnJheSkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gdXRmOFRvQXJyYXkoc3RyKSB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiB1dGY4VG9BcnJheShzdHIpO1xufVxuZnVuY3Rpb24gYXRvYlVuaXZlcnNhbChhKSB7XG4gIHJldHVybiBiYXNlNjQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gYnRvYVVuaXZlcnNhbChiKSB7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbmZ1bmN0aW9uIGJ1ZjJoZXgoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVkdWNlKChyLCB4KSA9PiByICsgeC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBgMHgke3JlbW92ZUhleFByZWZpeChoZXgpfWA7XG59XG5mdW5jdGlvbiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIGxlZnQsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICBjb25zdCBkaWZmID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgY29uc3QgcGFkID0gcGFkZGluZy5yZXBlYXQoZGlmZik7XG4gICAgcmVzdWx0ID0gbGVmdCA/IHBhZCArIHN0ciA6IHN0ciArIHBhZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIHRydWUsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSA9IDgpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoICUgYnl0ZVNpemU7XG4gIHJldHVybiByZW1haW5kZXIgPyAobGVuZ3RoIC0gcmVtYWluZGVyKSAvIGJ5dGVTaXplICogYnl0ZVNpemUgKyBieXRlU2l6ZSA6IGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplQnl0ZXMoc3RyLCBieXRlU2l6ZSA9IDgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkTGVmdChzdHIsIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUpLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSGV4KGhleCkge1xuICBoZXggPSByZW1vdmVIZXhQcmVmaXgoaGV4KTtcbiAgaGV4ID0gc2FuaXRpemVCeXRlcyhoZXgsIDIpO1xuICBpZiAoaGV4KSB7XG4gICAgaGV4ID0gYWRkSGV4UHJlZml4KGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbnZhciBwYXNjYWxUb1NuYWtlID0gKHRleHQpID0+IC9bYS16XS8udGVzdCh0ZXh0KSA/IHRleHQuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oXCJfXCIpLnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSA9IFwiMHgxXCI7XG52YXIgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzIgPSBcIjB4MlwiO1xudmFyIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSA9IDFuO1xudmFyIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiA9IDJuO1xudmFyIEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzEgPSAybiAqKiAxMjhuICsgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xO1xudmFyIEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzIgPSAybiAqKiAxMjhuICsgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yO1xudmFyIFpFUk8gPSAwbjtcbnZhciBNQVNLXzI1MCA9IDJuICoqIDI1MG4gLSAxbjtcbnZhciBBUElfVkVSU0lPTiA9IFpFUk87XG52YXIgTUFYX1NUT1JBR0VfSVRFTV9TSVpFID0gMjU2bjtcbnZhciBBRERSX0JPVU5EID0gMm4gKiogMjUxbiAtIE1BWF9TVE9SQUdFX0lURU1fU0laRTtcbnZhciBCYXNlVXJsID0gLyogQF9fUFVSRV9fICovICgoQmFzZVVybDIpID0+IHtcbiAgQmFzZVVybDJbXCJTTl9NQUlOXCJdID0gXCJodHRwczovL2FscGhhLW1haW5uZXQuc3RhcmtuZXQuaW9cIjtcbiAgQmFzZVVybDJbXCJTTl9HT0VSTElcIl0gPSBcImh0dHBzOi8vYWxwaGE0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fU0VQT0xJQVwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1zZXBvbGlhLnN0YXJrbmV0LmlvXCI7XG4gIHJldHVybiBCYXNlVXJsMjtcbn0pKEJhc2VVcmwgfHwge30pO1xudmFyIE5ldHdvcmtOYW1lID0gLyogQF9fUFVSRV9fICovICgoTmV0d29ya05hbWUyKSA9PiB7XG4gIE5ldHdvcmtOYW1lMltcIlNOX01BSU5cIl0gPSBcIlNOX01BSU5cIjtcbiAgTmV0d29ya05hbWUyW1wiU05fR09FUkxJXCJdID0gXCJTTl9HT0VSTElcIjtcbiAgTmV0d29ya05hbWUyW1wiU05fU0VQT0xJQVwiXSA9IFwiU05fU0VQT0xJQVwiO1xuICByZXR1cm4gTmV0d29ya05hbWUyO1xufSkoTmV0d29ya05hbWUgfHwge30pO1xudmFyIFN0YXJrbmV0Q2hhaW5JZCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0Q2hhaW5JZDQpID0+IHtcbiAgU3RhcmtuZXRDaGFpbklkNFtcIlNOX01BSU5cIl0gPSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIjtcbiAgU3RhcmtuZXRDaGFpbklkNFtcIlNOX0dPRVJMSVwiXSA9IFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIjtcbiAgU3RhcmtuZXRDaGFpbklkNFtcIlNOX1NFUE9MSUFcIl0gPSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIjtcbiAgcmV0dXJuIFN0YXJrbmV0Q2hhaW5JZDQ7XG59KShTdGFya25ldENoYWluSWQgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uSGFzaFByZWZpeCA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uSGFzaFByZWZpeDIpID0+IHtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFQ0xBUkVcIl0gPSBcIjB4NjQ2NTYzNmM2MTcyNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWVwiXSA9IFwiMHg2NDY1NzA2YzZmNzlcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIklOVk9LRVwiXSA9IFwiMHg2OTZlNzY2ZjZiNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkwxX0hBTkRMRVJcIl0gPSBcIjB4NmMzMTVmNjg2MTZlNjQ2YzY1NzJcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uSGFzaFByZWZpeDI7XG59KShUcmFuc2FjdGlvbkhhc2hQcmVmaXggfHwge30pO1xudmFyIFVEQyA9IHtcbiAgQUREUkVTUzogXCIweDA0MWE3OGU3NDFlNWFmMmZlYzM0YjY5NTY3OWJjNjg5MTc0MjQzOWY3YWZiODQ4NGVjZDc3NjY2NjFhZDAyYmZcIixcbiAgRU5UUllQT0lOVDogXCJkZXBsb3lDb250cmFjdFwiXG59O1xudmFyIFJQQ19ERUZBVUxUX1ZFUlNJT04gPSBcInYwXzVcIjtcbnZhciBSUENfTk9ERVMgPSB7XG4gIFNOX0dPRVJMSTogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LXRlc3RuZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy9gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vZ29lcmxpLWp1bm8vYFxuICBdLFxuICBTTl9NQUlOOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL2AsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9tYWlubmV0LWp1bm8vYFxuICBdLFxuICBTTl9TRVBPTElBOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL2AsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9zZXBvbGlhLWp1bm8vYFxuICBdXG59O1xuXG4vLyBzcmMvdHlwZXMvaW5kZXgudHNcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEJsb2NrU3RhdHVzOiAoKSA9PiBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWc6ICgpID0+IEJsb2NrVGFnLFxuICBFbnRyeVBvaW50VHlwZTogKCkgPT4gRW50cnlQb2ludFR5cGUsXG4gIExpdGVyYWw6ICgpID0+IExpdGVyYWwsXG4gIFJQQzogKCkgPT4gcnBjX2V4cG9ydHMsXG4gIFNJTVVMQVRJT05fRkxBRzogKCkgPT4gU0lNVUxBVElPTl9GTEFHLFxuICBTZXF1ZW5jZXI6ICgpID0+IHNlcXVlbmNlcl9leHBvcnRzLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uOiAoKSA9PiBUeXBlZERhdGFSZXZpc2lvbixcbiAgVWludDogKCkgPT4gVWludCxcbiAgVmFsaWRhdGVUeXBlOiAoKSA9PiBWYWxpZGF0ZVR5cGVcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYWNjb3VudC50c1xudmFyIFNJTVVMQVRJT05fRkxBRyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNJTVVMQVRJT05fRkxBRzIpID0+IHtcbiAgU0lNVUxBVElPTl9GTEFHMltcIlNLSVBfVkFMSURBVEVcIl0gPSBcIlNLSVBfVkFMSURBVEVcIjtcbiAgU0lNVUxBVElPTl9GTEFHMltcIlNLSVBfRVhFQ1VURVwiXSA9IFwiU0tJUF9FWEVDVVRFXCI7XG4gIHJldHVybiBTSU1VTEFUSU9OX0ZMQUcyO1xufSkoU0lNVUxBVElPTl9GTEFHIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2NhbGxkYXRhLnRzXG52YXIgVmFsaWRhdGVUeXBlID0gLyogQF9fUFVSRV9fICovICgoVmFsaWRhdGVUeXBlMikgPT4ge1xuICBWYWxpZGF0ZVR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgVmFsaWRhdGVUeXBlMltcIkNBTExcIl0gPSBcIkNBTExcIjtcbiAgVmFsaWRhdGVUeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIHJldHVybiBWYWxpZGF0ZVR5cGUyO1xufSkoVmFsaWRhdGVUeXBlIHx8IHt9KTtcbnZhciBVaW50ID0gLyogQF9fUFVSRV9fICovICgoVWludDIpID0+IHtcbiAgVWludDJbXCJ1OFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dThcIjtcbiAgVWludDJbXCJ1MTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUxNlwiO1xuICBVaW50MltcInUzMlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTMyXCI7XG4gIFVpbnQyW1widTY0XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1NjRcIjtcbiAgVWludDJbXCJ1MTI4XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCI7XG4gIFVpbnQyW1widTI1NlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiO1xuICByZXR1cm4gVWludDI7XG59KShVaW50IHx8IHt9KTtcbnZhciBMaXRlcmFsID0gLyogQF9fUFVSRV9fICovICgoTGl0ZXJhbDIpID0+IHtcbiAgTGl0ZXJhbDJbXCJDbGFzc0hhc2hcIl0gPSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIjtcbiAgTGl0ZXJhbDJbXCJDb250cmFjdEFkZHJlc3NcIl0gPSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbiAgcmV0dXJuIExpdGVyYWwyO1xufSkoTGl0ZXJhbCB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvY29udHJhY3QvaW5kZXgudHNcbnZhciBFbnRyeVBvaW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVudHJ5UG9pbnRUeXBlMikgPT4ge1xuICBFbnRyeVBvaW50VHlwZTJbXCJFWFRFUk5BTFwiXSA9IFwiRVhURVJOQUxcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJDT05TVFJVQ1RPUlwiXSA9IFwiQ09OU1RSVUNUT1JcIjtcbiAgcmV0dXJuIEVudHJ5UG9pbnRUeXBlMjtcbn0pKEVudHJ5UG9pbnRUeXBlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9pbmRleC50c1xudmFyIFRyYW5zYWN0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uVHlwZTIpID0+IHtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiREVQTE9ZX0FDQ09VTlRcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFX0ZVTkNUSU9OXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblR5cGUyO1xufSkoVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJTVUNDRUVERURcIl0gPSBcIlNVQ0NFRURFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgfHwge30pO1xudmFyIEJsb2NrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tTdGF0dXMyKSA9PiB7XG4gIEJsb2NrU3RhdHVzMltcIlBFTkRJTkdcIl0gPSBcIlBFTkRJTkdcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBCbG9ja1N0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgcmV0dXJuIEJsb2NrU3RhdHVzMjtcbn0pKEJsb2NrU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrVGFnMikgPT4ge1xuICBCbG9ja1RhZzJbXCJwZW5kaW5nXCJdID0gXCJwZW5kaW5nXCI7XG4gIEJsb2NrVGFnMltcImxhdGVzdFwiXSA9IFwibGF0ZXN0XCI7XG4gIHJldHVybiBCbG9ja1RhZzI7XG59KShCbG9ja1RhZyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy90eXBlZERhdGEudHNcbnZhciBUeXBlZERhdGFSZXZpc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFR5cGVkRGF0YVJldmlzaW9uMikgPT4ge1xuICBUeXBlZERhdGFSZXZpc2lvbjJbXCJBY3RpdmVcIl0gPSBcIjFcIjtcbiAgVHlwZWREYXRhUmV2aXNpb24yW1wiTGVnYWN5XCJdID0gXCIwXCI7XG4gIHJldHVybiBUeXBlZERhdGFSZXZpc2lvbjI7XG59KShUeXBlZERhdGFSZXZpc2lvbiB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjLnRzXG52YXIgcnBjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJwY19leHBvcnRzLCB7XG4gIEVCbG9ja1RhZzogKCkgPT4gRUJsb2NrVGFnLFxuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGU6ICgpID0+IEVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgRVNpbXVsYXRpb25GbGFnOiAoKSA9PiBFU2ltdWxhdGlvbkZsYWcsXG4gIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLFxuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIEVUcmFuc2FjdGlvblN0YXR1czogKCkgPT4gRVRyYW5zYWN0aW9uU3RhdHVzLFxuICBFVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBFVHJhbnNhY3Rpb25UeXBlLFxuICBFcnJvcnM6ICgpID0+IGVycm9yc19leHBvcnRzLFxuICBKUlBDOiAoKSA9PiBqc29ucnBjX2V4cG9ydHMsXG4gIFNQRUM6ICgpID0+IGNvbXBvbmVudHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvanNvbnJwYy9pbmRleC50c1xudmFyIGpzb25ycGNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWMvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjL2NvbXBvbmVudHMudHNcbnZhciBjb21wb25lbnRzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjL25vbnNwZWMudHNcbnZhciBFVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVHlwZTIpID0+IHtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERUNMQVJFXCJdID0gXCJERUNMQVJFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiREVQTE9ZX0FDQ09VTlRcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkwxX0hBTkRMRVJcIl0gPSBcIkwxX0hBTkRMRVJcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblR5cGUyO1xufSkoRVRyYW5zYWN0aW9uVHlwZSB8fCB7fSk7XG52YXIgRVNpbXVsYXRpb25GbGFnID0gLyogQF9fUFVSRV9fICovICgoRVNpbXVsYXRpb25GbGFnMikgPT4ge1xuICBFU2ltdWxhdGlvbkZsYWcyW1wiU0tJUF9WQUxJREFURVwiXSA9IFwiU0tJUF9WQUxJREFURVwiO1xuICBFU2ltdWxhdGlvbkZsYWcyW1wiU0tJUF9GRUVfQ0hBUkdFXCJdID0gXCJTS0lQX0ZFRV9DSEFSR0VcIjtcbiAgcmV0dXJuIEVTaW11bGF0aW9uRmxhZzI7XG59KShFU2ltdWxhdGlvbkZsYWcgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgfHwge30pO1xudmFyIEVCbG9ja1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVCbG9ja1RhZzIpID0+IHtcbiAgRUJsb2NrVGFnMltcIkxBVEVTVFwiXSA9IFwibGF0ZXN0XCI7XG4gIEVCbG9ja1RhZzJbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gIHJldHVybiBFQmxvY2tUYWcyO1xufSkoRUJsb2NrVGFnIHx8IHt9KTtcbnZhciBFRGF0YUF2YWlsYWJpbGl0eU1vZGUgPSAvKiBAX19QVVJFX18gKi8gKChFRGF0YUF2YWlsYWJpbGl0eU1vZGUyKSA9PiB7XG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTJbXCJMMVwiXSA9IFwiTDFcIjtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlMltcIkwyXCJdID0gXCJMMlwiO1xuICByZXR1cm4gRURhdGFBdmFpbGFiaWxpdHlNb2RlMjtcbn0pKEVEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvc2VxdWVuY2VyLnRzXG52YXIgc2VxdWVuY2VyX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3V0aWxzL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL251bS50c1xudmFyIG51bV9leHBvcnRzID0ge307XG5fX2V4cG9ydChudW1fZXhwb3J0cywge1xuICBhc3NlcnRJblJhbmdlOiAoKSA9PiBhc3NlcnRJblJhbmdlLFxuICBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5LFxuICBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXksXG4gIGNsZWFuSGV4OiAoKSA9PiBjbGVhbkhleCxcbiAgZ2V0RGVjaW1hbFN0cmluZzogKCkgPT4gZ2V0RGVjaW1hbFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nOiAoKSA9PiBnZXRIZXhTdHJpbmcsXG4gIGdldEhleFN0cmluZ0FycmF5OiAoKSA9PiBnZXRIZXhTdHJpbmdBcnJheSxcbiAgaGV4VG9CeXRlczogKCkgPT4gaGV4VG9CeXRlcyxcbiAgaGV4VG9EZWNpbWFsU3RyaW5nOiAoKSA9PiBoZXhUb0RlY2ltYWxTdHJpbmcsXG4gIGlzQmlnSW50OiAoKSA9PiBpc0JpZ0ludCxcbiAgaXNIZXg6ICgpID0+IGlzSGV4LFxuICBpc1N0cmluZ1dob2xlTnVtYmVyOiAoKSA9PiBpc1N0cmluZ1dob2xlTnVtYmVyLFxuICB0b0JpZ0ludDogKCkgPT4gdG9CaWdJbnQsXG4gIHRvQ2Fpcm9Cb29sOiAoKSA9PiB0b0NhaXJvQm9vbCxcbiAgdG9IZXg6ICgpID0+IHRvSGV4LFxuICB0b0hleFN0cmluZzogKCkgPT4gdG9IZXhTdHJpbmcsXG4gIHRvU3RvcmFnZUtleTogKCkgPT4gdG9TdG9yYWdlS2V5XG59KTtcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlc05vYmxlIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIjtcbmZ1bmN0aW9uIGlzSGV4KGhleCkge1xuICByZXR1cm4gL14weFswLTlhLWZdKiQvaS50ZXN0KGhleCk7XG59XG5mdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCI7XG59XG5mdW5jdGlvbiB0b0hleChudW1iZXIyKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpKTtcbn1cbnZhciB0b0hleFN0cmluZyA9IHRvSGV4O1xuZnVuY3Rpb24gdG9TdG9yYWdlS2V5KG51bWJlcjIpIHtcbiAgY29uc3QgcmVzID0gYWRkSGV4UHJlZml4KHRvQmlnSW50KG51bWJlcjIpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGhleFRvRGVjaW1hbFN0cmluZyhoZXgpIHtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoaGV4KSkudG9TdHJpbmcoMTApO1xufVxudmFyIGNsZWFuSGV4ID0gKGhleCkgPT4gaGV4LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXigweCkwKy8sIFwiJDFcIik7XG5mdW5jdGlvbiBhc3NlcnRJblJhbmdlKGlucHV0LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpbnB1dE5hbWUgPSBcIlwiKSB7XG4gIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBpbnB1dE5hbWUgPT09IFwiXCIgPyBcImludmFsaWQgbGVuZ3RoXCIgOiBgaW52YWxpZCAke2lucHV0TmFtZX0gbGVuZ3RoYDtcbiAgY29uc3QgaW5wdXRCaWdJbnQgPSBCaWdJbnQoaW5wdXQpO1xuICBjb25zdCBsb3dlckJvdW5kQmlnSW50ID0gQmlnSW50KGxvd2VyQm91bmQpO1xuICBjb25zdCB1cHBlckJvdW5kQmlnSW50ID0gQmlnSW50KHVwcGVyQm91bmQpO1xuICBhc3NlcnQoXG4gICAgaW5wdXRCaWdJbnQgPj0gbG93ZXJCb3VuZEJpZ0ludCAmJiBpbnB1dEJpZ0ludCA8PSB1cHBlckJvdW5kQmlnSW50LFxuICAgIGBNZXNzYWdlIG5vdCBzaWduYWJsZSwgJHttZXNzYWdlU3VmZml4fS5gXG4gICk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KHJhd0NhbGxkYXRhKSB7XG4gIHJldHVybiByYXdDYWxsZGF0YS5tYXAoKHgpID0+IHRvQmlnSW50KHgpLnRvU3RyaW5nKDEwKSk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShyYXdDYWxsZGF0YSkge1xuICByZXR1cm4gcmF3Q2FsbGRhdGEubWFwKCh4KSA9PiB0b0hleCh4KSk7XG59XG52YXIgaXNTdHJpbmdXaG9sZU51bWJlciA9ICh2YWx1ZSkgPT4gL15cXGQrJC8udGVzdCh2YWx1ZSk7XG5mdW5jdGlvbiBnZXREZWNpbWFsU3RyaW5nKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaGV4VG9EZWNpbWFsU3RyaW5nKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmdBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKChlbCkgPT4gZ2V0SGV4U3RyaW5nKGVsKSk7XG59XG52YXIgdG9DYWlyb0Jvb2wgPSAodmFsdWUpID0+ICgrdmFsdWUpLnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKHZhbHVlKSB7XG4gIGlmICghaXNIZXgodmFsdWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBhIGhleC1zdHJpbmdgKTtcbiAgbGV0IGFkYXB0ZWRWYWx1ZSA9IHJlbW92ZUhleFByZWZpeCh2YWx1ZSk7XG4gIGlmIChhZGFwdGVkVmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIGFkYXB0ZWRWYWx1ZSA9IGAwJHthZGFwdGVkVmFsdWV9YDtcbiAgfVxuICByZXR1cm4gaGV4VG9CeXRlc05vYmxlKGFkYXB0ZWRWYWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9zZWxlY3Rvci50c1xudmFyIHNlbGVjdG9yX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNlbGVjdG9yX2V4cG9ydHMsIHtcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBrZWNjYWtCbjogKCkgPT4ga2VjY2FrQm4sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2Nha1xufSk7XG5pbXBvcnQgeyBrZWNjYWsgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5mdW5jdGlvbiBrZWNjYWtCbih2YWx1ZSkge1xuICBjb25zdCBoZXhXaXRob3V0UHJlZml4ID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KEJpZ0ludCh2YWx1ZSkpKTtcbiAgY29uc3QgZXZlbkhleCA9IGhleFdpdGhvdXRQcmVmaXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleFdpdGhvdXRQcmVmaXggOiBgMCR7aGV4V2l0aG91dFByZWZpeH1gO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2NhayhoZXhUb0J5dGVzKGFkZEhleFByZWZpeChldmVuSGV4KSkpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBrZWNjYWtIZXgoc3RyKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKHV0ZjhUb0FycmF5KHN0cikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBzdGFya25ldEtlY2NhayhzdHIpIHtcbiAgY29uc3QgaGFzaCA9IEJpZ0ludChrZWNjYWtIZXgoc3RyKSk7XG4gIHJldHVybiBoYXNoICYgTUFTS18yNTA7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvckZyb21OYW1lKGZ1bmNOYW1lKSB7XG4gIHJldHVybiB0b0hleChzdGFya25ldEtlY2NhayhmdW5jTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3Nob3J0U3RyaW5nLnRzXG52YXIgc2hvcnRTdHJpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2hvcnRTdHJpbmdfZXhwb3J0cywge1xuICBkZWNvZGVTaG9ydFN0cmluZzogKCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcsXG4gIGVuY29kZVNob3J0U3RyaW5nOiAoKSA9PiBlbmNvZGVTaG9ydFN0cmluZyxcbiAgaXNBU0NJSTogKCkgPT4gaXNBU0NJSSxcbiAgaXNEZWNpbWFsU3RyaW5nOiAoKSA9PiBpc0RlY2ltYWxTdHJpbmcsXG4gIGlzTG9uZ1RleHQ6ICgpID0+IGlzTG9uZ1RleHQsXG4gIGlzU2hvcnRTdHJpbmc6ICgpID0+IGlzU2hvcnRTdHJpbmcsXG4gIGlzU2hvcnRUZXh0OiAoKSA9PiBpc1Nob3J0VGV4dCxcbiAgaXNUZXh0OiAoKSA9PiBpc1RleHQsXG4gIHNwbGl0TG9uZ1N0cmluZzogKCkgPT4gc3BsaXRMb25nU3RyaW5nXG59KTtcbmZ1bmN0aW9uIGlzQVNDSUkoc3RyKSB7XG4gIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNTaG9ydFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gVEVYVF9UT19GRUxUX01BWF9MRU47XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxTdHJpbmcoc3RyKSB7XG4gIHJldHVybiAvXlswLTldKiQvaS50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICYmICFpc0hleCh2YWwpICYmICFpc1N0cmluZ1dob2xlTnVtYmVyKHZhbCk7XG59XG52YXIgaXNTaG9ydFRleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiBpc1Nob3J0U3RyaW5nKHZhbCk7XG52YXIgaXNMb25nVGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmICFpc1Nob3J0U3RyaW5nKHZhbCk7XG5mdW5jdGlvbiBzcGxpdExvbmdTdHJpbmcobG9uZ1N0cikge1xuICBjb25zdCByZWdleCA9IFJlZ0V4cChgW15dezEsJHtURVhUX1RPX0ZFTFRfTUFYX0xFTn19YCwgXCJnXCIpO1xuICByZXR1cm4gbG9uZ1N0ci5tYXRjaChyZWdleCkgfHwgW107XG59XG5mdW5jdGlvbiBlbmNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoIWlzU2hvcnRTdHJpbmcoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyB0b28gbG9uZ2ApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0ci5yZXBsYWNlKC8uL2csIChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiByZW1vdmVIZXhQcmVmaXgoc3RyKS5yZXBsYWNlKC8uezJ9L2csIChoZXgpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpKTtcbiAgfVxuICBpZiAoaXNEZWNpbWFsU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gZGVjb2RlU2hvcnRTdHJpbmcoXCIwWFwiLmNvbmNhdChCaWdJbnQoc3RyKS50b1N0cmluZygxNikpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgSGV4IG9yIGRlY2ltYWxgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgY2Fpcm9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2Fpcm9fZXhwb3J0cywge1xuICBmZWx0OiAoKSA9PiBmZWx0LFxuICBnZXRBYmlDb250cmFjdFZlcnNpb246ICgpID0+IGdldEFiaUNvbnRyYWN0VmVyc2lvbixcbiAgZ2V0QXJyYXlUeXBlOiAoKSA9PiBnZXRBcnJheVR5cGUsXG4gIGlzQ2Fpcm8xQWJpOiAoKSA9PiBpc0NhaXJvMUFiaSxcbiAgaXNDYWlybzFUeXBlOiAoKSA9PiBpc0NhaXJvMVR5cGUsXG4gIGlzTGVuOiAoKSA9PiBpc0xlbixcbiAgaXNUeXBlQXJyYXk6ICgpID0+IGlzVHlwZUFycmF5LFxuICBpc1R5cGVCb29sOiAoKSA9PiBpc1R5cGVCb29sLFxuICBpc1R5cGVDb250cmFjdEFkZHJlc3M6ICgpID0+IGlzVHlwZUNvbnRyYWN0QWRkcmVzcyxcbiAgaXNUeXBlRW51bTogKCkgPT4gaXNUeXBlRW51bSxcbiAgaXNUeXBlRXRoQWRkcmVzczogKCkgPT4gaXNUeXBlRXRoQWRkcmVzcyxcbiAgaXNUeXBlRmVsdDogKCkgPT4gaXNUeXBlRmVsdCxcbiAgaXNUeXBlTGl0ZXJhbDogKCkgPT4gaXNUeXBlTGl0ZXJhbCxcbiAgaXNUeXBlTmFtZWRUdXBsZTogKCkgPT4gaXNUeXBlTmFtZWRUdXBsZSxcbiAgaXNUeXBlT3B0aW9uOiAoKSA9PiBpc1R5cGVPcHRpb24sXG4gIGlzVHlwZVJlc3VsdDogKCkgPT4gaXNUeXBlUmVzdWx0LFxuICBpc1R5cGVTdHJ1Y3Q6ICgpID0+IGlzVHlwZVN0cnVjdCxcbiAgaXNUeXBlVHVwbGU6ICgpID0+IGlzVHlwZVR1cGxlLFxuICBpc1R5cGVVaW50OiAoKSA9PiBpc1R5cGVVaW50LFxuICBpc1R5cGVVaW50MjU2OiAoKSA9PiBpc1R5cGVVaW50MjU2LFxuICB0dXBsZTogKCkgPT4gdHVwbGUsXG4gIHVpbnQyNTY6ICgpID0+IHVpbnQyNTZcbn0pO1xuXG4vLyBzcmMvdXRpbHMvdWludDI1Ni50c1xudmFyIHVpbnQyNTZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodWludDI1Nl9leHBvcnRzLCB7XG4gIFVJTlRfMTI4X01BWDogKCkgPT4gVUlOVF8xMjhfTUFYLFxuICBVSU5UXzI1Nl9NQVg6ICgpID0+IFVJTlRfMjU2X01BWCxcbiAgYm5Ub1VpbnQyNTY6ICgpID0+IGJuVG9VaW50MjU2LFxuICBpc1VpbnQyNTY6ICgpID0+IGlzVWludDI1NixcbiAgdWludDI1NlRvQk46ICgpID0+IHVpbnQyNTZUb0JOXG59KTtcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbmZ1bmN0aW9uIHVpbnQyNTZUb0JOKHVpbnQyNTYyKSB7XG4gIHJldHVybiAodG9CaWdJbnQodWludDI1NjIuaGlnaCkgPDwgMTI4bikgKyB0b0JpZ0ludCh1aW50MjU2Mi5sb3cpO1xufVxuZnVuY3Rpb24gaXNVaW50MjU2KGJuKSB7XG4gIHJldHVybiB0b0JpZ0ludChibikgPD0gVUlOVF8yNTZfTUFYO1xufVxuZnVuY3Rpb24gYm5Ub1VpbnQyNTYoYm4pIHtcbiAgY29uc3QgYmkgPSB0b0JpZ0ludChibik7XG4gIGlmICghaXNVaW50MjU2KGJpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgaXMgdG9vIGxhcmdlXCIpO1xuICByZXR1cm4ge1xuICAgIGxvdzogYWRkSGV4UHJlZml4KChiaSAmIFVJTlRfMTI4X01BWCkudG9TdHJpbmcoMTYpKSxcbiAgICBoaWdoOiBhZGRIZXhQcmVmaXgoKGJpID4+IDEyOG4pLnRvU3RyaW5nKDE2KSlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVMaXRlcmFsID0gKHR5cGUpID0+IE9iamVjdC52YWx1ZXMoTGl0ZXJhbCkuaW5jbHVkZXModHlwZSk7XG52YXIgaXNUeXBlVWludDI1NiA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbnZhciBpc1R5cGVCb29sID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ym9vbFwiO1xudmFyIGlzVHlwZUNvbnRyYWN0QWRkcmVzcyA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbnZhciBpc1R5cGVFdGhBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI7XG52YXIgaXNDYWlybzFUeXBlID0gKHR5cGUpID0+IHR5cGUuaW5jbHVkZXMoXCI6OlwiKTtcbnZhciBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3Vic3RyaW5nKHR5cGUuaW5kZXhPZihcIjxcIikgKyAxLCB0eXBlLmxhc3RJbmRleE9mKFwiPlwiKSk7XG4gIH1cbiAgcmV0dXJuIHR5cGUucmVwbGFjZShcIipcIiwgXCJcIik7XG59O1xuZnVuY3Rpb24gaXNDYWlybzFBYmkoYWJpKSB7XG4gIGNvbnN0IHsgY2Fpcm8gfSA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpO1xuICBpZiAoY2Fpcm8gPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGRldGVybWluZSBDYWlybyB2ZXJzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjYWlybyA9PT0gXCIxXCI7XG59XG5mdW5jdGlvbiBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIyXCIgfTtcbiAgfVxuICBjb25zdCB0ZXN0RnVuY3Rpb24gPSBhYmkuZmluZChcbiAgICAoaXQpID0+IGl0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAoaXQuaW5wdXRzLmxlbmd0aCB8fCBpdC5vdXRwdXRzLmxlbmd0aClcbiAgKTtcbiAgaWYgKCF0ZXN0RnVuY3Rpb24pIHtcbiAgICByZXR1cm4geyBjYWlybzogdm9pZCAwLCBjb21waWxlcjogdm9pZCAwIH07XG4gIH1cbiAgY29uc3QgaW8gPSB0ZXN0RnVuY3Rpb24uaW5wdXRzLmxlbmd0aCA/IHRlc3RGdW5jdGlvbi5pbnB1dHMgOiB0ZXN0RnVuY3Rpb24ub3V0cHV0cztcbiAgaWYgKGlzQ2Fpcm8xVHlwZShpb1swXS50eXBlKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbn1cbnZhciB1aW50MjU2ID0gKGl0KSA9PiB7XG4gIGNvbnN0IGJuID0gQmlnSW50KGl0KTtcbiAgaWYgKCFpc1VpbnQyNTYoYm4pKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBpcyB0b28gbGFyZ2VcIik7XG4gIHJldHVybiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBsb3c6IChibiAmIFVJTlRfMTI4X01BWCkudG9TdHJpbmcoMTApLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgaGlnaDogKGJuID4+IDEyOG4pLnRvU3RyaW5nKDEwKVxuICB9O1xufTtcbnZhciB0dXBsZSA9ICguLi5hcmdzKSA9PiAoeyAuLi5hcmdzIH0pO1xuZnVuY3Rpb24gZmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IHR5cGVvZiBpdCA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGl0KSkge1xuICAgIHJldHVybiBpdC50b1N0cmluZygpO1xuICB9XG4gIGlmIChpc1RleHQoaXQpKSB7XG4gICAgaWYgKCFpc1Nob3J0U3RyaW5nKGl0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7aXR9IGlzIGEgbG9uZyBzdHJpbmcgPiAzMSBjaGFycywgZmVsdCBjYW4gc3RvcmUgc2hvcnQgc3RyaW5ncywgc3BsaXQgaXQgdG8gYXJyYXkgb2Ygc2hvcnQgc3RyaW5nc2BcbiAgICAgICk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVNob3J0U3RyaW5nKGl0KTtcbiAgICByZXR1cm4gQmlnSW50KGVuY29kZWQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc0hleChpdCkpIHtcbiAgICByZXR1cm4gQmlnSW50KGl0KS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0eXBlb2YgaXQgPT09IFwic3RyaW5nXCIgJiYgaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICByZXR1cm4gaXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9DdXN0b21FbnVtLnRzXG52YXIgQ2Fpcm9DdXN0b21FbnVtID0gY2xhc3Mge1xuICAvKipcbiAgICogZGlyZWN0IHJlYWRvbmx5IGFjY2VzcyB0byB2YXJpYW50cyBvZiB0aGUgQ2Fpcm8gQ3VzdG9tIEVudW0uXG4gICAqIEByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBhbnlcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWNjZXNzVmFsdWUgPSBteUNhaXJvRW51bS52YXJpYW50LlN1Y2Nlc3M7XG4gICAqL1xuICB2YXJpYW50O1xuICAvKipcbiAgICogQHBhcmFtIGVudW1Db250ZW50IGFuIG9iamVjdCB3aXRoIHRoZSB2YXJpYW50cyBhcyBrZXlzIGFuZCB0aGUgY29udGVudCBhcyB2YWx1ZS4gT25seSBvbmUgY29udGVudCBzaGFsbCBiZSBkZWZpbmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW51bUNvbnRlbnQpIHtcbiAgICBjb25zdCB2YXJpYW50c0xpc3QgPSBPYmplY3QudmFsdWVzKGVudW1Db250ZW50KTtcbiAgICBpZiAodmFyaWFudHNMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhcmlhbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5iQWN0aXZlVmFyaWFudHMgPSB2YXJpYW50c0xpc3QuZmlsdGVyKFxuICAgICAgKGNvbnRlbnQpID0+IHR5cGVvZiBjb250ZW50ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgKS5sZW5ndGg7XG4gICAgaWYgKG5iQWN0aXZlVmFyaWFudHMgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRW51bSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgYWN0aXZlIHZhcmlhbnRcIik7XG4gICAgfVxuICAgIHRoaXMudmFyaWFudCA9IGVudW1Db250ZW50O1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModGhpcy52YXJpYW50KTtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gdHlwZW9mIGl0ZW1bMV0gIT09IFwidW5kZWZpbmVkXCIpO1xuICAgIGlmICh0eXBlb2YgYWN0aXZlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVZhcmlhbnRbMV07XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqL1xuICBhY3RpdmVWYXJpYW50KCkge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModGhpcy52YXJpYW50KTtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gdHlwZW9mIGl0ZW1bMV0gIT09IFwidW5kZWZpbmVkXCIpO1xuICAgIGlmICh0eXBlb2YgYWN0aXZlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzBdO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb09wdGlvbi50c1xudmFyIENhaXJvT3B0aW9uVmFyaWFudCA9IC8qIEBfX1BVUkVfXyAqLyAoKENhaXJvT3B0aW9uVmFyaWFudDIpID0+IHtcbiAgQ2Fpcm9PcHRpb25WYXJpYW50MltDYWlyb09wdGlvblZhcmlhbnQyW1wiU29tZVwiXSA9IDBdID0gXCJTb21lXCI7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIk5vbmVcIl0gPSAxXSA9IFwiTm9uZVwiO1xuICByZXR1cm4gQ2Fpcm9PcHRpb25WYXJpYW50Mjtcbn0pKENhaXJvT3B0aW9uVmFyaWFudCB8fCB7fSk7XG52YXIgQ2Fpcm9PcHRpb24gPSBjbGFzcyB7XG4gIFNvbWU7XG4gIE5vbmU7XG4gIGNvbnN0cnVjdG9yKHZhcmlhbnQsIHNvbWVDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb09wdGlvblZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvT3B0aW9uVmFyaWFudC5Tb21lIG9yIC5Ob25lLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogU29tZSAqLykge1xuICAgICAgaWYgKHR5cGVvZiBzb21lQ29udGVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBjcmVhdGlvbiBvZiBhIENhaXJvIE9wdGlvbiB3aXRoIFwiU29tZVwiIHZhcmlhbnQgbmVlZHMgYSBjb250ZW50IGFzIGlucHV0LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuU29tZSA9IHNvbWVDb250ZW50O1xuICAgICAgdGhpcy5Ob25lID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLlNvbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLk5vbmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICogIElmIE5vbmUsIHJldHVybnMgJ3VuZGVmaW5lZCcuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgaWYgKHRoaXMuTm9uZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuU29tZTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnaXNTb21lJy5cbiAgICovXG4gIGlzU29tZSgpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5Tb21lID09PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnaXNOb25lJy5cbiAgICovXG4gIGlzTm9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5Ob25lID09PSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb1Jlc3VsdC50c1xudmFyIENhaXJvUmVzdWx0VmFyaWFudCA9IC8qIEBfX1BVUkVfXyAqLyAoKENhaXJvUmVzdWx0VmFyaWFudDIpID0+IHtcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50MltDYWlyb1Jlc3VsdFZhcmlhbnQyW1wiT2tcIl0gPSAwXSA9IFwiT2tcIjtcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50MltDYWlyb1Jlc3VsdFZhcmlhbnQyW1wiRXJyXCJdID0gMV0gPSBcIkVyclwiO1xuICByZXR1cm4gQ2Fpcm9SZXN1bHRWYXJpYW50Mjtcbn0pKENhaXJvUmVzdWx0VmFyaWFudCB8fCB7fSk7XG52YXIgQ2Fpcm9SZXN1bHQgPSBjbGFzcyB7XG4gIE9rO1xuICBFcnI7XG4gIGNvbnN0cnVjdG9yKHZhcmlhbnQsIHJlc3VsdENvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIENhaXJvUmVzdWx0VmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQgOiBzaG91bGQgYmUgQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rIG9yIC5FcnIuXCIpO1xuICAgIH1cbiAgICBpZiAodmFyaWFudCA9PT0gMCAvKiBPayAqLykge1xuICAgICAgdGhpcy5PayA9IHJlc3VsdENvbnRlbnQ7XG4gICAgICB0aGlzLkVyciA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5PayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuRXJyID0gcmVzdWx0Q29udGVudDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gUmVzdWx0LlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5PayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMuT2s7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5FcnIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLkVycjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBSZXN1bHQuT2sgYW5kIC5FcnIgYXJlIHVuZGVmaW5lZC4gTm90IGF1dGhvcml6ZWQuXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdPaycuXG4gICAqL1xuICBpc09rKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLk9rID09PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnaXNFcnInLlxuICAgKi9cbiAgaXNFcnIoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuRXJyID09PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2Zvcm1hdHRlci50c1xudmFyIGd1YXJkID0ge1xuICBpc0JOOiAoZGF0YSwgdHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKCFpc0JpZ0ludChkYXRhW2tleV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGF0YSBhbmQgZm9ybWF0dGVyIG1pc21hdGNoIG9uICR7a2V5fToke3R5cGVba2V5XX0sIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfSB0byBiZSBCTiBpbnN0ZWFkIGl0IGlzICR7dHlwZW9mIGRhdGFba2V5XX1gXG4gICAgICApO1xuICB9LFxuICB1bmtub3duOiAoZGF0YSwgdHlwZSwga2V5KSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgZm9ybWF0dGVyIHR5cGUgb24gJHtrZXl9OiR7dHlwZVtrZXldfSBmb3IgZGF0YSAke2tleX06JHtkYXRhW2tleV19YCk7XG4gIH1cbn07XG5mdW5jdGlvbiBmb3JtYXR0ZXIoZGF0YSwgdHlwZSwgc2FtZVR5cGUpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBlbFR5cGUgPSBzYW1lVHlwZSA/PyB0eXBlW2tleV07XG4gICAgaWYgKCEoa2V5IGluIHR5cGUpICYmICFzYW1lVHlwZSkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChlbFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgY29uc3QgYXJyYXlTdHIgPSBmb3JtYXR0ZXIoXG4gICAgICAgICAgZGF0YVtrZXldLFxuICAgICAgICAgIGRhdGFba2V5XS5tYXAoKF8pID0+IGVsVHlwZSlcbiAgICAgICAgKTtcbiAgICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5U3RyKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgZ3VhcmQuaXNCTihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgYWNjW2tleV0gPSBkZWNvZGVTaG9ydFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoZWxUeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICBhY2Nba2V5XSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhY2Nba2V5XSA9IGVsVHlwZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbFR5cGUpKSB7XG4gICAgICBjb25zdCBhcnJheU9iaiA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSwgZWxUeXBlWzBdKTtcbiAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheU9iaik7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYWNjW2tleV0gPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgZ3VhcmQudW5rbm93bihkYXRhLCB0eXBlLCBrZXkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3BhcnNlci9wYXJzZXItMC0xLjEuMC50c1xudmFyIEFiaVBhcnNlcjEgPSBjbGFzcyB7XG4gIGFiaTtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG4gIH1cbiAgLyoqXG4gICAqIGFiaSBtZXRob2QgaW5wdXRzIGxlbmd0aCB3aXRob3V0ICdfbGVuJyBpbnB1dHNcbiAgICogY2Fpcm8gMCByZWR1Y2VyXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiAhaXNMZW4oaW5wdXQubmFtZSkgPyBhY2MgKyAxIDogYWNjLCAwKTtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1ldGhvZCBkZWZpbml0aW9uIGZyb20gYWJpXG4gICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgKiBAcmV0dXJucyBGdW5jdGlvbkFiaSB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0aG9kKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmluZCgoaXQpID0+IGl0Lm5hbWUgPT09IG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQWJpIGluIGxlZ2FjeSBmb3JtYXRcbiAgICogQHJldHVybnMgQWJpXG4gICAqL1xuICBnZXRMZWdhY3lGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0yLjAuMC50c1xudmFyIEFiaVBhcnNlcjIgPSBjbGFzcyB7XG4gIGFiaTtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG4gIH1cbiAgLyoqXG4gICAqIGFiaSBtZXRob2QgaW5wdXRzIGxlbmd0aFxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1ldGhvZCBkZWZpbml0aW9uIGZyb20gYWJpXG4gICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgKiBAcmV0dXJucyBGdW5jdGlvbkFiaSB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0aG9kKG5hbWUpIHtcbiAgICBjb25zdCBpbnRmID0gdGhpcy5hYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpO1xuICAgIHJldHVybiBpbnRmLml0ZW1zLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaS5mbGF0TWFwKChlKSA9PiB7XG4gICAgICBpZiAoZS50eXBlID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIHJldHVybiBlLml0ZW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZUFiaVBhcnNlcihhYmkpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldEFiaVZlcnNpb24oYWJpKTtcbiAgaWYgKHZlcnNpb24gPT09IDAgfHwgdmVyc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMShhYmkpO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAyKSB7XG4gICAgcmV0dXJuIG5ldyBBYmlQYXJzZXIyKGFiaSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEFCSSB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEFiaVZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKVxuICAgIHJldHVybiAyO1xuICBpZiAoaXNDYWlybzFBYmkoYWJpKSlcbiAgICByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09IFwiY29uc3RydWN0b3JcIiAmJiAhYWJpTWV0aG9kICYmICFhcmdzQ2FsbGRhdGEubGVuZ3RoO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvdHVwbGUudHNcbmZ1bmN0aW9uIHBhcnNlTmFtZWRUdXBsZShuYW1lZFR1cGxlKSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZygwLCBuYW1lZFR1cGxlLmluZGV4T2YoXCI6XCIpKTtcbiAgY29uc3QgdHlwZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgXCI6XCIubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdWJUdXBsZShzKSB7XG4gIGlmICghcy5pbmNsdWRlcyhcIihcIikpXG4gICAgcmV0dXJuIHsgc3ViVHVwbGU6IFtdLCByZXN1bHQ6IHMgfTtcbiAgY29uc3Qgc3ViVHVwbGUgPSBbXTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzLmxlbmd0aCkge1xuICAgIGlmIChzW2ldID09PSBcIihcIikge1xuICAgICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgICAgY29uc3QgbEJyYWNrZXQgPSBpO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKVwiKVxuICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKFwiKVxuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgc3ViVHVwbGUucHVzaChzLnN1YnN0cmluZyhsQnJhY2tldCwgaSkpO1xuICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgaS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gc1tpXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3ViVHVwbGUsXG4gICAgcmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBsZXQgcmVjb21wb3NlZCA9IHJlc3VsdC5zcGxpdChcIixcIikubWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBzdWJUdXBsZS5sZW5ndGggPyBpdC5yZXBsYWNlKFwiIFwiLCBzdWJUdXBsZS5zaGlmdCgpKSA6IGl0O1xuICB9KTtcbiAgaWYgKGlzVHlwZU5hbWVkVHVwbGUodHlwZSkpIHtcbiAgICByZWNvbXBvc2VkID0gcmVjb21wb3NlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlTmFtZWRUdXBsZShpdCkpO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGNsZWFuVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgeyBzdWJUdXBsZSwgcmVzdWx0IH0gPSBwYXJzZVN1YlR1cGxlKGNsZWFuVHlwZSk7XG4gIGNvbnN0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIHJldHVybiByZWNvbXBvc2VkO1xufVxuZnVuY3Rpb24gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZSkge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKTtcbiAgfVxuICByZXR1cm4gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcHJvcGVydHlPcmRlci50c1xuZnVuY3Rpb24gZXJyb3JVMjU2KGtleSkge1xuICByZXR1cm4gRXJyb3IoXG4gICAgYFlvdXIgb2JqZWN0IGluY2x1ZGVzIHRoZSBwcm9wZXJ0eSA6ICR7a2V5fSwgY29udGFpbmluZyBhbiBVaW50MjU2IG9iamVjdCB3aXRob3V0IHRoZSAnbG93JyBhbmQgJ2hpZ2gnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHUyNTYgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1MjU2ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1MjU2O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsb3dcIiBpbiB1MjU2ICYmIFwiaGlnaFwiIGluIHUyNTYpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTI1NihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxvdzogdTI1Ni5sb3csIGhpZ2g6IHUyNTYuaGlnaCB9O1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU3RydWN0KGFiaVR5cGUsIHN0cnVjdHMpKSB7XG4gICAgICBjb25zdCBhYmlPZlN0cnVjdCA9IHN0cnVjdHNbYWJpVHlwZV0ubWVtYmVycztcbiAgICAgIHJldHVybiBvcmRlclN0cnVjdCh1bm9yZGVyZWRJdGVtLCBhYmlPZlN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICB9O1xuICBjb25zdCBvcmRlclN0cnVjdCA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IGFiaU9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSB8fCAhaXNMZW4oYWJpUGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgWW91ciBvYmplY3QgbmVlZHMgYSBwcm9wZXJ0eSB3aXRoIGtleSA6ICR7YWJpUGFyYW0ubmFtZX0gLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH07XG4gIGZ1bmN0aW9uIG9yZGVyQXJyYXkobXlBcnJheSwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlSW5BcnJheSA9IGdldEFycmF5VHlwZShhYmlQYXJhbSk7XG4gICAgaWYgKHR5cGVvZiBteUFycmF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbXlBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIG15QXJyYXkubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5BcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9yZGVyVHVwbGUodW5vcmRlcmVkT2JqZWN0MiwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlTGlzdCA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGFiaVBhcmFtKTtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IHR5cGVMaXN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpVHlwZUNhaXJvWCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG15T2JqS2V5cyA9IE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdDIpO1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBpbmRleC50b1N0cmluZygpLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFiaVR5cGUgPSBhYmlUeXBlQ2Fpcm9YPy50eXBlID8gYWJpVHlwZUNhaXJvWC50eXBlIDogYWJpVHlwZUNhaXJvWDtcbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXSwgYWJpVHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfVxuICBjb25zdCBvcmRlckVudW0gPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgaWYgKGlzVHlwZVJlc3VsdChhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZFJlc3VsdCA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRPa1R5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCIsXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0RXJyVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIixcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkUmVzdWx0LmlzT2soKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAgIDAgLyogT2sgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRPa1R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAxIC8qIEVyciAqLyxcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgMCAvKiBTb21lICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT3B0aW9uLnVud3JhcCgpLCByZXN1bHRTb21lVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oMSAvKiBOb25lICovLCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHVub3JkZXJlZEN1c3RvbUVudW0gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModW5vcmRlcmVkQ3VzdG9tRW51bS52YXJpYW50KTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhcmlhbnRbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGFiaU9iamVjdC50eXBlLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHZhcmlhbnRUeXBlID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZhcmlhbnRbMF0sIG9yZGVySW5wdXQodW5vcmRlcmVkQ3VzdG9tRW51bS51bndyYXAoKSwgdmFyaWFudFR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bShPYmplY3QuZnJvbUVudHJpZXMobmV3RW50cmllcykpO1xuICB9O1xuICBjb25zdCBmaW5hbE9yZGVyZWRPYmplY3QgPSBhYmlPZk9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoaXNMZW4oYWJpUGFyYW0ubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0W2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGZpbmFsT3JkZXJlZE9iamVjdDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3JlcXVlc3RQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbCkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBlbF91aW50MjU2ID0gdWludDI1Nih2YWwpO1xuICAgICAgcmV0dXJuIFtmZWx0KGVsX3VpbnQyNTYubG93KSwgZmVsdChlbF91aW50MjU2LmhpZ2gpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZlbHQodmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlU3RyKSB7XG4gIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZVN0cik7XG4gIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LnZhbHVlcyhlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gbWVtYmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgUGFyc2VUdXBsZTogcHJvdmlkZWQgYW5kIGV4cGVjdGVkIGFiaSB0dXBsZSBzaXplIGRvIG5vdCBtYXRjaC5cbiAgICAgIHByb3ZpZGVkOiAke2VsZW1lbnRzfSBcbiAgICAgIGV4cGVjdGVkOiAke21lbWJlclR5cGVzfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZW1iZXJUeXBlcy5tYXAoKGl0LCBkeCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50c1tkeF0sXG4gICAgICB0eXBlOiBpdC50eXBlID8/IGl0XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVVpbnQyNTYoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCB7IGxvdywgaGlnaCB9ID0gZWxlbWVudDtcbiAgICByZXR1cm4gW2ZlbHQobG93KSwgZmVsdChoaWdoKV07XG4gIH1cbiAgY29uc3QgZWxfdWludDI1NiA9IHVpbnQyNTYoZWxlbWVudCk7XG4gIHJldHVybiBbZmVsdChlbF91aW50MjU2LmxvdyksIGZlbHQoZWxfdWludDI1Ni5oaWdoKV07XG59XG5mdW5jdGlvbiBwYXJzZUNhbGxkYXRhVmFsdWUoZWxlbWVudCwgdHlwZSwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKGBNaXNzaW5nIHBhcmFtZXRlciBmb3IgdHlwZSAke3R5cGV9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQucHVzaChmZWx0KGVsZW1lbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgYXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlKHR5cGUpO1xuICAgIHJldHVybiBlbGVtZW50LnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKGl0LCBhcnJheVR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICBpZiAoc3RydWN0c1t0eXBlXSAmJiBzdHJ1Y3RzW3R5cGVdLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYodHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKVxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgbWVtYmVycyB9ID0gc3RydWN0c1t0eXBlXTtcbiAgICBjb25zdCBzdWJFbGVtZW50ID0gZWxlbWVudDtcbiAgICByZXR1cm4gbWVtYmVycy5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShzdWJFbGVtZW50W2l0Lm5hbWVdLCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUodHlwZSkpIHtcbiAgICBjb25zdCB0dXBsZWQgPSBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGUpO1xuICAgIHJldHVybiB0dXBsZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gcGFyc2VDYWxsZGF0YVZhbHVlKGl0LmVsZW1lbnQsIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlZERhdGEpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1Nih0eXBlKSkge1xuICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzVHlwZUVudW0odHlwZSwgZW51bXMpKSB7XG4gICAgY29uc3QgeyB2YXJpYW50cyB9ID0gZW51bXNbdHlwZV07XG4gICAgaWYgKGlzVHlwZU9wdGlvbih0eXBlKSkge1xuICAgICAgY29uc3QgbXlPcHRpb24gPSBlbGVtZW50O1xuICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiU29tZVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IE9wdGlvbiBoYXMgbm8gJ1NvbWUnIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRTb21lID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRTb21lID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBTb21lICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteU9wdGlvbi51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudFNvbWUsXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLyogTm9uZSAqLy50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlUmVzdWx0KHR5cGUpKSB7XG4gICAgICBjb25zdCBteVJlc3VsdCA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDMgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiT2tcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdPaycgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudE9rID0gbGlzdFR5cGVWYXJpYW50My50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRPayA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogT2sgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIzID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15UmVzdWx0LnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50T2ssXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIzKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyM107XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIkVyclwiKTtcbiAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnRXJyJyB2YXJpYW50LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZVZhcmlhbnRFcnIgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICBpZiAodHlwZVZhcmlhbnRFcnIgPT09IFwiKClcIikge1xuICAgICAgICByZXR1cm4gMSAvKiBFcnIgKi8udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlSZXN1bHQudW53cmFwKCksIHR5cGVWYXJpYW50RXJyLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICB9XG4gICAgY29uc3QgbXlFbnVtID0gZWxlbWVudDtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm90IGZpbmQgaW4gYWJpIDogRW51bSBoYXMgbm8gJyR7YWN0aXZlVmFyaWFudH0nIHZhcmlhbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVBY3RpdmVWYXJpYW50ID0gbGlzdFR5cGVWYXJpYW50LnR5cGU7XG4gICAgY29uc3QgbnVtQWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmRJbmRleCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZUFjdGl2ZVZhcmlhbnQgPT09IFwiKClcIikge1xuICAgICAgcmV0dXJuIG51bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15RW51bS51bndyYXAoKSwgdHlwZUFjdGl2ZVZhcmlhbnQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIpKSB7XG4gICAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcl07XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICAgIGNhc2UgKGlzVHlwZVN0cnVjdCh0eXBlLCBzdHJ1Y3RzKSB8fCBpc1R5cGVUdXBsZSh0eXBlKSB8fCBpc1R5cGVVaW50MjU2KHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIHVpbnQyNTZUb0JOKHsgbG93LCBoaWdoIH0pO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsZW1lbnQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiKClcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1NihlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbG93ID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgaGlnaCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiB1aW50MjU2VG9CTih7IGxvdywgaGlnaCB9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgaWYgKHN0cnVjdHMgJiYgZWxlbWVudC50eXBlIGluIHN0cnVjdHMgJiYgc3RydWN0c1tlbGVtZW50LnR5cGVdKSB7XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0c1tlbGVtZW50LnR5cGVdLm1lbWJlcnMucmVkdWNlKChhY2MsIGVsKSA9PiB7XG4gICAgICBhY2NbZWwubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChlbnVtcyAmJiBlbGVtZW50LnR5cGUgaW4gZW51bXMgJiYgZW51bXNbZWxlbWVudC50eXBlXSkge1xuICAgIGNvbnN0IHZhcmlhbnROdW0gPSBOdW1iZXIocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHJhd0VudW0gPSBlbnVtc1tlbGVtZW50LnR5cGVdLnZhcmlhbnRzLnJlZHVjZSgoYWNjLCB2YXJpYW50LCBudW0pID0+IHtcbiAgICAgIGlmIChudW0gPT09IHZhcmlhbnROdW0pIHtcbiAgICAgICAgYWNjW3ZhcmlhbnQubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHZhcmlhbnQudHlwZSB9LFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB2YXJpYW50TnVtID09PSAwIC8qIFNvbWUgKi8gPyByYXdFbnVtLlNvbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdFwiKSkge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAodmFyaWFudE51bSA9PT0gMCAvKiBPayAqLykge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5PaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLkVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQodmFyaWFudE51bSwgY29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbUVudW0gPSBuZXcgQ2Fpcm9DdXN0b21FbnVtKHJhd0VudW0pO1xuICAgIHJldHVybiBjdXN0b21FbnVtO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhlbGVtZW50LnR5cGUpO1xuICAgIHJldHVybiBtZW1iZXJUeXBlcy5yZWR1Y2UoKGFjYywgaXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0Py5uYW1lID8gaXQubmFtZSA6IGlkeDtcbiAgICAgIGNvbnN0IHR5cGUgPSBpdD8udHlwZSA/IGl0LnR5cGUgOiBpdDtcbiAgICAgIGNvbnN0IGVsID0geyBuYW1lLCB0eXBlIH07XG4gICAgICBhY2NbbmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKGVsZW1lbnQudHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG59XG5mdW5jdGlvbiByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zLCBwYXJzZWRSZXN1bHQpIHtcbiAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBvdXRwdXQ7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzTGVuKG5hbWUpOlxuICAgICAgdGVtcCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgICBjYXNlIChzdHJ1Y3RzICYmIHR5cGUgaW4gc3RydWN0cyB8fCBpc1R5cGVUdXBsZSh0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgKGVudW1zICYmIGlzVHlwZUVudW0odHlwZSwgZW51bXMpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICAgIGlmIChwYXJzZWRSZXN1bHQgJiYgcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbiA9IHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXTtcbiAgICAgICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgYXJyTGVuKSB7XG4gICAgICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKFxuICAgICAgICAgICAgcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICAgICAgICB7IG5hbWUsIHR5cGU6IG91dHB1dC50eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpIH0sXG4gICAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICAgIGVudW1zXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJpZ2ludFwiLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIikge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludCksIGJ1dCBpcyAke3R5cGVvZiBwYXJhbWV0ZXJ9ICR7cGFyYW1ldGVyfS5gXG4gICk7XG4gIGNvbnN0IHBhcmFtID0gdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiA/IHVpbnQyNTZUb0JOKHBhcmFtZXRlcikgOiB0b0JpZ0ludChwYXJhbWV0ZXIpO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dThcIiAvKiB1OCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMjU1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCAtIDI1NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxNlwiIC8qIHUxNiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNjU1MzVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA2NTUzNV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUzMlwiIC8qIHUzMiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNDI5NDk2NzI5NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDQyOTQ5NjcyOTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1NjRcIiAvKiB1NjQgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDY0biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjY0LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCIgLyogdTEyOCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTI4biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjEyOC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Nm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjI1Ni0xYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCIgLyogQ2xhc3NIYXNoICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTY3MFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCIgLyogQ29udHJhY3RBZGRyZXNzICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI0NVxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUJvb2wgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJib29sZWFuXCIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKEJvb2xlYW4pYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVN0cnVjdCA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKSA9PiB7XG4gIGlmIChpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgaW5wdXQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlQm9vbChiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlQm9vbChwYXJhbSwgaW5wdXQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBWYWxpZGF0ZSBVbmhhbmRsZWQ6IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgJHtwYXJhbWV0ZXJ9YFxuICAgICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgc3RydWN0cywgZW51bXMpIHtcbiAgYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+IHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBhcmdzW2FjY107XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlzTGVuKGlucHV0Lm5hbWUpOlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgY2FzZSBpc1R5cGVGZWx0KGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUZlbHQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoaXNUeXBlVWludChpbnB1dC50eXBlKSB8fCBpc1R5cGVMaXRlcmFsKGlucHV0LnR5cGUpKTpcbiAgICAgICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQm9vbChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCb29sKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlU3RydWN0KGlucHV0LnR5cGUsIHN0cnVjdHMpOlxuICAgICAgICB2YWxpZGF0ZVN0cnVjdChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUVudW0oaW5wdXQudHlwZSwgZW51bXMpOlxuICAgICAgICB2YWxpZGF0ZUVudW0ocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVUdXBsZShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVUdXBsZShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhY2MgKyAxO1xuICB9LCAwKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2luZGV4LnRzXG52YXIgQ2FsbERhdGEgPSBjbGFzcyB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5lbnVtcyA9IENhbGxEYXRhLmdldEFiaUVudW0oYWJpKTtcbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gdGhpcy5wYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbmVzIGluIHRoZSBhYmlcbiAgICogQHBhcmFtIHR5cGUgVmFsaWRhdGVUeXBlIC0gdHlwZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbmFtZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3NPckNhbGxkYXRhIC0gYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqL1xuICB2YWxpZGF0ZSh0eXBlLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGlmICh0eXBlICE9PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgY29uc3QgaW52b2NhYmxlRnVuY3Rpb25OYW1lcyA9IHRoaXMuYWJpLmZpbHRlcigoYWJpKSA9PiB7XG4gICAgICAgIGlmIChhYmkudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNWaWV3ID0gYWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgYWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8gPyAhaXNWaWV3IDogaXNWaWV3O1xuICAgICAgfSkubWFwKChhYmkpID0+IGFiaS5uYW1lKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgaW52b2NhYmxlRnVuY3Rpb25OYW1lcy5pbmNsdWRlcyhtZXRob2QpLFxuICAgICAgICBgJHt0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/IFwiaW52b2NhYmxlXCIgOiBcInZpZXdhYmxlXCJ9IG1ldGhvZCBub3QgZm91bmQgaW4gYWJpYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZChcbiAgICAgIChhYmkpID0+IHR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovID8gYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiIDogYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0c0xlbmd0aCA9IHRoaXMucGFyc2VyLm1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gaW5wdXRzTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgZXhwZWN0ZWQgJHtpbnB1dHNMZW5ndGh9IGFyZ3VtZW50cywgYnV0IGdvdCAke2FyZ3MubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRoIGFiaVxuICAgKiBQYXJzZSB0aGUgY2FsbGRhdGEgYnkgdXNpbmcgaW5wdXQgZmllbGRzIGZyb20gdGhlIGFiaSBmb3IgdGhhdCBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gYXJncyBSYXdBcmdzIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBDYW4gYmUgYW4gYXJyYXkgb2YgYXJndW1lbnRzIChpbiB0aGUgb3JkZXIgb2YgYWJpIGRlZmluaXRpb24pLCBvciBhbiBvYmplY3QgY29uc3RydWN0ZWQgaW4gY29uZm9ybWl0eSB3aXRoIGFiaSAoaW4gdGhpcyBjYXNlLCB0aGUgcGFyYW1ldGVyIGNhbiBiZSBpbiBhIHdyb25nIG9yZGVyKS5cbiAgICogQHJldHVybiBDYWxsZGF0YSAtIHBhcnNlZCBhcmd1bWVudHMgaW4gZm9ybWF0IHRoYXQgY29udHJhY3QgaXMgZXhwZWN0aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBbXCIweDM0YVwiLCBbMSwgM25dXSk7XG4gICAqIGBgYFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhMiA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHtsaXN0OlsxLCAzbl0sIGJhbGFuY2U6XCIweDM0XCJ9KTsgLy8gd3Jvbmcgb3JkZXIgaXMgdmFsaWRcbiAgICogYGBgXG4gICAqL1xuICBjb21waWxlKG1ldGhvZCwgYXJnc0NhbGxkYXRhKSB7XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZCgoYWJpRnVuY3Rpb24pID0+IGFiaUZ1bmN0aW9uLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBhcmdzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NDYWxsZGF0YSkpIHtcbiAgICAgIGFyZ3MgPSBhcmdzQ2FsbGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyZWRPYmplY3QgPSBvcmRlclByb3BzQnlBYmkoXG4gICAgICAgIGFyZ3NDYWxsZGF0YSxcbiAgICAgICAgYWJpTWV0aG9kLmlucHV0cyxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApO1xuICAgICAgYXJncyA9IE9iamVjdC52YWx1ZXMob3JkZXJlZE9iamVjdCk7XG4gICAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3NJdGVyYXRvciA9IGFyZ3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNhbGxBcnJheSA9IGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgaW5wdXQpID0+IGlzTGVuKGlucHV0Lm5hbWUpICYmICFpc0NhaXJvMVR5cGUoaW5wdXQudHlwZSkgPyBhY2MgOiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbEFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxBcnJheTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRob3V0IGFiaVxuICAgKiBAcGFyYW0gcmF3QXJncyBSYXdBcmdzIHJlcHJlc2VudGluZyBjYWlybyBtZXRob2QgYXJndW1lbnRzIG9yIHN0cmluZyBhcnJheSBvZiBjb21waWxlZCBkYXRhXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgY29tcGlsZShyYXdBcmdzKSB7XG4gICAgY29uc3QgY3JlYXRlVHJlZSA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IGdldEVudHJpZXMgPSAobywgcHJlZml4ID0gXCIuXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb2UgPSBBcnJheS5pc0FycmF5KG8pID8gW28ubGVuZ3RoLnRvU3RyaW5nKCksIC4uLm9dIDogbztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9lKS5mbGF0TWFwKChbaywgdl0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2O1xuICAgICAgICAgIGlmIChrID09PSBcImVudHJ5cG9pbnRcIilcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb25nVGV4dCh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0TG9uZ1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qga2sgPSBBcnJheS5pc0FycmF5KG9lKSAmJiBrID09PSBcIjBcIiA/IFwiJCRsZW5cIiA6IGs7XG4gICAgICAgICAgaWYgKGlzQmlnSW50KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIC4uLm1ldGhvZHNLZXlzXTtcbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNTb21lXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc05vbmVcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlPcHRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlPcHRpb24uaXNTb21lKCkgPyAwIC8qIFNvbWUgKi8gOiAxIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlPcHRpb24udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhcmlhbnROYildXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlSZXN1bHQuaXNPaygpID8gMCAvKiBPayAqLyA6IDEgLyogRXJyICovO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlSZXN1bHQudW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJ2YXJpYW50XCIpICYmIGtleXMuaW5jbHVkZXMoXCJhY3RpdmVWYXJpYW50XCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15RW51bSA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdFZhcmlhbnRzID0gT2JqZWN0LmtleXMobXlFbnVtLnZhcmlhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50TmIgPSBsaXN0VmFyaWFudHMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICh2YXJpYW50KSA9PiB2YXJpYW50ID09PSBhY3RpdmVWYXJpYW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlFbnVtLnVud3JhcCgpID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG15RW51bS51bndyYXAoKSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdChhY3RpdmVWYXJpYW50TmIpXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiBhY3RpdmVWYXJpYW50TmIsIDE6IG15RW51bS51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh2YWx1ZSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0RW50cmllcyhvYmopKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBsZXQgY2FsbFRyZWVBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3QXJncykpIHtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShyYXdBcmdzKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2FsbE9iaiA9IHsgLi4ucmF3QXJncyB9O1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKGNhbGxPYmopO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbFRyZWVBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsVHJlZUFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBlbGVtZW50cyBvZiB0aGUgcmVzcG9uc2UgYXJyYXkgYW5kIHN0cnVjdHVyaW5nIHRoZW0gaW50byByZXNwb25zZSBvYmplY3RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSByZXNwb25zZSBmcm9tIHRoZSBtZXRob2RcbiAgICogQHJldHVybiBSZXN1bHQgLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0aGUgYWJpXG4gICAqL1xuICBwYXJzZShtZXRob2QsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSB0aGlzLmFiaS5maW5kKChhYmkpID0+IGFiaS5uYW1lID09PSBtZXRob2QpO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dHMuZmxhdCgpLnJlZHVjZSgoYWNjLCBvdXRwdXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSBvdXRwdXQubmFtZSA/PyBpZHg7XG4gICAgICBhY2NbcHJvcE5hbWVdID0gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMsIGFjYyk7XG4gICAgICBpZiAoYWNjW3Byb3BOYW1lXSAmJiBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdKSB7XG4gICAgICAgIGRlbGV0ZSBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID09PSAxICYmIDAgaW4gcGFyc2VkID8gcGFyc2VkWzBdIDogcGFyc2VkO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgY2Fpcm8gbWV0aG9kIHJlc3BvbnNlIGRhdGEgdG8gbmF0aXZlIGpzIHZhbHVlcyBiYXNlZCBvbiBwcm92aWRlZCBmb3JtYXQgc2NoZW1hXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gY2Fpcm8gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gY2Fpcm8gbWV0aG9kIHJlc3BvbnNlXG4gICAqIEBwYXJhbSBmb3JtYXQgb2JqZWN0IC0gZm9ybWF0dGVyIG9iamVjdCBzY2hlbWFcbiAgICogQHJldHVybnMgUmVzdWx0IC0gcGFyc2VkIGFuZCBmb3JtYXR0ZWQgcmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuICBmb3JtYXQobWV0aG9kLCByZXNwb25zZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZShtZXRob2QsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyKHBhcnNlZCwgZm9ybWF0KTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3Qgc3RydWN0cyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlTdHJ1Y3RzIC0gc3RydWN0cyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaVN0cnVjdChhYmkpIHtcbiAgICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwic3RydWN0XCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBlbnVtcyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlFbnVtcyAtIGVudW1zIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpRW51bShhYmkpIHtcbiAgICBjb25zdCBmdWxsRW51bUxpc3QgPSBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJlbnVtXCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICAgIGRlbGV0ZSBmdWxsRW51bUxpc3RbXCJjb3JlOjpib29sXCJdO1xuICAgIHJldHVybiBmdWxsRW51bUxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29tcGlsZSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcGFyYW0gcmF3Q2FsbGRhdGEgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0NhbGxkYXRhKHJhd0NhbGxkYXRhID0gW10pIHtcbiAgICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZShyYXdDYWxsZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29udmVydCByYXcgdG8gSGV4Q2FsbGRhdGFcbiAgICogQHBhcmFtIHJhdyBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBIZXhDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvSGV4KHJhdyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKHJhdyk7XG4gICAgcmV0dXJuIGNhbGxkYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIGNvbnRyYWN0IHJlc3BvbnNlIGFuZCBzdHJ1Y3R1cmUgdGhlbSBpbnRvIG9uZSBvciBzZXZlcmFsIFJlc3VsdC5cbiAgICogSW4gQ2Fpcm8gMCwgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gdHlwZUNhaXJvIHN0cmluZyBvciBzdHJpbmdbXSAtIENhaXJvIHR5cGUgbmFtZSwgZXggOiBcImhlbGxvOjpoZWxsbzo6VXNlckRhdGFcIlxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBzZXJpYWxpemVkIGRhdGEgY29ycmVzcG9uZGluZyB0byB0eXBlQ2Fpcm8uXG4gICAqIEByZXR1cm4gUmVzdWx0IG9yIFJlc3VsdFtdIC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdHlwZURhdGEuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlczI9aGVsbG9DYWxsRGF0YS5kZWNvZGVQYXJhbWV0ZXJzKFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiLFtcIjB4MTIzNDU2XCIsXCIweDFcIl0pO1xuICAgKiByZXN1bHQgPSB7IGFkZHJlc3M6IDExOTMwNDZuLCBpc19jbGFpbWVkOiB0cnVlIH1cbiAgICovXG4gIGRlY29kZVBhcmFtZXRlcnModHlwZUNhaXJvLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHR5cGVDYWlyb0FycmF5ID0gQXJyYXkuaXNBcnJheSh0eXBlQ2Fpcm8pID8gdHlwZUNhaXJvIDogW3R5cGVDYWlyb107XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGVjb2RlZEFycmF5ID0gdHlwZUNhaXJvQXJyYXkubWFwKFxuICAgICAgKHR5cGVQYXJhbSkgPT4gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogdHlwZVBhcmFtIH0sXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRBcnJheS5sZW5ndGggPT09IDEgPyBkZWNvZGVkQXJyYXlbMF0gOiBkZWNvZGVkQXJyYXk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYXNoLnRzXG52YXIgaGFzaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChoYXNoX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2g6ICgpID0+IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoLFxuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uLFxuICBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaCxcbiAgY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaDogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlUG9zZWlkb25IYXNoOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBkZWZhdWx0OiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBmZWVUcmFuc2FjdGlvblZlcnNpb246ICgpID0+IGZlZVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzI6ICgpID0+IGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBnZXRWZXJzaW9uc0J5VHlwZTogKCkgPT4gZ2V0VmVyc2lvbnNCeVR5cGUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWssXG4gIHRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gdHJhbnNhY3Rpb25WZXJzaW9uLFxuICB0cmFuc2FjdGlvblZlcnNpb25fMjogKCkgPT4gdHJhbnNhY3Rpb25WZXJzaW9uXzJcbn0pO1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcblxuLy8gc3JjL3V0aWxzL2VjLnRzXG52YXIgZWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWNfZXhwb3J0cywge1xuICBzdGFya0N1cnZlOiAoKSA9PiBzdGFya0N1cnZlLFxuICB3ZWllcnN0cmFzczogKCkgPT4gd2VpZXJzdHJhc3Ncbn0pO1xuaW1wb3J0ICogYXMgc3RhcmtDdXJ2ZSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgKiBhcyB3ZWllcnN0cmFzcyBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzc1wiO1xuXG4vLyBzcmMvdXRpbHMvanNvbi50c1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHBhcnNlQWx3YXlzQXNCaWc6ICgpID0+IHBhcnNlQWx3YXlzQXNCaWcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5MixcbiAgc3RyaW5naWZ5QWx3YXlzQXNCaWc6ICgpID0+IHN0cmluZ2lmeUFsd2F5c0FzQmlnXG59KTtcbmltcG9ydCAqIGFzIGpzb24gZnJvbSBcImxvc3NsZXNzLWpzb25cIjtcbnZhciBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQgPSAoeCkgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHgpKVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICBjb25zdCB2ID0gcGFyc2VJbnQoeCwgMTApO1xuICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodikgPyB2IDogQmlnSW50KHgpO1xufTtcbnZhciBwYXJzZTIgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHgpID0+IGpzb24ucGFyc2UoU3RyaW5nKHgpLCB2b2lkIDAsIGpzb24ucGFyc2VOdW1iZXJBbmRCaWdJbnQpO1xudmFyIHN0cmluZ2lmeTIgPSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSA9PiBqc29uLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpO1xudmFyIHN0cmluZ2lmeUFsd2F5c0FzQmlnID0gc3RyaW5naWZ5MjtcblxuLy8gc3JjL3V0aWxzL2hhc2gudHNcbmltcG9ydCAqIGFzIHBvc2VpZG9uIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCI7XG52YXIgdHJhbnNhY3Rpb25WZXJzaW9uID0gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xO1xudmFyIHRyYW5zYWN0aW9uVmVyc2lvbl8yID0gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yO1xudmFyIGZlZVRyYW5zYWN0aW9uVmVyc2lvbiA9IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIgPSBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yO1xuZnVuY3Rpb24gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpIHtcbiAgcmV0dXJuIHZlcnNpb25UeXBlID09PSBcImZlZVwiID8geyB2MTogZmVlVHJhbnNhY3Rpb25WZXJzaW9uLCB2MjogZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIgfSA6IHsgdjE6IHRyYW5zYWN0aW9uVmVyc2lvbiwgdjI6IHRyYW5zYWN0aW9uVmVyc2lvbl8yIH07XG59XG5mdW5jdGlvbiBjb21wdXRlUGVkZXJzZW5IYXNoKGEsIGIpIHtcbiAgcmV0dXJuIHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KGEpLCBCaWdJbnQoYikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBvc2VpZG9uSGFzaChhLCBiKSB7XG4gIHJldHVybiB0b0hleChzdGFya0N1cnZlLnBvc2VpZG9uSGFzaChCaWdJbnQoYSksIEJpZ0ludChiKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludCh4KSwgQmlnSW50KHkpKSwgMCkudG9TdHJpbmcoKTtcbn1cbnZhciBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyA9IGNvbXB1dGVIYXNoT25FbGVtZW50cztcbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkoZGF0YS5tYXAoKHgpID0+IEJpZ0ludCh4KSkpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbih0eEhhc2hQcmVmaXgsIHZlcnNpb24sIGNvbnRyYWN0QWRkcmVzcywgZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSwgbWF4RmVlLCBjaGFpbklkLCBhZGRpdGlvbmFsRGF0YSA9IFtdKSB7XG4gIGNvbnN0IGNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjYWxsZGF0YSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGVudHJ5UG9pbnRTZWxlY3RvcixcbiAgICBjYWxsZGF0YUhhc2gsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgLi4uYWRkaXRpb25hbERhdGFcbiAgXTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhVG9IYXNoKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHZlcnNpb24sIGNoYWluSWQsIGNvbnN0cnVjdG9yTmFtZSA9IFwiY29uc3RydWN0b3JcIikge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NzA2YzZmNzlcIiAvKiBERVBMT1kgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZ2V0U2VsZWN0b3JGcm9tTmFtZShjb25zdHJ1Y3Rvck5hbWUpLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgMCxcbiAgICBjaGFpbklkXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKGNsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSwgY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICAwLFxuICAgIFtjbGFzc0hhc2hdLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZSwgLi4uY29tcGlsZWRDbGFzc0hhc2ggPyBbY29tcGlsZWRDbGFzc0hhc2hdIDogW11dXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIGNvbnN0IGNhbGxkYXRhID0gW2NsYXNzSGFzaCwgc2FsdCwgLi4uY29uc3RydWN0b3JDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIHZlcnNpb24sIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKHNhbHQsIGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgZGVwbG95ZXJBZGRyZXNzKSB7XG4gIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjb21waWxlZENhbGxkYXRhKTtcbiAgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVggPSBmZWx0KFwiMHg1MzU0NDE1MjRiNGU0NTU0NWY0MzRmNGU1NDUyNDE0MzU0NWY0MTQ0NDQ1MjQ1NTM1M1wiKTtcbiAgY29uc3QgaGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhbXG4gICAgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgsXG4gICAgZGVwbG95ZXJBZGRyZXNzLFxuICAgIHNhbHQsXG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoXG4gIF0pO1xuICByZXR1cm4gdG9IZXgoQmlnSW50KGhhc2gpICUgQUREUl9CT1VORCk7XG59XG5mdW5jdGlvbiBudWxsU2tpcFJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgfHwga2V5ID09PSBcImFjY2Vzc2libGVfc2NvcGVzXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkZWJ1Z19pbmZvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNwYWNlcyhqc29uMikge1xuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XG4gIGNvbnN0IG5ld1N0cmluZyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2YganNvbjIpIHtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiAobmV3U3RyaW5nLmxlbmd0aCA+IDAgJiYgbmV3U3RyaW5nLnNsaWNlKC0xKVswXSA9PT0gXCJcXFxcXCIpID09PSBmYWxzZSkge1xuICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcbiAgICB9XG4gICAgaWYgKGluc2lkZVF1b3Rlcykge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIgPT09IFwiOlwiID8gXCI6IFwiIDogY2hhciA9PT0gXCIsXCIgPyBcIiwgXCIgOiBjaGFyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmluZy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KSB7XG4gIGNvbnN0IHsgYWJpLCBwcm9ncmFtIH0gPSBjb21waWxlZENvbnRyYWN0O1xuICBjb25zdCBjb250cmFjdENsYXNzID0geyBhYmksIHByb2dyYW0gfTtcbiAgY29uc3Qgc2VyaWFsaXplZEpzb24gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdENsYXNzLCBudWxsU2tpcFJlcGxhY2VyKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoc2VyaWFsaXplZEpzb24pKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSB0b0hleChBUElfVkVSU0lPTik7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgYnVpbHRpbnNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5idWlsdGlucy5tYXAoKHMpID0+IGVuY29kZVNob3J0U3RyaW5nKHMpKVxuICApO1xuICBjb25zdCBoaW50ZWRDbGFzc0hhc2ggPSBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xuICBjb25zdCBkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjb21waWxlZENvbnRyYWN0LnByb2dyYW0uZGF0YSk7XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMoW1xuICAgIGFwaVZlcnNpb24sXG4gICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoLFxuICAgIGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2gsXG4gICAgYnVpbHRpbnNIYXNoLFxuICAgIGhpbnRlZENsYXNzSGFzaCxcbiAgICBkYXRhSGFzaFxuICBdKTtcbn1cbmZ1bmN0aW9uIGhhc2hCdWlsdGlucyhidWlsdGlucykge1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShcbiAgICBidWlsdGlucy5mbGF0TWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhpdCkpO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludChkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQub2Zmc2V0KSwgaGFzaEJ1aWx0aW5zKGl0LmJ1aWx0aW5zKV07XG4gIH0pO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShiYXNlKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChjYXNtKSB7XG4gIGNvbnN0IENPTVBJTEVEX0NMQVNTX1ZFUlNJT04gPSBcIkNPTVBJTEVEX0NMQVNTX1YxXCI7XG4gIGNvbnN0IGNvbXBpbGVkQ2xhc3NWZXJzaW9uID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKENPTVBJTEVEX0NMQVNTX1ZFUlNJT04pKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUik7XG4gIGNvbnN0IGJ5dGVjb2RlID0gcG9zZWlkb25IYXNoTWFueShjYXNtLmJ5dGVjb2RlLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVjb2RlXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50U2llcnJhKGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5mdW5jdGlvbl9pZHgpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KGJhc2UpO1xufVxuZnVuY3Rpb24gaGFzaEFiaShzaWVycmEpIHtcbiAgY29uc3QgaW5kZW50U3RyaW5nID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoc2llcnJhLmFiaSwgbnVsbCkpO1xuICByZXR1cm4gQmlnSW50KGFkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShpbmRlbnRTdHJpbmcpKS50b1N0cmluZygxNikpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChzaWVycmEpIHtcbiAgY29uc3QgQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTiA9IFwiQ09OVFJBQ1RfQ0xBU1NfVjAuMS4wXCI7XG4gIGNvbnN0IGNvbXBpbGVkQ2xhc3NWZXJzaW9uID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKENPTlRSQUNUX0NMQVNTX1ZFUlNJT04pKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwpO1xuICBjb25zdCBsMUhhbmRsZXJzID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUik7XG4gIGNvbnN0IGFiaUhhc2ggPSBoYXNoQWJpKHNpZXJyYSk7XG4gIGNvbnN0IHNpZXJyYVByb2dyYW0gPSBwb3NlaWRvbkhhc2hNYW55KHNpZXJyYS5zaWVycmFfcHJvZ3JhbS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKSk7XG4gIHJldHVybiB0b0hleChcbiAgICBwb3NlaWRvbkhhc2hNYW55KFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhYmlIYXNoLFxuICAgICAgc2llcnJhUHJvZ3JhbVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RhcmsudHNcbnZhciBzdGFya19leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya19leHBvcnRzLCB7XG4gIGNvbXByZXNzUHJvZ3JhbTogKCkgPT4gY29tcHJlc3NQcm9ncmFtLFxuICBkZWNvbXByZXNzUHJvZ3JhbTogKCkgPT4gZGVjb21wcmVzc1Byb2dyYW0sXG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlOiAoKSA9PiBlc3RpbWF0ZWRGZWVUb01heEZlZSxcbiAgZm9ybWF0U2lnbmF0dXJlOiAoKSA9PiBmb3JtYXRTaWduYXR1cmUsXG4gIG1ha2VBZGRyZXNzOiAoKSA9PiBtYWtlQWRkcmVzcyxcbiAgcmFuZG9tQWRkcmVzczogKCkgPT4gcmFuZG9tQWRkcmVzcyxcbiAgc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5LFxuICBzaWduYXR1cmVUb0hleEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0hleEFycmF5XG59KTtcbmltcG9ydCB7IGdldFN0YXJrS2V5LCB1dGlscyB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCB7IGd6aXAsIHVuZ3ppcCB9IGZyb20gXCJwYWtvXCI7XG5mdW5jdGlvbiBjb21wcmVzc1Byb2dyYW0oanNvblByb2dyYW0pIHtcbiAgY29uc3Qgc3RyaW5naWZpZWQgPSB0eXBlb2YganNvblByb2dyYW0gPT09IFwic3RyaW5nXCIgPyBqc29uUHJvZ3JhbSA6IHN0cmluZ2lmeTIoanNvblByb2dyYW0pO1xuICBjb25zdCBjb21wcmVzc2VkUHJvZ3JhbSA9IGd6aXAoc3RyaW5naWZpZWQpO1xuICByZXR1cm4gYnRvYVVuaXZlcnNhbChjb21wcmVzc2VkUHJvZ3JhbSk7XG59XG5mdW5jdGlvbiBkZWNvbXByZXNzUHJvZ3JhbShiYXNlNjQyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2U2NDIpKVxuICAgIHJldHVybiBiYXNlNjQyO1xuICBjb25zdCBkZWNvbXByZXNzZWQgPSBhcnJheUJ1ZmZlclRvU3RyaW5nKHVuZ3ppcChhdG9iVW5pdmVyc2FsKGJhc2U2NDIpKSk7XG4gIHJldHVybiBwYXJzZTIoZGVjb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUFkZHJlc3MoKSB7XG4gIGNvbnN0IHJhbmRvbUtleVBhaXIgPSB1dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIHJldHVybiBnZXRTdGFya0tleShyYW5kb21LZXlQYWlyKTtcbn1cbmZ1bmN0aW9uIG1ha2VBZGRyZXNzKGlucHV0KSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoaW5wdXQpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaWduYXR1cmUoc2lnKSB7XG4gIGlmICghc2lnKVxuICAgIHRocm93IEVycm9yKFwiZm9ybWF0U2lnbmF0dXJlOiBwcm92aWRlZCBzaWduYXR1cmUgaXMgdW5kZWZpbmVkXCIpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzaWcpKSB7XG4gICAgcmV0dXJuIHNpZy5tYXAoKGl0KSA9PiB0b0hleChpdCkpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzaWc7XG4gICAgcmV0dXJuIFt0b0hleChyKSwgdG9IZXgocyldO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIG5lZWQgdG8gYmUgd2VpZXJzdHJhc3MuU2lnbmF0dXJlVHlwZSBvciBhbiBhcnJheSBmb3IgY3VzdG9tXCIpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWcpIHtcbiAgcmV0dXJuIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9IZXhBcnJheShzaWcpIHtcbiAgcmV0dXJuIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlZEZlZVRvTWF4RmVlKGVzdGltYXRlZEZlZSwgb3ZlcmhlYWQgPSAwLjUpIHtcbiAgY29uc3Qgb3ZlckhlYWRQZXJjZW50ID0gTWF0aC5yb3VuZCgoMSArIG92ZXJoZWFkKSAqIDEwMCk7XG4gIHJldHVybiB0b0JpZ0ludChlc3RpbWF0ZWRGZWUpICogdG9CaWdJbnQob3ZlckhlYWRQZXJjZW50KSAvIDEwMG47XG59XG5cbi8vIHNyYy91dGlscy9jb250cmFjdC50c1xuZnVuY3Rpb24gaXNTaWVycmEoY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgcmV0dXJuIFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0O1xufVxuZnVuY3Rpb24gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSB7IC4uLnBheWxvYWQgfTtcbiAgaWYgKGlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpKSB7XG4gICAgaWYgKCFwYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoICYmIHBheWxvYWQuY2FzbSkge1xuICAgICAgcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2ggPSBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2gocGF5bG9hZC5jYXNtKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5jb21waWxlZENsYXNzSGFzaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHRyYWN0IGNvbXBpbGVkQ2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ2Fpcm9Bc3NlbWJseSkuY2FzbSBmaWxlIG9yIGNvbXBpbGVkQ2xhc3NIYXNoXCJcbiAgICAgICk7XG4gIH1cbiAgcmVzcG9uc2UuY2xhc3NIYXNoID0gcGF5bG9hZC5jbGFzc0hhc2ggPz8gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKHBheWxvYWQuY29udHJhY3QpO1xuICBpZiAoIXJlc3BvbnNlLmNsYXNzSGFzaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRyYWN0IGNsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENvbXBpbGVkQ29udHJhY3QpLmpzb24gZmlsZSBvciBjbGFzc0hhc2hcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdChjY3IpIHtcbiAgaWYgKGlzU2llcnJhKGNjcikpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0Q2xhc3NSZXNwb25zZSBuZWVkIHRvIGJlIExlZ2FjeUNvbnRyYWN0Q2xhc3MgKGNhaXJvMCByZXNwb25zZSBjbGFzcylcIik7XG4gIH1cbiAgY29uc3QgY29udHJhY3QgPSBjY3I7XG4gIHJldHVybiB7IC4uLmNvbnRyYWN0LCBwcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5wcm9ncmFtKSB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZmV0Y2hQb255ZmlsbC50c1xuaW1wb3J0IGlzb21vcnBoaWNGZXRjaCBmcm9tIFwiaXNvbW9ycGhpYy1mZXRjaFwiO1xudmFyIGZldGNoUG9ueWZpbGxfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmZldGNoIHx8IC8vIHVzZSBidWlsZGluIGZldGNoIGluIGJyb3dzZXIgaWYgYXZhaWxhYmxlXG50eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBub2RlLCByZWFjdC1uYXRpdmUgYW5kIHNlcnZpY2Ugd29ya2VyIGlmIGF2YWlsYWJsZVxuaXNvbW9ycGhpY0ZldGNoO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3M6ICgpID0+IGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MsXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHdhaXQ6ICgpID0+IHdhaXRcbn0pO1xuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzLCBkZWxheSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhjb250cmFjdCkge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmNvbnRyYWN0IH07XG4gIGRlbGV0ZSByZXN1bHQuc2llcnJhX3Byb2dyYW1fZGVidWdfaW5mbztcbiAgcmVzdWx0LmFiaSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LmFiaSkpO1xuICByZXN1bHQuc2llcnJhX3Byb2dyYW0gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5zaWVycmFfcHJvZ3JhbSkpO1xuICByZXN1bHQuc2llcnJhX3Byb2dyYW0gPSBjb21wcmVzc1Byb2dyYW0ocmVzdWx0LnNpZXJyYV9wcm9ncmFtKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udHJhY3QoY29udHJhY3QpIHtcbiAgY29uc3QgcGFyc2VkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZENvbnRyYWN0LFxuICAgICAgLi4uXCJwcm9ncmFtXCIgaW4gcGFyc2VkQ29udHJhY3QgJiYgeyBwcm9ncmFtOiBjb21wcmVzc1Byb2dyYW0ocGFyc2VkQ29udHJhY3QucHJvZ3JhbSkgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MocGFyc2VkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvcnBjLnRzXG52YXIgUlBDUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyB7XG4gIHBhcnNlR2V0QmxvY2tSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wOiByZXMudGltZXN0YW1wLFxuICAgICAgYmxvY2tfaGFzaDogXCJibG9ja19oYXNoXCIgaW4gcmVzID8gcmVzLmJsb2NrX2hhc2ggOiBcIlwiLFxuICAgICAgYmxvY2tfbnVtYmVyOiBcImJsb2NrX251bWJlclwiIGluIHJlcyA/IHJlcy5ibG9ja19udW1iZXIgOiAtMSxcbiAgICAgIG5ld19yb290OiBcIm5ld19yb290XCIgaW4gcmVzID8gcmVzLm5ld19yb290IDogXCJcIixcbiAgICAgIHBhcmVudF9oYXNoOiByZXMucGFyZW50X2hhc2gsXG4gICAgICBzdGF0dXM6IFwic3RhdHVzXCIgaW4gcmVzID8gcmVzLnN0YXR1cyA6IFwiUEVORElOR1wiIC8qIFBFTkRJTkcgKi8sXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlcy50cmFuc2FjdGlvbnNcbiAgICB9O1xuICB9XG4gIHBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGRhdGE6IFwiY2FsbGRhdGFcIiBpbiByZXMgPyByZXMuY2FsbGRhdGEgOiBbXSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IFwiY29udHJhY3RfYWRkcmVzc1wiIGluIHJlcyA/IHJlcy5jb250cmFjdF9hZGRyZXNzIDogXCJcIixcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBcInNlbmRlcl9hZGRyZXNzXCIgaW4gcmVzID8gcmVzLnNlbmRlcl9hZGRyZXNzIDogXCJcIixcbiAgICAgIG1heF9mZWU6IFwibWF4X2ZlZVwiIGluIHJlcyA/IHJlcy5tYXhfZmVlIDogXCJcIixcbiAgICAgIG5vbmNlOiBcIm5vbmNlXCIgaW4gcmVzID8gcmVzLm5vbmNlIDogXCJcIixcbiAgICAgIHNpZ25hdHVyZTogXCJzaWduYXR1cmVcIiBpbiByZXMgPyByZXMuc2lnbmF0dXJlIDogW10sXG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiByZXMudHJhbnNhY3Rpb25faGFzaCxcbiAgICAgIHZlcnNpb246IHJlcy52ZXJzaW9uXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChyZXNbMF0ub3ZlcmFsbF9mZWUpLFxuICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludChyZXNbMF0uZ2FzX2NvbnN1bWVkKSxcbiAgICAgIGdhc19wcmljZTogdG9CaWdJbnQocmVzWzBdLmdhc19wcmljZSlcbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5tYXAoKHZhbCkgPT4gKHtcbiAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludCh2YWwub3ZlcmFsbF9mZWUpLFxuICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludCh2YWwuZ2FzX2NvbnN1bWVkKSxcbiAgICAgIGdhc19wcmljZTogdG9CaWdJbnQodmFsLmdhc19wcmljZSlcbiAgICB9KSk7XG4gIH1cbiAgcGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXNcbiAgICB9O1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KGl0LmZlZV9lc3RpbWF0aW9uLm92ZXJhbGxfZmVlKSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIGFiaTogdHlwZW9mIHJlcy5hYmkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHJlcy5hYmkpIDogcmVzLmFiaVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9lcnJvcnMudHNcbmZ1bmN0aW9uIGZpeFN0YWNrKHRhcmdldCwgZm4gPSB0YXJnZXQuY29uc3RydWN0b3IpIHtcbiAgY29uc3QgeyBjYXB0dXJlU3RhY2tUcmFjZSB9ID0gRXJyb3I7XG4gIGNhcHR1cmVTdGFja1RyYWNlICYmIGNhcHR1cmVTdGFja1RyYWNlKHRhcmdldCwgZm4pO1xufVxuZnVuY3Rpb24gZml4UHJvdG8odGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgY29uc3QgeyBzZXRQcm90b3R5cGVPZiB9ID0gT2JqZWN0O1xuICBzZXRQcm90b3R5cGVPZiA/IHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG90eXBlKSA6IHRhcmdldC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG59XG52YXIgQ3VzdG9tRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgbmFtZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgdmFsdWU6IG5ldy50YXJnZXQubmFtZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZml4UHJvdG8odGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIGZpeFN0YWNrKHRoaXMpO1xuICB9XG59O1xudmFyIExpYnJhcnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ3VzdG9tRXJyb3Ige1xufTtcbnZhciBHYXRld2F5RXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xudmFyIEh0dHBFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9zdGFya25ldElkLnRzXG52YXIgc3RhcmtuZXRJZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya25ldElkX2V4cG9ydHMsIHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICB1c2VEZWNvZGVkOiAoKSA9PiB1c2VEZWNvZGVkLFxuICB1c2VFbmNvZGVkOiAoKSA9PiB1c2VFbmNvZGVkXG59KTtcbnZhciBiYXNpY0FscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXCI7XG52YXIgYmFzaWNTaXplUGx1c09uZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCArIDEpO1xudmFyIGJpZ0FscGhhYmV0ID0gXCJcXHU4RkQ5XFx1Njc2NVwiO1xudmFyIGJhc2ljQWxwaGFiZXRTaXplID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemVQbHVzT25lID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCArIDEpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YXJzKHN0cikge1xuICBsZXQgayA9IDA7XG4gIHdoaWxlIChzdHIuZW5kc1dpdGgoYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0pKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgayArPSAxO1xuICB9XG4gIHJldHVybiBbc3RyLCBrXTtcbn1cbmZ1bmN0aW9uIHVzZURlY29kZWQoZW5jb2RlZCkge1xuICBsZXQgZGVjb2RlZCA9IFwiXCI7XG4gIGVuY29kZWQuZm9yRWFjaCgoc3ViZG9tYWluKSA9PiB7XG4gICAgd2hpbGUgKHN1YmRvbWFpbiAhPT0gWkVSTykge1xuICAgICAgY29uc3QgY29kZSA9IHN1YmRvbWFpbiAlIGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBzdWJkb21haW4gLz0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGlmIChjb2RlID09PSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdWJkb21haW4gPSBzdWJkb21haW4gLyBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICBpZiAobmV4dFN1YmRvbWFpbiA9PT0gWkVSTykge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgICBzdWJkb21haW4gPSBuZXh0U3ViZG9tYWluO1xuICAgICAgICAgIGlmIChjb2RlMiA9PT0gWkVSTylcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFswXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMikgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMildO1xuICAgICAgICAgIHN1YmRvbWFpbiAvPSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbTnVtYmVyKGNvZGUpXTtcbiAgICB9XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgKGsgJSAyID09PSAwID8gYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KGsgLyAyIC0gMSkgKyBiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0gOiBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoKGsgLSAxKSAvIDIgKyAxKSk7XG4gICAgZGVjb2RlZCArPSBcIi5cIjtcbiAgfSk7XG4gIGlmICghZGVjb2RlZCkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmNvbmNhdChcInN0YXJrXCIpO1xufVxuZnVuY3Rpb24gdXNlRW5jb2RlZChkZWNvZGVkKSB7XG4gIGxldCBlbmNvZGVkID0gQmlnSW50KDApO1xuICBsZXQgbXVsdGlwbGllciA9IEJpZ0ludCgxKTtcbiAgaWYgKGRlY29kZWQuZW5kc1dpdGgoYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdKSkge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQuc3Vic3RyaW5nKDAsIGRlY29kZWQubGVuZ3RoIC0gMikpO1xuICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMiAqIChrICsgMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgxICsgMiAqIChrIC0gMSkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBkZWNvZGVkW2ldO1xuICAgIGNvbnN0IGluZGV4ID0gYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgIGNvbnN0IGJuSW5kZXggPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxICYmIGRlY29kZWRbaV0gPT09IGJhc2ljQWxwaGFiZXRbMF0pIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYm5JbmRleDtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKSAhPT0gLTEpIHtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgY29uc3QgbmV3aWQgPSAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxID8gMSA6IDApICsgYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIEJpZ0ludChuZXdpZCk7XG4gICAgICBtdWx0aXBsaWVyICo9IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG52YXIgU3RhcmtuZXRJZENvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZENvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIjtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdDI7XG59KShTdGFya25ldElkQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiIC8qIFNOX0dPRVJMSSAqLzpcbiAgICAgIHJldHVybiBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIiAvKiBURVNUTkVUICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvdmlkZXIvc3RhcmtuZXRJZC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgaGV4RG9tYWluID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgIGFkZHJlc3NcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgZGVjaW1hbERvbWFpbiA9IGhleERvbWFpbi5yZXN1bHQubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgIGNvbnN0IHN0cmluZ0RvbWFpbiA9IHVzZURlY29kZWQoZGVjaW1hbERvbWFpbik7XG4gICAgaWYgKCFzdHJpbmdEb21haW4pIHtcbiAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0RvbWFpbjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlID09PSBcIlN0YXJrbmFtZSBub3QgZm91bmRcIikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHN0YXJrIG5hbWVcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRkcmVzc0RhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgIGVudHJ5cG9pbnQ6IFwiZG9tYWluX3RvX2FkZHJlc3NcIixcbiAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgZG9tYWluOiBbdXNlRW5jb2RlZChuYW1lLnJlcGxhY2UoXCIuc3RhcmtcIiwgXCJcIikpLnRvU3RyaW5nKDEwKV1cbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3NEYXRhLnJlc3VsdFswXTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFkZHJlc3MgZnJvbSBzdGFyayBuYW1lXCIpO1xuICB9XG59XG5cbi8vIHNyYy9wcm92aWRlci91dGlscy50c1xudmFyIHZhbGlkQmxvY2tUYWdzID0gT2JqZWN0LnZhbHVlcyhCbG9ja1RhZyk7XG52YXIgQmxvY2sgPSBjbGFzcyB7XG4gIGhhc2ggPSBudWxsO1xuICBudW1iZXIgPSBudWxsO1xuICB0YWcgPSBudWxsO1xuICBzZXRJZGVudGlmaWVyKF9faWRlbnRpZmllcikge1xuICAgIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcInN0cmluZ1wiICYmIGlzSGV4KF9faWRlbnRpZmllcikpIHtcbiAgICAgIHRoaXMuaGFzaCA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHRoaXMuaGFzaCA9IHRvSGV4KF9faWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLm51bWJlciA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIgJiYgdmFsaWRCbG9ja1RhZ3MuaW5jbHVkZXMoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy50YWcgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnID0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLztcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgZ2V0IHF1ZXJ5SWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLm51bWJlcn1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYGJsb2NrSGFzaD0ke3RoaXMuaGFzaH1gO1xuICAgIH1cbiAgICByZXR1cm4gYGJsb2NrTnVtYmVyPSR7dGhpcy50YWd9YDtcbiAgfVxuICAvLyBUT0RPOiBmaXggYW55XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfbnVtYmVyOiB0aGlzLm51bWJlciB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19oYXNoOiB0aGlzLmhhc2ggfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnO1xuICB9XG4gIHNldCBpZGVudGlmaWVyKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICB2YWx1ZU9mID0gKCkgPT4gdGhpcy5udW1iZXI7XG4gIHRvU3RyaW5nID0gKCkgPT4gdGhpcy5oYXNoO1xuICBnZXQgc2VxdWVuY2VySWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNoICE9PSBudWxsID8geyBibG9ja0hhc2g6IHRoaXMuaGFzaCB9IDogeyBibG9ja051bWJlcjogdGhpcy5udW1iZXIgPz8gdGhpcy50YWcgfTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3JwYy50c1xudmFyIGdldERlZmF1bHROb2RlVXJsID0gKG5ldHdvcmtOYW1lLCBtdXRlID0gZmFsc2UsIHZlcnNpb24gPSBSUENfREVGQVVMVF9WRVJTSU9OKSA9PiB7XG4gIGlmICghbXV0ZSlcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IHB1YmxpYyBub2RlIHVybCwgcGxlYXNlIHByb3ZpZGUgbm9kZVVybCBpbiBwcm92aWRlciBvcHRpb25zIVwiKTtcbiAgY29uc3Qgbm9kZXMgPSBSUENfTk9ERVNbbmV0d29ya05hbWUgPz8gXCJTTl9HT0VSTElcIiAvKiBTTl9HT0VSTEkgKi9dO1xuICBjb25zdCByYW5kSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKTtcbiAgcmV0dXJuIGAke25vZGVzW3JhbmRJZHhdfSR7dmVyc2lvbn1gO1xufTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNQcm92aWRlciA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmVzcG9uc2VQYXJzZXIgPSBuZXcgUlBDUmVzcG9uc2VQYXJzZXIoKTtcbiAgcmV0cmllcztcbiAgYmxvY2tJZGVudGlmaWVyO1xuICBjaGFpbklkO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIGNvbnN0IHsgbm9kZVVybCwgcmV0cmllcywgaGVhZGVycywgYmxvY2tJZGVudGlmaWVyLCBjaGFpbklkLCBycGNWZXJzaW9uIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKFxuICAgICAgICBub2RlVXJsLFxuICAgICAgICBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCxcbiAgICAgICAgcnBjVmVyc2lvblxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQsIHJwY1ZlcnNpb24pO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzIHx8IGRlZmF1bHRPcHRpb25zLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9ucy5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBibG9ja0lkZW50aWZpZXIgfHwgZGVmYXVsdE9wdGlvbnMuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMpfVxuICR7Y29kZX06ICR7bWVzc2FnZX06ICR7c3RyaW5naWZ5MihkYXRhKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgdGhyb3cgb3RoZXJFcnJvcjtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgIHRocm93IEVycm9yKG90aGVyRXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoRW5kcG9pbnQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaChtZXRob2QsIHBhcmFtcyk7XG4gICAgICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGF3YWl0IHJhd1Jlc3VsdC5qc29uKCk7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yPy5yZXNwb25zZT8uZGF0YSwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgdGhpcy5jaGFpbklkID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jaGFpbklkXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYWluSWQ7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgU3RhcmtuZXQgSlNPTi1SUEMgc3BlY2lmaWNhdGlvbiBiZWluZyB1c2VkXG4gICAqL1xuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3BlY1ZlcnNpb25cIik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldE5vbmNlXCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZ2V0QmxvY2tXaXRoVHhIYXNoZXMgb3IgZ2V0QmxvY2tXaXRoVHhzICh3aWxsIGJlIHJlbW92ZWQgb24gc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICovXG4gIGdldEJsb2NrSGFzaEFuZE51bWJlciA9IHRoaXMuZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZDtcbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja0hhc2hBbmROdW1iZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrTnVtYmVyXCIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeEhhc2hlc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RhdGVVcGRhdGVcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja1N0YXRlVXBkYXRlKCk7XG4gICAqL1xuICBnZXRTdGF0ZVVwZGF0ZSA9IHRoaXMuZ2V0QmxvY2tTdGF0ZVVwZGF0ZTtcbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlQmxvY2tUcmFuc2FjdGlvbnNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhlY3V0aW9uIHRyYWNlcyBvZiBhbGwgdHJhbnNhY3Rpb25zIGluY2x1ZGVkIGluIHRoZSBnaXZlbiBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKClcbiAgICovXG4gIHRyYWNlQmxvY2tUcmFuc2FjdGlvbnMgPSB0aGlzLmdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzO1xuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudFwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gYSBibG9jayBnaXZlbiBhIGJsb2NrIGlkXG4gICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KClcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25Db3VudCA9IHRoaXMuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50O1xuICAvKipcbiAgICogUmV0dXJuIHRyYW5zYWN0aW9ucyBmcm9tIHBlbmRpbmcgYmxvY2tcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCB1c2UgZ2V0QmxvY2soQmxvY2tUYWcucGVuZGluZyk7ICh3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCBtaW5vciB2ZXJzaW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucygpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gYXdhaXQgdGhpcy5nZXRCbG9jayhcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgoaXQpID0+IHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2goaXQpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXRUcmFuc2FjdGlvbkJ5SGFzaCBvciBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4ICh3aWxsIGJlIHJlbW92ZWQgb24gc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0VHJhbnNhY3Rpb25UcmFjZSgpO1xuICAgKiBGb3IgYSBnaXZlbiBleGVjdXRlZCB0cmFuc2FjdGlvbiwgcmV0dXJuIHRoZSB0cmFjZSBvZiBpdHMgZXhlY3V0aW9uLCBpbmNsdWRpbmcgaW50ZXJuYWwgY2FsbHNcbiAgICovXG4gIHRyYWNlVHJhbnNhY3Rpb24gPSB0aGlzLmdldFRyYW5zYWN0aW9uVHJhY2U7XG4gIC8qKlxuICAgKiBORVc6IEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gc2ltdWxhdGVUcmFuc2FjdGlvbigpO1xuICAgKi9cbiAgZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbiA9IHRoaXMuc2ltdWxhdGVUcmFuc2FjdGlvbjtcbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgIHNraXBWYWxpZGF0ZSA9IGZhbHNlLFxuICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gIH0pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY19leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY19leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX0ZFRV9DSEFSR0UpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zaW11bGF0ZVRyYW5zYWN0aW9uc1wiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIHRyYW5zYWN0aW9uczogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0KSksXG4gICAgICBzaW11bGF0aW9uX2ZsYWdzOiBzaW11bGF0aW9uRmxhZ3NcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gNWUzO1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uU3RhdHVzLlJFSkVDVEVEXG4gICAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHRvIHByZXNlcnZlIHRoZSBsb25nLXN0YW5kaW5nIGJlaGF2aW9yIG9mIFwicmV2ZXJ0ZWRcIiBub3QgYmVpbmcgdHJlYXRlZCBhcyBhbiBlcnJvciBieSBkZWZhdWx0XG4gICAgICAvLyBzaG91bGQgZGVjaWRlIHdoaWNoIGJlaGF2aW9yIHRvIGtlZXAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gUlBDLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRCxcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKF9jb250cmFjdEFkZHJlc3MsIF9ibG9ja0lkZW50aWZpZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSUEMgZG9lcyBub3QgaW1wbGVtZW50IGdldENvZGUgZnVuY3Rpb25cIik7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBjb21waWxlciA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGlmIChza2lwVmFsaWRhdGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImdldEVzdGltYXRlRmVlQnVsayBSUEMgZG9lcyBub3Qgc3VwcG9ydCBza2lwVmFsaWRhdGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiBcIjB4MVwiLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHR5cGU6IHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChkZXRhaWxzLnZlcnNpb24gfHwgMCksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2FsbFwiLCB7XG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNhbGwuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShjYWxsLmVudHJ5cG9pbnQpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY2FsbC5jYWxsZGF0YSlcbiAgICAgIH0sXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ2FsbENvbnRyYWN0UmVzcG9uc2UocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB0b0hleChmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGFzeW5jIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFya25ldElkIEVuZHBvaW50IChnZXQgbmFtZSBmcm9tIGFkZHJlc3MpXG4gICAqL1xuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJrbmV0SWQgRW5kcG9pbnQgKGdldCBhZGRyZXNzIGZyb20gbmFtZSlcbiAgICovXG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUodGhpcywgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgfTtcbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIC8vIERpZmYgYmV0d2VlbiBzZXF1ZW5jZXIgYW5kIHJwYyBpbnZva2UgdHlwZVxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb21waWxlZF9jbGFzc19oYXNoXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3NlcXVlbmNlci50c1xuaW1wb3J0IHVybGpvaW4yIGZyb20gXCJ1cmwtam9pblwiO1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvaW5kZXgudHNcbnZhciBSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9zZXF1ZW5jZXIudHNcbnZhciBTZXF1ZW5jZXJBUElSZXNwb25zZVBhcnNlciA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2VQYXJzZXIge1xuICBwYXJzZUdldEJsb2NrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIG5ld19yb290OiByZXMuc3RhdGVfcm9vdCxcbiAgICAgIHBhcmVudF9oYXNoOiByZXMucGFyZW50X2Jsb2NrX2hhc2gsXG4gICAgICB0cmFuc2FjdGlvbnM6IE9iamVjdC52YWx1ZXMocmVzLnRyYW5zYWN0aW9ucykubWFwKCh2YWx1ZSkgPT4gXCJ0cmFuc2FjdGlvbl9oYXNoXCIgaW4gdmFsdWUgJiYgdmFsdWUudHJhbnNhY3Rpb25faGFzaCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovICYmIHJlcy5maW5hbGl0eV9zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBjYWxsZGF0YTogXCJjYWxsZGF0YVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5jYWxsZGF0YSA6IFtdLFxuICAgICAgY29udHJhY3RfY2xhc3M6IFwiY29udHJhY3RfY2xhc3NcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uY29udHJhY3RfY2xhc3MgOiB2b2lkIDAsXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogXCJlbnRyeV9wb2ludF9zZWxlY3RvclwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5lbnRyeV9wb2ludF9zZWxlY3RvciA6IHZvaWQgMCxcbiAgICAgIG1heF9mZWU6IFwibWF4X2ZlZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5tYXhfZmVlIDogdm9pZCAwLFxuICAgICAgbm9uY2U6IHJlcy50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBcInNlbmRlcl9hZGRyZXNzXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnNlbmRlcl9hZGRyZXNzIDogdm9pZCAwLFxuICAgICAgc2lnbmF0dXJlOiBcInNpZ25hdHVyZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5zaWduYXR1cmUgOiB2b2lkIDAsXG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiBcInRyYW5zYWN0aW9uX2hhc2hcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24udHJhbnNhY3Rpb25faGFzaCA6IHZvaWQgMCxcbiAgICAgIHZlcnNpb246IFwidmVyc2lvblwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi52ZXJzaW9uIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVjZWlwdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBtZXNzYWdlc19zZW50OiByZXMubDJfdG9fbDFfbWVzc2FnZXMsXG4gICAgICAuLi5cInJldmVydF9lcnJvclwiIGluIHJlcyAmJiB7IHJldmVydF9yZWFzb246IHJlcy5yZXZlcnRfZXJyb3IgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGlmIChcIm92ZXJhbGxfZmVlXCIgaW4gcmVzKSB7XG4gICAgICBsZXQgZ2FzSW5mbyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHJlcy5nYXNfdXNhZ2UpLFxuICAgICAgICAgIGdhc19wcmljZTogdG9CaWdJbnQocmVzLmdhc19wcmljZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlcy5vdmVyYWxsX2ZlZSksXG4gICAgICAgIC4uLmdhc0luZm9cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQocmVzLmFtb3VudClcbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKFwib3ZlcmFsbF9mZWVcIiBpbiBpdGVtKSB7XG4gICAgICAgIGxldCBnYXNJbmZvID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQoaXRlbS5nYXNfdXNhZ2UpLFxuICAgICAgICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChpdGVtLmdhc19wcmljZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChpdGVtLm92ZXJhbGxfZmVlKSxcbiAgICAgICAgICAuLi5nYXNJbmZvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQoaXRlbS5hbW91bnQpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IFwib3ZlcmFsbF9mZWVcIiBpbiByZXMuZmVlX2VzdGltYXRpb24gPyByZXMuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUgOiByZXMuZmVlX2VzdGltYXRpb24uYW1vdW50O1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRyYW5zYWN0aW9uX3RyYWNlOiByZXMudHJhY2UsXG4gICAgICAgIGZlZV9lc3RpbWF0aW9uOiByZXMuZmVlX2VzdGltYXRpb24sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KHN1Z2dlc3RlZE1heEZlZSkpXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlcy5yZXN1bHRcbiAgICB9O1xuICB9XG4gIHBhcnNlSW52b2tlRnVuY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2hcbiAgICB9O1xuICB9XG4gIHBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiByZXMuYWRkcmVzc1xuICAgIH07XG4gIH1cbiAgcGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjbGFzc19oYXNoOiByZXMuY2xhc3NfaGFzaFxuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IG5vbmNlcyA9IE9iamVjdC5lbnRyaWVzKHJlcy5zdGF0ZV9kaWZmLm5vbmNlcykubWFwKChbY29udHJhY3RfYWRkcmVzcywgbm9uY2VdKSA9PiAoe1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIG5vbmNlXG4gICAgfSkpO1xuICAgIGNvbnN0IHN0b3JhZ2VfZGlmZnMgPSBPYmplY3QuZW50cmllcyhyZXMuc3RhdGVfZGlmZi5zdG9yYWdlX2RpZmZzKS5tYXAoXG4gICAgICAoW2FkZHJlc3MsIHN0b3JhZ2VfZW50cmllc10pID0+ICh7IGFkZHJlc3MsIHN0b3JhZ2VfZW50cmllcyB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIHN0YXRlX2RpZmY6IHtcbiAgICAgICAgLi4ucmVzLnN0YXRlX2RpZmYsXG4gICAgICAgIHN0b3JhZ2VfZGlmZnMsXG4gICAgICAgIG5vbmNlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBpc1NpZXJyYShyZXMpID8gcmVzIDogcGFyc2VDb250cmFjdChyZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGFiaTogdHlwZW9mIHJlc3BvbnNlLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzcG9uc2UuYWJpKSA6IHJlc3BvbnNlLmFiaVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmltcG9ydCB1cmxqb2luIGZyb20gXCJ1cmwtam9pblwiO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogdXJsam9pbihiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnlPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBPYmplY3QuZW50cmllcyhvYmopLmV2ZXJ5KChbaywgdl0pID0+IGsgPT09IFwiYmxvY2tJZGVudGlmaWVyXCIgJiYgdiA9PT0gbnVsbCk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMyID0ge1xuICBuZXR3b3JrOiBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqLyxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovXG59O1xudmFyIFNlcXVlbmNlclByb3ZpZGVyID0gY2xhc3Mge1xuICBiYXNlVXJsO1xuICBmZWVkZXJHYXRld2F5VXJsO1xuICBnYXRld2F5VXJsO1xuICBoZWFkZXJzO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIHJlc3BvbnNlUGFyc2VyID0gbmV3IFNlcXVlbmNlckFQSVJlc3BvbnNlUGFyc2VyKCk7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyID0gZGVmYXVsdE9wdGlvbnMyKSB7XG4gICAgaWYgKFwibmV0d29ya1wiIGluIG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBTZXF1ZW5jZXJQcm92aWRlci5nZXROZXR3b3JrRnJvbU5hbWUob3B0aW9uc09yUHJvdmlkZXIubmV0d29yayk7XG4gICAgICB0aGlzLmZlZWRlckdhdGV3YXlVcmwgPSBidWlsZFVybCh0aGlzLmJhc2VVcmwsIFwiZmVlZGVyX2dhdGV3YXlcIik7XG4gICAgICB0aGlzLmdhdGV3YXlVcmwgPSBidWlsZFVybCh0aGlzLmJhc2VVcmwsIFwiZ2F0ZXdheVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iYXNlVXJsID0gb3B0aW9uc09yUHJvdmlkZXIuYmFzZVVybDtcbiAgICAgIHRoaXMuZmVlZGVyR2F0ZXdheVVybCA9IGJ1aWxkVXJsKFxuICAgICAgICB0aGlzLmJhc2VVcmwsXG4gICAgICAgIFwiZmVlZGVyX2dhdGV3YXlcIixcbiAgICAgICAgb3B0aW9uc09yUHJvdmlkZXIuZmVlZGVyR2F0ZXdheVVybFxuICAgICAgKTtcbiAgICAgIHRoaXMuZ2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJnYXRld2F5XCIsIG9wdGlvbnNPclByb3ZpZGVyLmdhdGV3YXlVcmwpO1xuICAgIH1cbiAgICB0aGlzLmNoYWluSWQgPSBvcHRpb25zT3JQcm92aWRlcj8uY2hhaW5JZCA/PyBTZXF1ZW5jZXJQcm92aWRlci5nZXRDaGFpbklkRnJvbUJhc2VVcmwodGhpcy5iYXNlVXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zT3JQcm92aWRlci5oZWFkZXJzO1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gb3B0aW9uc09yUHJvdmlkZXI/LmJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9uczIuYmxvY2tJZGVudGlmaWVyO1xuICB9XG4gIHN0YXRpYyBnZXROZXR3b3JrRnJvbU5hbWUobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcIlNOX01BSU5cIiAvKiBTTl9NQUlOICovOlxuICAgICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgICByZXR1cm4gXCJodHRwczovL2FscGhhLW1haW5uZXQuc3RhcmtuZXQuaW9cIiAvKiBTTl9NQUlOICovO1xuICAgICAgY2FzZSBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqLzpcbiAgICAgIGNhc2UgXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiIC8qIFNOX0dPRVJMSSAqLzpcbiAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9hbHBoYTQuc3RhcmtuZXQuaW9cIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZWN0IGJhc2UgdXJsIGZyb20gTmV0d29ya05hbWVcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRDaGFpbklkRnJvbUJhc2VVcmwoYmFzZVVybCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgaWYgKHVybC5ob3N0LmluY2x1ZGVzKFwibWFpbm5ldC5zdGFya25ldC5pb1wiKSkge1xuICAgICAgICByZXR1cm4gXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLztcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIGJhc2VVcmw6ICR7YmFzZVVybH1gKTtcbiAgICAgIHJldHVybiBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovO1xuICAgIH1cbiAgfVxuICBnZXRGZXRjaFVybChlbmRwb2ludCkge1xuICAgIGNvbnN0IGdhdGV3YXlVcmxFbmRwb2ludHMgPSBbXCJhZGRfdHJhbnNhY3Rpb25cIl07XG4gICAgcmV0dXJuIGdhdGV3YXlVcmxFbmRwb2ludHMuaW5jbHVkZXMoZW5kcG9pbnQpID8gdGhpcy5nYXRld2F5VXJsIDogdGhpcy5mZWVkZXJHYXRld2F5VXJsO1xuICB9XG4gIGdldEZldGNoTWV0aG9kKGVuZHBvaW50KSB7XG4gICAgY29uc3QgcG9zdE1ldGhvZEVuZHBvaW50cyA9IFtcbiAgICAgIFwiYWRkX3RyYW5zYWN0aW9uXCIsXG4gICAgICBcImNhbGxfY29udHJhY3RcIixcbiAgICAgIFwiZXN0aW1hdGVfZmVlXCIsXG4gICAgICBcImVzdGltYXRlX21lc3NhZ2VfZmVlXCIsXG4gICAgICBcImVzdGltYXRlX2ZlZV9idWxrXCIsXG4gICAgICBcInNpbXVsYXRlX3RyYW5zYWN0aW9uXCJcbiAgICBdO1xuICAgIHJldHVybiBwb3N0TWV0aG9kRW5kcG9pbnRzLmluY2x1ZGVzKGVuZHBvaW50KSA/IFwiUE9TVFwiIDogXCJHRVRcIjtcbiAgfVxuICBnZXRRdWVyeVN0cmluZyhxdWVyeSkge1xuICAgIGlmIChpc0VtcHR5UXVlcnlPYmplY3QocXVlcnkpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3QuZW50cmllcyhxdWVyeSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBuZXcgQmxvY2sodmFsdWUpO1xuICAgICAgICByZXR1cm4gYCR7YmxvY2sucXVlcnlJZGVudGlmaWVyfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgfSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIGA/JHtxdWVyeVN0cmluZ31gO1xuICB9XG4gIGdldEhlYWRlcnMobWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi50aGlzLmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhlYWRlcnM7XG4gIH1cbiAgLy8gdHlwZXNhZmUgZmV0Y2hcbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChlbmRwb2ludCwgLi4uW3F1ZXJ5LCByZXF1ZXN0XSkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEZldGNoVXJsKGVuZHBvaW50KTtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLmdldEZldGNoTWV0aG9kKGVuZHBvaW50KTtcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRoaXMuZ2V0UXVlcnlTdHJpbmcocXVlcnkpO1xuICAgIGNvbnN0IHVybCA9IHVybGpvaW4yKGJhc2VVcmwsIGVuZHBvaW50LCBxdWVyeVN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBib2R5OiByZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZmV0Y2goZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwgPSBidWlsZFVybCh0aGlzLmJhc2VVcmwsIFwiXCIsIGVuZHBvaW50KTtcbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zPy5tZXRob2QgPz8gXCJHRVRcIjtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKG1ldGhvZCk7XG4gICAgY29uc3QgYm9keSA9IHN0cmluZ2lmeTIob3B0aW9ucz8uYm9keSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hQb255ZmlsbF9kZWZhdWx0KHVybCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGV4dFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlQm9keSA9IHBhcnNlMih0ZXh0UmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEdhdGV3YXlFcnJvcihyZXNwb25zZUJvZHkubWVzc2FnZSwgcmVzcG9uc2VCb2R5LmNvZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VDaG9pY2UgPSBvcHRpb25zPy5wYXJzZUFsd2F5c0FzQmlnSW50ID8gcGFyc2VBbHdheXNBc0JpZyA6IHBhcnNlMjtcbiAgICAgIHJldHVybiBwYXJzZUNob2ljZSh0ZXh0UmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCAke21ldGhvZH0gZnJvbSBlbmRwb2ludCBcXGAke3VybH1cXGA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jaGFpbklkKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoeyBjb250cmFjdEFkZHJlc3MsIGVudHJ5cG9pbnQ6IGVudHJ5UG9pbnRTZWxlY3RvciwgY2FsbGRhdGEgPSBbXSB9LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXG4gICAgICBcImNhbGxfY29udHJhY3RcIixcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyIH0sXG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gLSBkZXRlcm1pbmUgYmVzdCBjaG9pY2Ugb25jZSBib3RoIGFyZSBmdWxseSBzdXBwb3J0ZWQgaW4gZGV2bmV0XG4gICAgICAgIC8vIHNpZ25hdHVyZTogW10sXG4gICAgICAgIC8vIHNlbmRlcl9hZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yRnJvbU5hbWUoZW50cnlQb2ludFNlbGVjdG9yKSxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoY2FsbGRhdGEpXG4gICAgICB9XG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2Jsb2NrXCIsIHsgYmxvY2tJZGVudGlmaWVyIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X25vbmNlXCIsIHsgY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvQmlnSW50KGtleSkudG9TdHJpbmcoMTApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfc3RvcmFnZV9hdFwiLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIGNvbnN0IHR4SGFzaEhleCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF90cmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMocmVzdWx0KS5sZW5ndGggPT09IDEpXG4gICAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IocmVzdWx0LnN0YXR1cyk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uX3JlY2VpcHRcIiwgeyB0cmFuc2FjdGlvbkhhc2g6IHR4SGFzaEhleCB9KS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldFRyYW5zYWN0aW9uUmVjZWlwdFJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2Z1bGxfY29udHJhY3RcIiwgeyBibG9ja0lkZW50aWZpZXIsIGNvbnRyYWN0QWRkcmVzcyB9KS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY2xhc3NfaGFzaF9hdFwiLCB7IGJsb2NrSWRlbnRpZmllciwgY29udHJhY3RBZGRyZXNzIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NsYXNzX2J5X2hhc2hcIiwgeyBjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciB9KS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29tcGlsZWRDbGFzc0J5Q2xhc3NIYXNoKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NvbXBpbGVkX2NsYXNzX2J5X2NsYXNzX2hhc2hcIiwgeyBjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyBnZXRDb250cmFjdFZlcnNpb24oY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIGNvbXBpbGVyID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgY29udHJhY3RDbGFzcztcbiAgICBpZiAoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzSGFzaCkge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImdldENvbnRyYWN0VmVyc2lvbiByZXF1aXJlcyBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLFxuICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEgPz8gW10pLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgdmVyc2lvbjogXCIweDFcIlxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUludm9rZUZ1bmN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogYWRkcmVzc1NhbHQgPz8gcmFuZG9tQWRkcmVzcygpLFxuICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSA/PyBbXSksXG4gICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICB2ZXJzaW9uOiB0b0hleChkZXRhaWxzLnZlcnNpb24gfHwgMCksXG4gICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZ25hdHVyZSlcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VEZXBsb3lDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QoeyBzZW5kZXJBZGRyZXNzLCBjb250cmFjdCwgc2lnbmF0dXJlLCBjb21waWxlZENsYXNzSGFzaCB9LCBkZXRhaWxzKSB7XG4gICAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiBjb250cmFjdCxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgodHJhbnNhY3Rpb25WZXJzaW9uKVxuICAgICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRGVjbGFyZUNvbnRyYWN0UmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBjb250cmFjdF9jbGFzczogY29udHJhY3QsXG4gICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZ25hdHVyZSksXG4gICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgIHZlcnNpb246IHRvSGV4KHRyYW5zYWN0aW9uVmVyc2lvbl8yKVxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgfSxcbiAgICAgIFwiZmVlXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJlc3RpbWF0ZV9mZWVcIiwgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9LCB0cmFuc2FjdGlvbikudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSwgdHJhbnNhY3Rpb24pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSwgdHJhbnNhY3Rpb24pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSB9KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwiZXN0aW1hdGVfZmVlX2J1bGtcIixcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSxcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgICkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENvZGUoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29kZVwiLCB7IGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyIH0pO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGxldCBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gNWUzO1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgXCJSRUpFQ1RFRFwiIC8qIFJFSkVDVEVEICovLFxuICAgICAgXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8sXG4gICAgICBcIlJFVkVSVEVEXCIgLyogUkVWRVJURUQgKi9cbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIFwiU1VDQ0VFREVEXCIgLyogU1VDQ0VFREVEICovLFxuICAgICAgXCJBQ0NFUFRFRF9PTl9MMVwiIC8qIEFDQ0VQVEVEX09OX0wxICovLFxuICAgICAgXCJBQ0NFUFRFRF9PTl9MMlwiIC8qIEFDQ0VQVEVEX09OX0wyICovXG4gICAgXTtcbiAgICB3aGlsZSAoIWNvbXBsZXRlZCkge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHJlcyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHhIYXNoKTtcbiAgICAgIGlmIChcIk5PVF9SRUNFSVZFRFwiIC8qIE5PVF9SRUNFSVZFRCAqLyA9PT0gcmVzLmZpbmFsaXR5X3N0YXR1cyAmJiByZXRyaWVzIDwgMykge1xuICAgICAgICByZXRyaWVzICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMocmVzLmZpbmFsaXR5X3N0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhyZXMuZXhlY3V0aW9uX3N0YXR1cykpIHtcbiAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMocmVzLmZpbmFsaXR5X3N0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMocmVzLmV4ZWN1dGlvbl9zdGF0dXMpKSB7XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBpZiAocmVzLnR4X2ZhaWx1cmVfcmVhc29uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGAke3Jlcy50eF9zdGF0dXN9OiAke3Jlcy50eF9mYWlsdXJlX3JlYXNvbi5jb2RlfVxuJHtyZXMudHhfZmFpbHVyZV9yZWFzb24uZXJyb3JfbWVzc2FnZX1gO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcy50eF9yZXZlcnRfcmVhc29uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGAke3Jlcy50eF9zdGF0dXN9OiAke3Jlcy50eF9yZXZlcnRfcmVhc29ufWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IHJlcy50eF9zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHR4SGFzaCBCaWdOdW1iZXJpc2hcbiAgICogQHJldHVybnMgR2V0VHJhbnNhY3Rpb25TdGF0dXNSZXNwb25zZSAtIHRoZSB0cmFuc2FjdGlvbiBzdGF0dXMgb2JqZWN0XG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fc3RhdHVzXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNtYXJ0IGNvbnRyYWN0IGFkZHJlc3Mgb24gdGhlIGdvZXJsaSB0ZXN0bmV0LlxuICAgKiBAcmV0dXJucyBHZXRDb250cmFjdEFkZHJlc3Nlc1Jlc3BvbnNlIC0gc3RhcmtuZXQgc21hcnQgY29udHJhY3QgYWRkcmVzc2VzXG4gICAqL1xuICBhc3luYyBnZXRDb250cmFjdEFkZHJlc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NvbnRyYWN0X2FkZHJlc3Nlc1wiKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhbnNhY3Rpb24gdHJhY2UgZnJvbSBhIHR4IGlkLlxuICAgKiBAcGFyYW0gdHhIYXNoIEJpZ051bWJlcmlzaFxuICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvblRyYWNlUmVzcG9uc2UgLSB0aGUgdHJhbnNhY3Rpb24gdHJhY2VcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uX3RyYWNlXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVNZXNzYWdlRmVlKHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHZhbGlkQ2FsbEwxSGFuZGxlciA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogZ2V0RGVjaW1hbFN0cmluZyhmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogZ2V0SGV4U3RyaW5nKHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfbWVzc2FnZV9mZWVcIiwgeyBibG9ja0lkZW50aWZpZXIgfSwgdmFsaWRDYWxsTDFIYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogU2ltdWxhdGUgdHJhbnNhY3Rpb24gdXNpbmcgU2VxdWVuY2VyIHByb3ZpZGVyXG4gICAqIFdBUk5JTkchOiBTZXF1ZW5jZXIgd2lsbCBwcm9jZXNzIG9ubHkgZmlyc3QgZWxlbWVudCBmcm9tIGludm9jYXRpb25zIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBcnJheSBvZiBpbnZvY2F0aW9ucywgYnV0IG9ubHkgZmlyc3QgaW52b2NhdGlvbiB3aWxsIGJlIHByb2Nlc3NlZFxuICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIGJsb2NrIGlkZW50aWZpZXIsIGRlZmF1bHQgJ2xhdGVzdCdcbiAgICogQHBhcmFtIHNraXBWYWxpZGF0ZSBTa2lwIEFjY291bnQgX192YWxpZGF0ZV9fIG1ldGhvZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgIHNraXBWYWxpZGF0ZSA9IGZhbHNlLFxuICAgIHNraXBFeGVjdXRlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChpbnZvY2F0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTZXF1ZW5jZXIgc2ltdWxhdGUgcHJvY2VzcyBvbmx5IGZpcnN0IGVsZW1lbnQgZnJvbSBpbnZvY2F0aW9ucyBsaXN0XCIpO1xuICAgIH1cbiAgICBpZiAoc2tpcEV4ZWN1dGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlNlcXVlbmNlciBjYW4ndCBza2lwIGFjY291bnQgX19leGVjdXRlX19cIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb25zWzBdKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFxuICAgICAgXCJzaW11bGF0ZV90cmFuc2FjdGlvblwiLFxuICAgICAge1xuICAgICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICAgIHNraXBWYWxpZGF0ZTogc2tpcFZhbGlkYXRlID8/IGZhbHNlXG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBhcmdzID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuc2VxdWVuY2VySWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3N0YXRlX3VwZGF0ZVwiLCB7IC4uLmFyZ3MgfSkudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICAvLyBjb25zaWRlciBhZGRpbmcgYW4gb3B0aW9uYWwgdHJhY2UgcmV0cmlldmFsIHBhcmFtZXRlciB0byB0aGUgZ2V0QmxvY2sgbWV0aG9kXG4gIGFzeW5jIGdldEJsb2NrVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYXJncyA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLnNlcXVlbmNlcklkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9ibG9ja190cmFjZXNcIiwgeyAuLi5hcmdzIH0pO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHRoaXMsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIC8qKlxuICAgKiBCdWlsZCBTaW5nbGUgQWNjb3VudFRyYW5zYWN0aW9uIGZyb20gU2luZ2xlIEFjY291bnRJbnZvY2F0aW9uXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9uIEFjY291bnRJbnZvY2F0aW9uSXRlbVxuICAgKiBAcGFyYW0gdmVyc2lvblR5cGUgJ2ZlZScgfCAndHJhbnNhY3Rpb24nIC0gdXNlZCB0byBkZXRlcm1pbmUgZGVmYXVsdCB2ZXJzaW9uc1xuICAgKiBAcmV0dXJucyBBY2NvdW50VHJhbnNhY3Rpb25JdGVtXG4gICAqL1xuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKVxuICAgIH07XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShpbnZvY2F0aW9uLmNhbGxkYXRhID8/IFtdKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAvLyBmZWUgZnJvbSBnZXREZWNsYXJlRXN0aW1hdGVGZWUgdXNlIHQudi4gaW5zdGVhZCBvZiBmZWV0LnYuXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogaW52b2NhdGlvbi5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MiksXG4gICAgICAgIC8vIGZlZSBvbiBnZXREZWNsYXJlRXN0aW1hdGVGZWUgdXNlIHQudi4gaW5zdGVhZCBvZiBmZWV0LnYuXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShpbnZvY2F0aW9uLmNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICBjbGFzc19oYXNoOiB0b0hleChpbnZvY2F0aW9uLmNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoaW52b2NhdGlvbi5hZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiU2VxdWVuY2VyIGJ1aWxkVHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5rbm93biBUcmFuc2FjdGlvblR5cGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9kZWZhdWx0LnRzXG52YXIgUHJvdmlkZXIgPSBjbGFzcyB7XG4gIHByb3ZpZGVyO1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlck9yT3B0aW9ucykge1xuICAgIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJPck9wdGlvbnMucHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFJwY1Byb3ZpZGVyIHx8IHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgU2VxdWVuY2VyUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlck9yT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwicnBjXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMucnBjKTtcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwic2VxdWVuY2VyXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgU2VxdWVuY2VyUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMuc2VxdWVuY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBScGNQcm92aWRlcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIGludm9jYXRpb25XaXRoVHhUeXBlLFxuICAgICAgaW52b2NhdGlvbkRldGFpbHMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QocmVxdWVzdCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2FsbENvbnRyYWN0KHJlcXVlc3QsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRlcGxveUFjY291bnRDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5kZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBnZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHRoaXMsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBieXRlQXJyYXlGcm9tU3RyaW5nOiAoKSA9PiBieXRlQXJyYXlGcm9tU3RyaW5nLFxuICBlbmNvZGVEYXRhOiAoKSA9PiBlbmNvZGVEYXRhLFxuICBlbmNvZGVUeXBlOiAoKSA9PiBlbmNvZGVUeXBlLFxuICBlbmNvZGVWYWx1ZTogKCkgPT4gZW5jb2RlVmFsdWUsXG4gIGdldERlcGVuZGVuY2llczogKCkgPT4gZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXRNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TWVzc2FnZUhhc2gsXG4gIGdldFN0cnVjdEhhc2g6ICgpID0+IGdldFN0cnVjdEhhc2gsXG4gIGdldFR5cGVIYXNoOiAoKSA9PiBnZXRUeXBlSGFzaCxcbiAgaXNNZXJrbGVUcmVlVHlwZTogKCkgPT4gaXNNZXJrbGVUcmVlVHlwZSxcbiAgcHJlcGFyZVNlbGVjdG9yOiAoKSA9PiBwcmVwYXJlU2VsZWN0b3Jcbn0pO1xuXG4vLyBzcmMvdXRpbHMvbWVya2xlLnRzXG52YXIgbWVya2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1lcmtsZV9leHBvcnRzLCB7XG4gIE1lcmtsZVRyZWU6ICgpID0+IE1lcmtsZVRyZWUsXG4gIHByb29mTWVya2xlUGF0aDogKCkgPT4gcHJvb2ZNZXJrbGVQYXRoXG59KTtcbnZhciBNZXJrbGVUcmVlID0gY2xhc3Mge1xuICBsZWF2ZXM7XG4gIGJyYW5jaGVzID0gW107XG4gIHJvb3Q7XG4gIGhhc2hNZXRob2Q7XG4gIGNvbnN0cnVjdG9yKGxlYWZIYXNoZXMsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgdGhpcy5oYXNoTWV0aG9kID0gaGFzaE1ldGhvZDtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIE1lcmtsZSB0cmVlXG4gICAqIEBwYXJhbSBsZWF2ZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmc7IE1lcmtsZSB0cmVlIHJvb3RcbiAgICovXG4gIGJ1aWxkKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbGVhdmVzWzBdO1xuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCAhPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnB1c2gobGVhdmVzKTtcbiAgICB9XG4gICAgY29uc3QgbmV3TGVhdmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChpICsgMSA9PT0gbGVhdmVzLmxlbmd0aCkge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKE1lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIGxlYXZlc1tpICsgMV0sIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWlsZChuZXdMZWF2ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgaGFzaCBmcm9tIG9yZGVyZWQgYSBhbmQgYiwgUGVkZXJzZW4gaGFzaCBkZWZhdWx0XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZ1xuICAgKi9cbiAgc3RhdGljIGhhc2goYSwgYiwgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbQmlnSW50KGEpLCBCaWdJbnQoYildLnNvcnQoKHgsIHkpID0+IHggPj0geSA/IDEgOiAtMSk7XG4gICAgcmV0dXJuIGhhc2hNZXRob2QoYVNvcnRlZCwgYlNvcnRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBwYXRoIHRvIGxlYWZcbiAgICogQHBhcmFtIGxlYWYgaGV4LXN0cmluZ1xuICAgKiBAcGFyYW0gYnJhbmNoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHBhcmFtIGhhc2hQYXRoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHJldHVybnMgZm9ybWF0OiBoZXgtc3RyaW5nIGFycmF5XG4gICAqL1xuICBnZXRQcm9vZihsZWFmLCBicmFuY2ggPSB0aGlzLmxlYXZlcywgaGFzaFBhdGggPSBbXSkge1xuICAgIGNvbnN0IGluZGV4ID0gYnJhbmNoLmluZGV4T2YobGVhZik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVhZiBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIGlmIChicmFuY2gubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzaFBhdGg7XG4gICAgfVxuICAgIGNvbnN0IGlzTGVmdCA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICBjb25zdCBuZWVkZWRCcmFuY2ggPSAoaXNMZWZ0ID8gYnJhbmNoW2luZGV4ICsgMV0gOiBicmFuY2hbaW5kZXggLSAxXSkgPz8gXCIweDBcIjtcbiAgICBjb25zdCBuZXdIYXNoUGF0aCA9IFsuLi5oYXNoUGF0aCwgbmVlZGVkQnJhbmNoXTtcbiAgICBjb25zdCBjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCA9IHRoaXMubGVhdmVzLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCA/IC0xIDogdGhpcy5icmFuY2hlcy5maW5kSW5kZXgoKGIpID0+IGIubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoKTtcbiAgICBjb25zdCBuZXh0QnJhbmNoID0gdGhpcy5icmFuY2hlc1tjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCArIDFdID8/IFt0aGlzLnJvb3RdO1xuICAgIHJldHVybiB0aGlzLmdldFByb29mKFxuICAgICAgTWVya2xlVHJlZS5oYXNoKGlzTGVmdCA/IGxlYWYgOiBuZWVkZWRCcmFuY2gsIGlzTGVmdCA/IG5lZWRlZEJyYW5jaCA6IGxlYWYsIHRoaXMuaGFzaE1ldGhvZCksXG4gICAgICBuZXh0QnJhbmNoLFxuICAgICAgbmV3SGFzaFBhdGhcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIGxlYWYsIHBhdGgsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByb290ID09PSBsZWFmO1xuICB9XG4gIGNvbnN0IFtuZXh0LCAuLi5yZXN0XSA9IHBhdGg7XG4gIHJldHVybiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgTWVya2xlVHJlZS5oYXNoKGxlYWYsIG5leHQsIGhhc2hNZXRob2QpLCByZXN0LCBoYXNoTWV0aG9kKTtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHByZXNldFR5cGVzID0ge1xuICB1MjU2OiBKU09OLnBhcnNlKCdbeyBcIm5hbWVcIjogXCJsb3dcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH0sIHsgXCJuYW1lXCI6IFwiaGlnaFwiLCBcInR5cGVcIjogXCJ1MTI4XCIgfV0nKSxcbiAgVG9rZW5BbW91bnQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcInRva2VuX2FkZHJlc3NcIiwgXCJ0eXBlXCI6IFwiQ29udHJhY3RBZGRyZXNzXCIgfSwgeyBcIm5hbWVcIjogXCJhbW91bnRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApLFxuICBOZnRJZDogSlNPTi5wYXJzZShcbiAgICAnW3sgXCJuYW1lXCI6IFwiY29sbGVjdGlvbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwidG9rZW5faWRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApXG59O1xudmFyIHJldmlzaW9uQ29uZmlndXJhdGlvbiA9IHtcbiAgW1wiMVwiIC8qIEFjdGl2ZSAqL106IHtcbiAgICBkb21haW46IFwiU3RhcmtuZXREb21haW5cIixcbiAgICBoYXNoTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyxcbiAgICBoYXNoTWVya2xlTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICAgIGVzY2FwZVR5cGVTdHJpbmc6IChzKSA9PiBgXCIke3N9XCJgLFxuICAgIHByZXNldFR5cGVzXG4gIH0sXG4gIFtcIjBcIiAvKiBMZWdhY3kgKi9dOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrTmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gcyxcbiAgICBwcmVzZXRUeXBlczoge31cbiAgfVxufTtcbmZ1bmN0aW9uIGJ5dGVBcnJheUZyb21TdHJpbmcodGFyZ2V0U3RyaW5nKSB7XG4gIGNvbnN0IHNob3J0U3RyaW5ncyA9IHNwbGl0TG9uZ1N0cmluZyh0YXJnZXRTdHJpbmcpO1xuICBjb25zdCByZW1haW5kZXIgPSBzaG9ydFN0cmluZ3Nbc2hvcnRTdHJpbmdzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzaG9ydFN0cmluZ3NFbmNvZGVkID0gc2hvcnRTdHJpbmdzLm1hcChlbmNvZGVTaG9ydFN0cmluZyk7XG4gIGNvbnN0IFtwZW5kaW5nV29yZCwgcGVuZGluZ1dvcmRMZW5ndGhdID0gcmVtYWluZGVyID09PSB2b2lkIDAgfHwgcmVtYWluZGVyLmxlbmd0aCA9PT0gMzEgPyBbXCIweDAwXCIsIDBdIDogW3Nob3J0U3RyaW5nc0VuY29kZWQucG9wKCksIHJlbWFpbmRlci5sZW5ndGhdO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHNob3J0U3RyaW5nc0VuY29kZWQubGVuZ3RoID09PSAwID8gW1wiMHgwMFwiXSA6IHNob3J0U3RyaW5nc0VuY29kZWQsXG4gICAgcGVuZGluZ193b3JkOiBwZW5kaW5nV29yZCxcbiAgICBwZW5kaW5nX3dvcmRfbGVuOiBwZW5kaW5nV29yZExlbmd0aFxuICB9O1xufVxuZnVuY3Rpb24gaWRlbnRpZnlSZXZpc2lvbih7IHR5cGVzLCBkb21haW4gfSkge1xuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW1wiMVwiIC8qIEFjdGl2ZSAqL10uZG9tYWluIGluIHR5cGVzICYmIGRvbWFpbi5yZXZpc2lvbiA9PT0gXCIxXCIgLyogQWN0aXZlICovKVxuICAgIHJldHVybiBcIjFcIiAvKiBBY3RpdmUgKi87XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bXCIwXCIgLyogTGVnYWN5ICovXS5kb21haW4gaW4gdHlwZXMgJiYgKGRvbWFpbi5yZXZpc2lvbiA/PyBcIjBcIiAvKiBMZWdhY3kgKi8pID09PSBcIjBcIiAvKiBMZWdhY3kgKi8pXG4gICAgcmV0dXJuIFwiMFwiIC8qIExlZ2FjeSAqLztcbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZERhdGEoZGF0YSkge1xuICBjb25zdCB0eXBlZERhdGEgPSBkYXRhO1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlZERhdGEubWVzc2FnZSAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLnR5cGVzICYmIGlkZW50aWZ5UmV2aXNpb24odHlwZWREYXRhKVxuICApO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlLCBkZXBlbmRlbmNpZXMgPSBbXSwgY29udGFpbnMgPSBcIlwiLCByZXZpc2lvbiA9IFwiMFwiIC8qIExlZ2FjeSAqLykge1xuICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSBcIipcIikge1xuICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIC0xKTtcbiAgfSBlbHNlIGlmIChyZXZpc2lvbiA9PT0gXCIxXCIgLyogQWN0aXZlICovKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiZW51bVwiKSB7XG4gICAgICB0eXBlID0gY29udGFpbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlLm1hdGNoKC9eXFwoLipcXCkkLykpIHtcbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llcy5pbmNsdWRlcyh0eXBlKSB8fCAhdHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIHJldHVybiBbXG4gICAgdHlwZSxcbiAgICAuLi50eXBlc1t0eXBlXS5yZWR1Y2UoXG4gICAgICAocHJldmlvdXMsIHQpID0+IFtcbiAgICAgICAgLi4ucHJldmlvdXMsXG4gICAgICAgIC4uLmdldERlcGVuZGVuY2llcyh0eXBlcywgdC50eXBlLCBwcmV2aW91cywgdC5jb250YWlucywgcmV2aXNpb24pLmZpbHRlcihcbiAgICAgICAgICAoZGVwZW5kZW5jeSkgPT4gIXByZXZpb3VzLmluY2x1ZGVzKGRlcGVuZGVuY3kpXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBbXVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGdldE1lcmtsZVRyZWVUeXBlKHR5cGVzLCBjdHgpIHtcbiAgaWYgKGN0eC5wYXJlbnQgJiYgY3R4LmtleSkge1xuICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XTtcbiAgICBjb25zdCBtZXJrbGVUeXBlID0gcGFyZW50VHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGN0eC5rZXkpO1xuICAgIGNvbnN0IGlzTWVya2xlVHJlZSA9IGlzTWVya2xlVHJlZVR5cGUobWVya2xlVHlwZSk7XG4gICAgaWYgKCFpc01lcmtsZVRyZWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjdHgua2V5fSBpcyBub3QgYSBtZXJrbGUgdHJlZWApO1xuICAgIH1cbiAgICBpZiAobWVya2xlVHlwZS5jb250YWlucy5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWVya2xlIHRyZWUgY29udGFpbiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBhbiBhcnJheSBidXQgd2FzIGdpdmVuICR7Y3R4LmtleX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmtsZVR5cGUuY29udGFpbnM7XG4gIH1cbiAgcmV0dXJuIFwicmF3XCI7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKHR5cGVzLCB0eXBlLCByZXZpc2lvbiA9IFwiMFwiIC8qIExlZ2FjeSAqLykge1xuICBjb25zdCBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzXSA9IGdldERlcGVuZGVuY2llcyh0eXBlcywgdHlwZSwgdm9pZCAwLCB2b2lkIDAsIHJldmlzaW9uKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICBjb25zdCBlc2MgPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmVzY2FwZVR5cGVTdHJpbmc7XG4gIHJldHVybiBuZXdUeXBlcy5tYXAoKGRlcGVuZGVuY3kpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmN5RWxlbWVudHMgPSB0eXBlc1tkZXBlbmRlbmN5XS5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0LnR5cGUgPT09IFwiZW51bVwiICYmIHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8gPyB0LmNvbnRhaW5zIDogdC50eXBlO1xuICAgICAgY29uc3QgdHlwZVN0cmluZyA9IHRhcmdldFR5cGUubWF0Y2goL15cXCguKlxcKSQvKSA/IGAoJHt0YXJnZXRUeXBlLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKChlKSA9PiBlID8gZXNjKGUpIDogZSkuam9pbihcIixcIil9KWAgOiBlc2ModGFyZ2V0VHlwZSk7XG4gICAgICByZXR1cm4gYCR7ZXNjKHQubmFtZSl9OiR7dHlwZVN0cmluZ31gO1xuICAgIH0pO1xuICAgIHJldHVybiBgJHtlc2MoZGVwZW5kZW5jeSl9KCR7ZGVwZW5kZW5jeUVsZW1lbnRzfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUhhc2godHlwZXMsIHR5cGUsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZSwgZGF0YSwgY3R4ID0ge30sIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGlmICh0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbdHlwZSwgZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24pXTtcbiAgfVxuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgZ2V0U3RydWN0SGFzaChcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcmV2aXNpb25cbiAgICAgIClcbiAgICBdO1xuICB9XG4gIGlmICh0eXBlLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIGNvbnN0IGhhc2hlcyA9IGRhdGEubWFwKFxuICAgICAgKGVudHJ5KSA9PiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIGVudHJ5LCB2b2lkIDAsIHJldmlzaW9uKVsxXVxuICAgICk7XG4gICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoaGFzaGVzKV07XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImVudW1cIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICAgICAgY29uc3QgW3ZhcmlhbnRLZXksIHZhcmlhbnREYXRhXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpWzBdO1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbY3R4LnBhcmVudF1bMF07XG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZXNbcGFyZW50VHlwZS5jb250YWluc107XG4gICAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gZW51bVR5cGUuZmluZCgodCkgPT4gdC5uYW1lID09PSB2YXJpYW50S2V5KTtcbiAgICAgICAgY29uc3QgdmFyaWFudEluZGV4ID0gZW51bVR5cGUuaW5kZXhPZih2YXJpYW50VHlwZSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRTdWJ0eXBlcyA9IHZhcmlhbnRUeXBlLnR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKHN1YnR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJ0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgICAgY29uc3Qgc3VidHlwZURhdGEgPSB2YXJpYW50RGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBzdWJ0eXBlLCBzdWJ0eXBlRGF0YSwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKFt2YXJpYW50SW5kZXgsIC4uLmVuY29kZWRTdWJ0eXBlc10pXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJtZXJrbGV0cmVlXCI6IHtcbiAgICAgIGNvbnN0IG1lcmtsZVRyZWVUeXBlID0gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCk7XG4gICAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVWYWx1ZSh0eXBlcywgbWVya2xlVHJlZVR5cGUsIHN0cnVjdCwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoXG4gICAgICAgIHN0cnVjdEhhc2hlcyxcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWVya2xlTWV0aG9kXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtcImZlbHRcIiwgcm9vdF07XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCBwcmVwYXJlU2VsZWN0b3IoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gXCIxXCIgLyogQWN0aXZlICovKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgIGJ5dGVBcnJheS5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5ieXRlQXJyYXkuZGF0YSxcbiAgICAgICAgICBieXRlQXJyYXkucGVuZGluZ193b3JkLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVsZW1lbnRzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJmZWx0XCI6XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICBjYXNlIFwidTEyOFwiOlxuICAgIGNhc2UgXCJpMTI4XCI6XG4gICAgY2FzZSBcIkNvbnRyYWN0QWRkcmVzc1wiOlxuICAgIGNhc2UgXCJDbGFzc0hhc2hcIjpcbiAgICBjYXNlIFwidGltZXN0YW1wXCI6XG4gICAgY2FzZSBcInNob3J0c3RyaW5nXCI6XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbiA9IFwiMFwiIC8qIExlZ2FjeSAqLykge1xuICBjb25zdCB0YXJnZXRUeXBlID0gdHlwZXNbdHlwZV0gPz8gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlc1t0eXBlXTtcbiAgY29uc3QgW3JldHVyblR5cGVzLCB2YWx1ZXNdID0gdGFyZ2V0VHlwZS5yZWR1Y2UoXG4gICAgKFt0cywgdnNdLCBmaWVsZCkgPT4ge1xuICAgICAgaWYgKGRhdGFbZmllbGQubmFtZV0gPT09IHZvaWQgMCB8fCBkYXRhW2ZpZWxkLm5hbWVdID09PSBudWxsICYmIGZpZWxkLnR5cGUgIT09IFwiZW51bVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGVuY29kZSBkYXRhOiBtaXNzaW5nIGRhdGEgZm9yICcke2ZpZWxkLm5hbWV9J2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgY29uc3QgY3R4ID0geyBwYXJlbnQ6IHR5cGUsIGtleTogZmllbGQubmFtZSB9O1xuICAgICAgY29uc3QgW3QsIGVuY29kZWRWYWx1ZV0gPSBlbmNvZGVWYWx1ZSh0eXBlcywgZmllbGQudHlwZSwgdmFsdWUsIGN0eCwgcmV2aXNpb24pO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgWy4uLnRzLCB0XSxcbiAgICAgICAgWy4uLnZzLCBlbmNvZGVkVmFsdWVdXG4gICAgICBdO1xuICAgIH0sXG4gICAgW1tcImZlbHRcIl0sIFtnZXRUeXBlSGFzaCh0eXBlcywgdHlwZSwgcmV2aXNpb24pXV1cbiAgKTtcbiAgcmV0dXJuIFtyZXR1cm5UeXBlcywgdmFsdWVzXTtcbn1cbmZ1bmN0aW9uIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIHJldHVybiByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoZW5jb2RlRGF0YSh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24pWzFdKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudCkge1xuICBpZiAoIXZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIGRvZXMgbm90IG1hdGNoIEpTT04gc2NoZW1hXCIpO1xuICB9XG4gIGNvbnN0IHJldmlzaW9uID0gaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpO1xuICBjb25zdCB7IGRvbWFpbiwgaGFzaE1ldGhvZCB9ID0gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXTtcbiAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICBlbmNvZGVTaG9ydFN0cmluZyhcIlN0YXJrTmV0IE1lc3NhZ2VcIiksXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIGRvbWFpbiwgdHlwZWREYXRhLmRvbWFpbiwgcmV2aXNpb24pLFxuICAgIGFjY291bnQsXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSwgdHlwZWREYXRhLm1lc3NhZ2UsIHJldmlzaW9uKVxuICBdO1xuICByZXR1cm4gaGFzaE1ldGhvZChtZXNzYWdlKTtcbn1cblxuLy8gc3JjL3NpZ25lci9kZWZhdWx0LnRzXG52YXIgU2lnbmVyID0gY2xhc3Mge1xuICBwaztcbiAgY29uc3RydWN0b3IocGsgPSBzdGFya0N1cnZlLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSkge1xuICAgIHRoaXMucGsgPSBwayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWYyaGV4KHBrKSA6IHRvSGV4KHBrKTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuZ2V0U3RhcmtLZXkodGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uc0RldGFpbCwgYWJpcykge1xuICAgIGlmIChhYmlzICYmIGFiaXMubGVuZ3RoICE9PSB0cmFuc2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBQkkgbXVzdCBiZSBwcm92aWRlZCBmb3IgZWFjaCB0cmFuc2FjdGlvbiBvciBubyB0cmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbnNEZXRhaWwuY2Fpcm9WZXJzaW9uKTtcbiAgICBjb25zdCBtc2dIYXNoID0gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLndhbGxldEFkZHJlc3MsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwudmVyc2lvbixcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLm1heEZlZSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5jaGFpbklkLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLm5vbmNlXG4gICAgKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICBhZGRyZXNzU2FsdCxcbiAgICBtYXhGZWUsXG4gICAgdmVyc2lvbixcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlXG4gIH0pIHtcbiAgICBjb25zdCBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaChcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSksXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBtYXhGZWUsXG4gICAgICBjaGFpbklkLFxuICAgICAgbm9uY2VcbiAgICApO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnNpZ24obXNnSGFzaCwgdGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbih7XG4gICAgY2xhc3NIYXNoLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBtYXhGZWUsXG4gICAgdmVyc2lvbixcbiAgICBub25jZSxcbiAgICBjb21waWxlZENsYXNzSGFzaFxuICB9KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2goXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBzZW5kZXJBZGRyZXNzLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG1heEZlZSxcbiAgICAgIGNoYWluSWQsXG4gICAgICBub25jZSxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoXG4gICAgKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZXZlbnRzLnRzXG5mdW5jdGlvbiBwYXJzZVVEQ0V2ZW50KHR4UmVjZWlwdCkge1xuICBpZiAoIXR4UmVjZWlwdC5ldmVudHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVREMgZW1pdHRlZCBldmVudCBpcyBlbXB0eVwiKTtcbiAgfVxuICBjb25zdCBldmVudCA9IHR4UmVjZWlwdC5ldmVudHMuZmluZChcbiAgICAoaXQpID0+IGNsZWFuSGV4KGl0LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KFVEQy5BRERSRVNTKVxuICApIHx8IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICByZXR1cm4ge1xuICAgIHRyYW5zYWN0aW9uX2hhc2g6IHR4UmVjZWlwdC50cmFuc2FjdGlvbl9oYXNoLFxuICAgIGNvbnRyYWN0X2FkZHJlc3M6IGV2ZW50LmRhdGFbMF0sXG4gICAgYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBkZXBsb3llcjogZXZlbnQuZGF0YVsxXSxcbiAgICB1bmlxdWU6IGV2ZW50LmRhdGFbMl0sXG4gICAgY2xhc3NIYXNoOiBldmVudC5kYXRhWzNdLFxuICAgIGNhbGxkYXRhX2xlbjogZXZlbnQuZGF0YVs0XSxcbiAgICBjYWxsZGF0YTogZXZlbnQuZGF0YS5zbGljZSg1LCA1ICsgcGFyc2VJbnQoZXZlbnQuZGF0YVs0XSwgMTYpKSxcbiAgICBzYWx0OiBldmVudC5kYXRhW2V2ZW50LmRhdGEubGVuZ3RoIC0gMV1cbiAgfTtcbn1cblxuLy8gc3JjL2FjY291bnQvZGVmYXVsdC50c1xudmFyIEFjY291bnQgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCBhZGRyZXNzLCBwa09yU2lnbmVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucyk7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuc2lnbmVyID0gdHlwZW9mIHBrT3JTaWduZXIgPT09IFwic3RyaW5nXCIgfHwgcGtPclNpZ25lciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBuZXcgU2lnbmVyKHBrT3JTaWduZXIpIDogcGtPclNpZ25lcjtcbiAgICBpZiAoY2Fpcm9WZXJzaW9uKSB7XG4gICAgICB0aGlzLmNhaXJvVmVyc2lvbiA9IGNhaXJvVmVyc2lvbi50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXROb25jZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKHRoaXMuYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZVNhZmUobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAwbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gdmVyc2lvbiBmcm9tIHRoZSBuZXR3b3JrIGFuZCBzZXRzIGBjYWlyb1ZlcnNpb25gIGlmIG5vdCBhbHJlYWR5IHNldCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIGNsYXNzSGFzaCBpZiBwcm92aWRlZCBkZXRlY3RzIENhaXJvIHZlcnNpb24gZnJvbSBjbGFzc0hhc2gsIG90aGVyd2lzZSBmcm9tIHRoZSBhY2NvdW50IGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGdldENhaXJvVmVyc2lvbihjbGFzc0hhc2gpIHtcbiAgICBpZiAoIXRoaXMuY2Fpcm9WZXJzaW9uKSB7XG4gICAgICBjb25zdCB7IGNhaXJvIH0gPSBjbGFzc0hhc2ggPyBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odm9pZCAwLCBjbGFzc0hhc2gpIDogYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gICAgICB0aGlzLmNhaXJvVmVyc2lvbiA9IGNhaXJvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWlyb1ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCB7IG5vbmNlOiBwcm92aWRlZE5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQoZmVlVHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0SW52b2tlRXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLmludm9jYXRpb24gfSxcbiAgICAgIHsgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUocmVzcG9uc2Uub3ZlcmFsbF9mZWUpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZWNsYXJlRmVlKHsgY29udHJhY3QsIGNsYXNzSGFzaDogcHJvdmlkZWRDbGFzc0hhc2gsIGNhc20sIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIHsgYmxvY2tJZGVudGlmaWVyLCBub25jZTogcHJvdmlkZWROb25jZSwgc2tpcFZhbGlkYXRlIH0gPSB7fSkge1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQocHJvdmlkZWROb25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSAhaXNTaWVycmEoY29udHJhY3QpID8gZmVlVHJhbnNhY3Rpb25WZXJzaW9uIDogZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzI7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2g6IHByb3ZpZGVkQ2xhc3NIYXNoLCBjb250cmFjdCwgY2FzbSwgY29tcGlsZWRDbGFzc0hhc2ggfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldERlY2xhcmVFc3RpbWF0ZUZlZShcbiAgICAgIGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLFxuICAgICAgeyB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShyZXNwb25zZS5vdmVyYWxsX2ZlZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQoZmVlVHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5wYXlsb2FkIH0sXG4gICAgICB7IHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKHJlc3BvbnNlLm92ZXJhbGxfZmVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCkge1xuICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZUJ1bGsoaW52b2NhdGlvbnMsIHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0gPSB7fSkge1xuICAgIGNvbnN0IGFjY291bnRJbnZvY2F0aW9ucyA9IGF3YWl0IHRoaXMuYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywge1xuICAgICAgdmVyc2lvbnM6IFtmZWVUcmFuc2FjdGlvblZlcnNpb24sIGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXRFc3RpbWF0ZUZlZUJ1bGsoYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gW10uY29uY2F0KHJlc3BvbnNlKS5tYXAoKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKGVsZW0ub3ZlcmFsbF9mZWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZWxlbSxcbiAgICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGJ1aWxkSW52b2NhdGlvbihjYWxsLCBzaWduZXJEZXRhaWxzKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEoY2FsbCwgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGwsIHNpZ25lckRldGFpbHMpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBhc3luYyBleGVjdXRlKGNhbGxzLCBhYmlzID0gdm9pZCAwLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEFycmF5LmlzQXJyYXkoY2FsbHMpID8gY2FsbHMgOiBbY2FsbHNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQodHJhbnNhY3Rpb25zRGV0YWlsLm5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgbWF4RmVlID0gdHJhbnNhY3Rpb25zRGV0YWlsLm1heEZlZSA/PyBhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZE1heEZlZShcbiAgICAgIHsgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sIHBheWxvYWQ6IGNhbGxzIH0sXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWxcbiAgICApO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b0JpZ0ludCh0cmFuc2FjdGlvblZlcnNpb24pO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKVxuICAgIH07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgc2lnbmVyRGV0YWlscywgYWJpcyk7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpKTtcbiAgICByZXR1cm4gdGhpcy5pbnZva2VGdW5jdGlvbihcbiAgICAgIHsgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsIGNhbGxkYXRhLCBzaWduYXR1cmUgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IGNoZWNrIGlmIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVjbGFyZWQsIGlmIG5vdCBkZWNsYXJlIGl0XG4gICAqIElmIGNvbnRyYWN0IGFscmVhZHkgZGVjbGFyZWQgcmV0dXJuZWQgdHJhbnNhY3Rpb25faGFzaCBpcyAnJy5cbiAgICogTWV0aG9kIHdpbGwgcGFzcyBldmVuIGlmIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uc0RldGFpbCAob3B0aW9uYWwpXG4gICAqL1xuICBhc3luYyBkZWNsYXJlSWZOb3QocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmdldENsYXNzQnlIYXNoKGRlY2xhcmVDb250cmFjdFBheWxvYWQuY2xhc3NIYXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogXCJcIixcbiAgICAgIGNsYXNzX2hhc2g6IGRlY2xhcmVDb250cmFjdFBheWxvYWQuY2xhc3NIYXNoXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge307XG4gICAgZGV0YWlscy5ub25jZSA9IHRvQmlnSW50KHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGRldGFpbHMubWF4RmVlID0gdHJhbnNhY3Rpb25zRGV0YWlsLm1heEZlZSA/PyBhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZE1heEZlZShcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgcGF5bG9hZDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZFxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbFxuICAgICk7XG4gICAgZGV0YWlscy52ZXJzaW9uID0gIWlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpID8gdHJhbnNhY3Rpb25WZXJzaW9uIDogdHJhbnNhY3Rpb25WZXJzaW9uXzI7XG4gICAgZGV0YWlscy5jaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQoZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCwge1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwXG4gICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyZUNvbnRyYWN0KGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3kocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdLmNvbmNhdChwYXlsb2FkKS5tYXAoKGl0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgc2FsdCxcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgY29uc3QgZGVwbG95U2FsdCA9IHNhbHQgPz8gcmFuZG9tQWRkcmVzcygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDoge1xuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICAgIGRlcGxveVNhbHQsXG4gICAgICAgICAgICB0b0NhaXJvQm9vbCh1bmlxdWUpLFxuICAgICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkcmVzczogY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goXG4gICAgICAgICAgdW5pcXVlID8gc3RhcmtDdXJ2ZS5wZWRlcnNlbih0aGlzLmFkZHJlc3MsIGRlcGxveVNhbHQpIDogZGVwbG95U2FsdCxcbiAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLFxuICAgICAgICAgIHVuaXF1ZSA/IFVEQy5BRERSRVNTIDogMFxuICAgICAgICApXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxzID0gcGFyYW1zLm1hcCgoaXQpID0+IGl0LmNhbGwpO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5hZGRyZXNzKTtcbiAgICBjb25zdCBpbnZva2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShjYWxscywgdm9pZCAwLCBkZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW52b2tlUmVzcG9uc2UsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBhZGRyZXNzZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUNvbnRyYWN0KHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCBkZXBsb3lUeCA9IGF3YWl0IHRoaXMuZGVwbG95KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlcGxveVR4LnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgIHJldHVybiBwYXJzZVVEQ0V2ZW50KHR4UmVjZWlwdCk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUFuZERlcGxveShwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB1bmlxdWUgfSA9IHBheWxvYWQ7XG4gICAgbGV0IGRlY2xhcmUgPSBhd2FpdCB0aGlzLmRlY2xhcmVJZk5vdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBpZiAoZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoICE9PSBcIlwiKSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgICBkZWNsYXJlID0geyAuLi5kZWNsYXJlLCAuLi50eCB9O1xuICAgIH1cbiAgICBjb25zdCBkZXBsb3kgPSBhd2FpdCB0aGlzLmRlcGxveUNvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2g6IGRlY2xhcmUuY2xhc3NfaGFzaCwgc2FsdCwgdW5pcXVlLCBjb25zdHJ1Y3RvckNhbGxkYXRhIH0sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4geyBkZWNsYXJlOiB7IC4uLmRlY2xhcmUgfSwgZGVwbG95IH07XG4gIH1cbiAgZGVwbG95U2VsZiA9IHRoaXMuZGVwbG95QWNjb3VudDtcbiAgYXN5bmMgZGVwbG95QWNjb3VudCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b0JpZ0ludCh0cmFuc2FjdGlvblZlcnNpb24pO1xuICAgIGNvbnN0IG5vbmNlID0gWkVSTztcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3QgbWF4RmVlID0gdHJhbnNhY3Rpb25zRGV0YWlsLm1heEZlZSA/PyBhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZE1heEZlZShcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWxcbiAgICApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlcGxveUFjY291bnRDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoLCBhZGRyZXNzU2FsdCwgY29uc3RydWN0b3JDYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBtYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduTWVzc2FnZSh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgaGFzaE1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgZW50cnlwb2ludDogXCJpc1ZhbGlkU2lnbmF0dXJlXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBoYXNoOiB0b0JpZ0ludChoYXNoKS50b1N0cmluZygpLFxuICAgICAgICAgIHNpZ25hdHVyZTogZm9ybWF0U2lnbmF0dXJlKHNpZ25hdHVyZSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHZlcmlmeU1lc3NhZ2UodHlwZWREYXRhLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5oYXNoTWVzc2FnZSh0eXBlZERhdGEpO1xuICAgIHJldHVybiB0aGlzLnZlcmlmeU1lc3NhZ2VIYXNoKGhhc2gsIHNpZ25hdHVyZSk7XG4gIH1cbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkTWF4RmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IGZlZUVzdGltYXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlSW52b2tlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlQWNjb3VudERlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZXCIgLyogREVQTE9ZICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSB7IHN1Z2dlc3RlZE1heEZlZTogWkVSTywgb3ZlcmFsbF9mZWU6IFpFUk8gfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmZWVFc3RpbWF0ZS5zdWdnZXN0ZWRNYXhGZWU7XG4gIH1cbiAgLyoqXG4gICAqIHdpbGwgYmUgcmVuYW1lZCB0byBidWlsZERlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBidWlsZERlY2xhcmVQYXlsb2FkKHBheWxvYWQsIHsgbm9uY2UsIGNoYWluSWQsIHZlcnNpb24sIHdhbGxldEFkZHJlc3MsIG1heEZlZSB9KSB7XG4gICAgY29uc3QgeyBjbGFzc0hhc2gsIGNvbnRyYWN0LCBjb21waWxlZENsYXNzSGFzaCB9ID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0ID0gcGFyc2VDb250cmFjdChjb250cmFjdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlY2xhcmVUcmFuc2FjdGlvbih7XG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaCxcbiAgICAgIHNlbmRlckFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXG4gICAgICBjaGFpbklkLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5vbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmRlckFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBjb250cmFjdDogY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCB7IG5vbmNlLCBjaGFpbklkLCB2ZXJzaW9uLCBtYXhGZWUgfSkge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZSxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBjb25zdCBjYWxscyA9IFtdLmNvbmNhdChwYXlsb2FkKS5tYXAoKGl0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgc2FsdCA9IFwiMFwiLFxuICAgICAgICB1bmlxdWUgPSB0cnVlLFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICAgIH0gPSBpdDtcbiAgICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IFVEQy5BRERSRVNTLFxuICAgICAgICBlbnRyeXBvaW50OiBVREMuRU5UUllQT0lOVCxcbiAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgc2FsdCxcbiAgICAgICAgICB0b0NhaXJvQm9vbCh1bmlxdWUpLFxuICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YS5sZW5ndGgsXG4gICAgICAgICAgLi4uY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxzO1xuICB9XG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlLCBza2lwRXhlY3V0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIHZlcnNpb25zOiBbdHJhbnNhY3Rpb25WZXJzaW9uLCB0cmFuc2FjdGlvblZlcnNpb25fMl0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlLFxuICAgICAgc2tpcEV4ZWN1dGVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7IHZlcnNpb25zLCBub25jZSwgYmxvY2tJZGVudGlmaWVyIH0pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbMF07XG4gICAgY29uc3Qgc2FmZU5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZVNhZmUobm9uY2UpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCB0eDBQYXlsb2FkID0gXCJwYXlsb2FkXCIgaW4gaW52b2NhdGlvbnNbMF0gPyBpbnZvY2F0aW9uc1swXS5wYXlsb2FkIDogaW52b2NhdGlvbnNbMF07XG4gICAgY29uc3QgY2Fpcm9WZXJzaW9uID0gaW52b2NhdGlvbnNbMF0udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovID8gYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24odHgwUGF5bG9hZC5jbGFzc0hhc2gpIDogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBbXS5jb25jYXQoaW52b2NhdGlvbnMpLm1hcChhc3luYyAodHJhbnNhY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHR4UGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIHRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24ucGF5bG9hZCA6IHRyYW5zYWN0aW9uO1xuICAgICAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9CaWdJbnQoTnVtYmVyKHNhZmVOb25jZSkgKyBpbmRleCksXG4gICAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBjYWlyb1ZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICBub25jZTogdG9CaWdJbnQoTnVtYmVyKHNhZmVOb25jZSkgKyBpbmRleCksXG4gICAgICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihcbiAgICAgICAgICAgIFtdLmNvbmNhdCh0eFBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmVyRGV0YWlsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gIWlzU2llcnJhKHR4UGF5bG9hZC5jb250cmFjdCkgPyB0b0JpZ0ludCh2ZXJzaW9uc1swXSkgOiB0b0JpZ0ludCh2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZCh0eFBheWxvYWQsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgdmVyc2lvbjogc2lnbmVyRGV0YWlscy52ZXJzaW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh0eFBheWxvYWQsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8pIHtcbiAgICAgICAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQodHhQYXlsb2FkKTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oY2FsbHMsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKGBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5OiB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9ufWApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzID0gdGhpcy5hZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2ludGVyZmFjZS50c1xudmFyIFByb3ZpZGVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2luZGV4LnRzXG52YXIgZGVmYXVsdFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHsgcnBjOiB7IGRlZmF1bHQ6IHRydWUgfSB9KTtcblxuLy8gc3JjL2FjY291bnQvaW50ZXJmYWNlLnRzXG52YXIgQWNjb3VudEludGVyZmFjZSA9IGNsYXNzIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2Uge1xufTtcblxuLy8gc3JjL3V0aWxzL2V2ZW50cy9pbmRleC50c1xudmFyIGV2ZW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChldmVudHNfZXhwb3J0cywge1xuICBnZXRBYmlFdmVudHM6ICgpID0+IGdldEFiaUV2ZW50cyxcbiAgcGFyc2VFdmVudHM6ICgpID0+IHBhcnNlRXZlbnRzXG59KTtcbmZ1bmN0aW9uIGdldEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImV2ZW50XCIgJiYgKGFiaUVudHJ5LnNpemUgfHwgYWJpRW50cnkua2luZCAhPT0gXCJlbnVtXCIpKS5yZWR1Y2UoKGFjYywgYWJpRW50cnkpID0+IHtcbiAgICBjb25zdCBlbnRyeU5hbWUgPSBhYmlFbnRyeS5uYW1lLnNsaWNlKGFiaUVudHJ5Lm5hbWUubGFzdEluZGV4T2YoXCI6XCIpICsgMSk7XG4gICAgY29uc3QgYWJpRW50cnlNb2QgPSB7IC4uLmFiaUVudHJ5IH07XG4gICAgYWJpRW50cnlNb2QubmFtZSA9IGVudHJ5TmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShlbnRyeU5hbWUpKS50b1N0cmluZygxNikpXTogYWJpRW50cnlNb2RcbiAgICB9O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhwcm92aWRlclJlY2VpdmVkRXZlbnRzLCBhYmlFdmVudHMsIGFiaVN0cnVjdHMsIGFiaUVudW1zKSB7XG4gIGNvbnN0IHJldCA9IHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMuZmxhdCgpLnJlZHVjZSgoYWNjLCByZWNFdmVudCkgPT4ge1xuICAgIGNvbnN0IGFiaUV2ZW50ID0gYWJpRXZlbnRzW3JlY0V2ZW50LmtleXNbMF1dO1xuICAgIGlmICghYWJpRXZlbnQpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICByZWNFdmVudC5rZXlzLnNoaWZ0KCk7XG4gICAgY29uc3Qga2V5c0l0ZXIgPSByZWNFdmVudC5rZXlzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBkYXRhSXRlciA9IHJlY0V2ZW50LmRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGFiaUV2ZW50S2V5cyA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwia2V5XCIpIHx8IGFiaUV2ZW50LmtleXM7XG4gICAgY29uc3QgYWJpRXZlbnREYXRhID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJkYXRhXCIpIHx8IGFiaUV2ZW50LmRhdGE7XG4gICAgYWJpRXZlbnRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1ba2V5Lm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGtleXNJdGVyLFxuICAgICAgICBrZXksXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhYmlFdmVudERhdGEuZm9yRWFjaCgoZGF0YSkgPT4ge1xuICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1bZGF0YS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBkYXRhSXRlcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFjYy5wdXNoKHBhcnNlZEV2ZW50KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9jb250cmFjdC9kZWZhdWx0LnRzXG52YXIgc3BsaXRBcmdzQW5kT3B0aW9ucyA9IChhcmdzKSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgXCJibG9ja0lkZW50aWZpZXJcIixcbiAgICBcInBhcnNlUmVxdWVzdFwiLFxuICAgIFwicGFyc2VSZXNwb25zZVwiLFxuICAgIFwiZm9ybWF0UmVzcG9uc2VcIixcbiAgICBcIm1heEZlZVwiLFxuICAgIFwibm9uY2VcIixcbiAgICBcInNpZ25hdHVyZVwiLFxuICAgIFwiYWRkcmVzc1NhbHRcIlxuICBdO1xuICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICBpZiAodHlwZW9mIGxhc3RBcmcgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5zb21lKCh4KSA9PiB4IGluIGxhc3RBcmcpKSB7XG4gICAgcmV0dXJuIHsgYXJncywgb3B0aW9uczogYXJncy5wb3AoKSB9O1xuICB9XG4gIHJldHVybiB7IGFyZ3MgfTtcbn07XG5mdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuY2FsbChmdW5jdGlvbkFiaS5uYW1lLCBwYXJhbXMuYXJncywge1xuICAgICAgcGFyc2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgcGFyc2VSZXNwb25zZTogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtcy5vcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEludm9rZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIHJldHVybiBjb250cmFjdC5pbnZva2UoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtcy5vcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIGlmIChmdW5jdGlvbkFiaS5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IGZ1bmN0aW9uQWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnVuY3Rpb25BYmkpO1xuICB9XG4gIHJldHVybiBidWlsZEludm9rZShjb250cmFjdCwgZnVuY3Rpb25BYmkpO1xufVxuZnVuY3Rpb24gYnVpbGRQb3B1bGF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QucG9wdWxhdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjb250cmFjdC5lc3RpbWF0ZShmdW5jdGlvbkFiaS5uYW1lLCBhcmdzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENhbGxkYXRhKGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIFwiX19jb21waWxlZF9fXCIgaW4gYXJncylcbiAgICByZXR1cm4gYXJncztcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3NbMF0pXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIHJldHVybiBjYWxsYmFjaygpO1xufVxudmFyIENvbnRyYWN0ID0gY2xhc3Mge1xuICBhYmk7XG4gIGFkZHJlc3M7XG4gIHByb3ZpZGVyT3JBY2NvdW50O1xuICBkZXBsb3lUcmFuc2FjdGlvbkhhc2g7XG4gIHN0cnVjdHM7XG4gIGV2ZW50cztcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbiAgY2FsbERhdGE7XG4gIC8qKlxuICAgKiBDb250cmFjdCBjbGFzcyB0byBoYW5kbGUgY29udHJhY3QgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0gYWJpIC0gQWJpIG9mIHRoZSBjb250cmFjdCBvYmplY3RcbiAgICogQHBhcmFtIGFkZHJlc3MgKG9wdGlvbmFsKSAtIGFkZHJlc3MgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0gcHJvdmlkZXJPckFjY291bnQgKG9wdGlvbmFsKSAtIFByb3ZpZGVyIG9yIEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhYmksIGFkZHJlc3MsIHByb3ZpZGVyT3JBY2NvdW50ID0gZGVmYXVsdFByb3ZpZGVyKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcyAmJiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICAgIHRoaXMuY2FsbERhdGEgPSBuZXcgQ2FsbERhdGEoYWJpKTtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmV2ZW50cyA9IGdldEFiaUV2ZW50cyhhYmkpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gcGFyc2VyLmdldExlZ2FjeUZvcm1hdCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgZnVuY3Rpb25zOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBjYWxsU3RhdGljOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBlc3RpbWF0ZUZlZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9XG4gICAgfSk7XG4gICAgdGhpcy5hYmkuZm9yRWFjaCgoYWJpRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGFiaUVsZW1lbnQudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhYmlFbGVtZW50Lm5hbWU7XG4gICAgICBpZiAoIXRoaXNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZ1bmN0aW9ucywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZENhbGwodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkUG9wdWxhdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXN0aW1hdGVGZWVbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lc3RpbWF0ZUZlZSwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRFc3RpbWF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gIH1cbiAgY29ubmVjdChwcm92aWRlck9yQWNjb3VudCkge1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgfVxuICBhc3luYyBkZXBsb3llZCgpIHtcbiAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXJPckFjY291bnQud2FpdEZvclRyYW5zYWN0aW9uKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBjYWxsKG1ldGhvZCwgYXJncyA9IFtdLCB7XG4gICAgcGFyc2VSZXF1ZXN0ID0gdHJ1ZSxcbiAgICBwYXJzZVJlc3BvbnNlID0gdHJ1ZSxcbiAgICBmb3JtYXRSZXNwb25zZSA9IHZvaWQgMCxcbiAgICBibG9ja0lkZW50aWZpZXIgPSB2b2lkIDBcbiAgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJDQUxMXCIgLyogQ0FMTCAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5jYWxsQ29udHJhY3QoXG4gICAgICB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YSxcbiAgICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgICB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgKS50aGVuKCh4KSA9PiB7XG4gICAgICBpZiAoIXBhcnNlUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHgucmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmZvcm1hdChtZXRob2QsIHgucmVzdWx0LCBmb3JtYXRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5wYXJzZShtZXRob2QsIHgucmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuICBpbnZva2UobWV0aG9kLCBhcmdzID0gW10sIHsgcGFyc2VSZXF1ZXN0ID0gdHJ1ZSwgbWF4RmVlLCBub25jZSwgc2lnbmF0dXJlIH0gPSB7fSkge1xuICAgIGFzc2VydCh0aGlzLmFkZHJlc3MgIT09IG51bGwsIFwiY29udHJhY3QgaXMgbm90IGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzXCIpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4ge1xuICAgICAgaWYgKHBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmNhbGxEYXRhLnZhbGlkYXRlKFwiSU5WT0tFXCIgLyogSU5WT0tFICovLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJJbnZva2Ugc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfSk7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBlbnRyeXBvaW50OiBtZXRob2RcbiAgICB9O1xuICAgIGlmIChcImV4ZWN1dGVcIiBpbiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5leGVjdXRlKGludm9jYXRpb24sIHZvaWQgMCwge1xuICAgICAgICBtYXhGZWUsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFub25jZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uY2UgaXMgcmVxdWlyZWQgd2hlbiBpbnZva2luZyBhIGZ1bmN0aW9uIHdpdGhvdXQgYW4gYWNjb3VudGApO1xuICAgIGNvbnNvbGUud2FybihgSW52b2tpbmcgJHttZXRob2R9IHdpdGhvdXQgYW4gYWNjb3VudC4gVGhpcyB3aWxsIG5vdCB3b3JrIG9uIGEgcHVibGljIG5vZGUuYCk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7XG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgaWYgKCFnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiBmYWxzZSkpIHtcbiAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGludm9jYXRpb24gPSB0aGlzLnBvcHVsYXRlKG1ldGhvZCwgYXJncyk7XG4gICAgaWYgKFwiZXN0aW1hdGVJbnZva2VGZWVcIiBpbiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5lc3RpbWF0ZUludm9rZUZlZShpbnZvY2F0aW9uKTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdCBtdXN0IGJlIGNvbm5lY3RlZCB0byB0aGUgYWNjb3VudCBjb250cmFjdCB0byBlc3RpbWF0ZVwiKTtcbiAgfVxuICBwb3B1bGF0ZShtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncykpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZCxcbiAgICAgIGNhbGxkYXRhXG4gICAgfTtcbiAgfVxuICBwYXJzZUV2ZW50cyhyZWNlaXB0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKFxuICAgICAgcmVjZWlwdC5ldmVudHM/LmZpbHRlcihcbiAgICAgICAgKGV2ZW50KSA9PiBjbGVhbkhleChldmVudC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleCh0aGlzLmFkZHJlc3MpLFxuICAgICAgICBbXVxuICAgICAgKSB8fCBbXSxcbiAgICAgIHRoaXMuZXZlbnRzLFxuICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgQ2FsbERhdGEuZ2V0QWJpRW51bSh0aGlzLmFiaSlcbiAgICApO1xuICB9XG4gIGlzQ2Fpcm8xKCkge1xuICAgIHJldHVybiBjYWlyb19leHBvcnRzLmlzQ2Fpcm8xQWJpKHRoaXMuYWJpKTtcbiAgfVxuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICB9XG4gIHR5cGVkdjEodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHR5cGVkdjIodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICBjb21waWxlZENvbnRyYWN0O1xuICBhY2NvdW50O1xuICBhYmk7XG4gIGNsYXNzSGFzaDtcbiAgY2FzbTtcbiAgY29tcGlsZWRDbGFzc0hhc2g7XG4gIENhbGxEYXRhO1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFwiREVQTE9ZXCIgLyogREVQTE9ZICovLCBcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcGxveTogeyBjb250cmFjdF9hZGRyZXNzLCB0cmFuc2FjdGlvbl9oYXNoIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5hY2NvdW50LmRlY2xhcmVBbmREZXBsb3koe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNhc206IHRoaXMuY2FzbSxcbiAgICAgIGNsYXNzSGFzaDogdGhpcy5jbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaDogdGhpcy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBzYWx0OiBvcHRpb25zLmFkZHJlc3NTYWx0XG4gICAgfSk7XG4gICAgYXNzZXJ0KEJvb2xlYW4oY29udHJhY3RfYWRkcmVzcyksIFwiRGVwbG95bWVudCBvZiB0aGUgY29udHJhY3QgZmFpbGVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5zdGFuY2UgPSBuZXcgQ29udHJhY3QoXG4gICAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QuYWJpLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIHRoaXMuYWNjb3VudFxuICAgICk7XG4gICAgY29udHJhY3RJbnN0YW5jZS5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbl9oYXNoO1xuICAgIHJldHVybiBjb250cmFjdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyB0byBuZXcgQWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIG5ldyBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29ubmVjdChhY2NvdW50KSB7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBhYmkgYW5kIGFjY291bnQgdG8gdGhlIG5ldyBhZGRyZXNzXG4gICAqL1xuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QodGhpcy5hYmksIGFkZHJlc3MsIHRoaXMuYWNjb3VudCk7XG4gIH1cbiAgLy8gZXRoZXJzLmpzJyBnZXREZXBsb3lUcmFuc2FjdGlvbiBjYW4ndCBiZSBzdXBwb3J0ZWQgYXMgaXQgcmVxdWlyZXMgdGhlIGFjY291bnQgb3Igc2lnbmVyIHRvIHJldHVybiBhIHNpZ25lZCB0cmFuc2FjdGlvbiB3aGljaCBpcyBub3QgcG9zc2libGUgd2l0aCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvblxufTtcblxuLy8gc3JjL3V0aWxzL2FkZHJlc3MudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcykge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHJlbW92ZUhleFByZWZpeCh0b0hleChhZGRyZXNzKSkucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGFzc2VydEluUmFuZ2UoYWRkcmVzcywgWkVSTywgQUREUl9CT1VORCAtIDFuLCBcIlN0YXJrbmV0IEFkZHJlc3NcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGFkZEFkZHJlc3NQYWRkaW5nKGFkZHJlc3MpO1xuICBpZiAoIXJlc3VsdC5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NjR9JC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBBZGRyZXNzIEZvcm1hdFwiKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgY2hhcnMgPSByZW1vdmVIZXhQcmVmaXgodmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGhleCA9IHJlbW92ZUhleFByZWZpeChrZWNjYWtCbihhZGRyZXNzKSk7XG4gIGNvbnN0IGhhc2hlZCA9IGhleFRvQnl0ZXMyKGhleC5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoYXNoZWRbaSA+PiAxXSA+PiA0ID49IDgpIHtcbiAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDE1KSA+PSA4KSB7XG4gICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEhleFByZWZpeChjaGFycy5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgbnVtYmVyID0gbnVtX2V4cG9ydHM7XG5leHBvcnQge1xuICBBY2NvdW50LFxuICBBY2NvdW50SW50ZXJmYWNlLFxuICBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWcsXG4gIENhaXJvQ3VzdG9tRW51bSxcbiAgQ2Fpcm9PcHRpb24sXG4gIENhaXJvT3B0aW9uVmFyaWFudCxcbiAgQ2Fpcm9SZXN1bHQsXG4gIENhaXJvUmVzdWx0VmFyaWFudCxcbiAgQ2FsbERhdGEsXG4gIENvbnRyYWN0LFxuICBDb250cmFjdEZhY3RvcnksXG4gIENvbnRyYWN0SW50ZXJmYWNlLFxuICBDdXN0b21FcnJvcixcbiAgRW50cnlQb2ludFR5cGUsXG4gIEdhdGV3YXlFcnJvcixcbiAgSHR0cEVycm9yLFxuICBMaWJyYXJ5RXJyb3IsXG4gIExpdGVyYWwsXG4gIFByb3ZpZGVyLFxuICBQcm92aWRlckludGVyZmFjZSxcbiAgcnBjX2V4cG9ydHMgYXMgUlBDLFxuICBScGNQcm92aWRlcixcbiAgU0lNVUxBVElPTl9GTEFHLFxuICBzZXF1ZW5jZXJfZXhwb3J0cyBhcyBTZXF1ZW5jZXIsXG4gIFNlcXVlbmNlclByb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50LFxuICBWYWxpZGF0ZVR5cGUsXG4gIGFkZEFkZHJlc3NQYWRkaW5nLFxuICBidWlsZFVybCxcbiAgY2Fpcm9fZXhwb3J0cyBhcyBjYWlybyxcbiAgY29uc3RhbnRzX2V4cG9ydHMgYXMgY29uc3RhbnRzLFxuICBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QsXG4gIGRlZmF1bHRQcm92aWRlcixcbiAgZWNfZXhwb3J0cyBhcyBlYyxcbiAgZW5jb2RlX2V4cG9ydHMgYXMgZW5jb2RlLFxuICBldmVudHNfZXhwb3J0cyBhcyBldmVudHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlcyxcbiAgZml4UHJvdG8sXG4gIGZpeFN0YWNrLFxuICBnZXRDYWxsZGF0YSxcbiAgZ2V0Q2hlY2tzdW1BZGRyZXNzLFxuICBnZXREZWZhdWx0Tm9kZVVybCxcbiAgaGFzaF9leHBvcnRzIGFzIGhhc2gsXG4gIGlzU2llcnJhLFxuICBpc1VybCxcbiAganNvbl9leHBvcnRzIGFzIGpzb24sXG4gIG1lcmtsZV9leHBvcnRzIGFzIG1lcmtsZSxcbiAgbnVtX2V4cG9ydHMgYXMgbnVtLFxuICBudW1iZXIsXG4gIHBhcnNlVURDRXZlbnQsXG4gIHByb3ZpZGVyX2V4cG9ydHMgYXMgcHJvdmlkZXIsXG4gIHNlbGVjdG9yX2V4cG9ydHMgYXMgc2VsZWN0b3IsXG4gIHNob3J0U3RyaW5nX2V4cG9ydHMgYXMgc2hvcnRTdHJpbmcsXG4gIHNwbGl0QXJnc0FuZE9wdGlvbnMsXG4gIHN0YXJrX2V4cG9ydHMgYXMgc3RhcmssXG4gIHN0YXJrbmV0SWRfZXhwb3J0cyBhcyBzdGFya25ldElkLFxuICB0cmFuc2FjdGlvbl9leHBvcnRzIGFzIHRyYW5zYWN0aW9uLFxuICB0eXBlZERhdGFfZXhwb3J0cyBhcyB0eXBlZERhdGEsXG4gIHR5cGVzX2V4cG9ydHMgYXMgdHlwZXMsXG4gIHVpbnQyNTZfZXhwb3J0cyBhcyB1aW50MjU2LFxuICB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyxcbiAgdmFsaWRhdGVDaGVja3N1bUFkZHJlc3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbnN0YW50c19leHBvcnRzIiwiQUREUl9CT1VORCIsIkFQSV9WRVJTSU9OIiwiQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSIsIkJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCYXNlVXJsIiwiSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiIsIklTX0JST1dTRVIiLCJNQVNLXzI1MCIsIk1BWF9TVE9SQUdFX0lURU1fU0laRSIsIk5ldHdvcmtOYW1lIiwiUlBDX0RFRkFVTFRfVkVSU0lPTiIsIlJQQ19OT0RFUyIsIlN0YXJrbmV0Q2hhaW5JZCIsIlRFWFRfVE9fRkVMVF9NQVhfTEVOIiwiVHJhbnNhY3Rpb25IYXNoUHJlZml4IiwiVURDIiwiWkVSTyIsImVuY29kZV9leHBvcnRzIiwiYWRkSGV4UHJlZml4IiwiYXJyYXlCdWZmZXJUb1N0cmluZyIsImF0b2JVbml2ZXJzYWwiLCJidG9hVW5pdmVyc2FsIiwiYnVmMmhleCIsImNhbGNCeXRlTGVuZ3RoIiwicGFkTGVmdCIsInBhc2NhbFRvU25ha2UiLCJyZW1vdmVIZXhQcmVmaXgiLCJzYW5pdGl6ZUJ5dGVzIiwic2FuaXRpemVIZXgiLCJzdHJpbmdUb0FycmF5QnVmZmVyIiwidXRmOFRvQXJyYXkiLCJiYXNlNjQiLCJTVFJJTkdfWkVSTyIsImFycmF5IiwiVWludDhBcnJheSIsInJlZHVjZSIsImRhdGEiLCJieXRlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJhIiwiZGVjb2RlIiwiYiIsImJ1ZmZlciIsInIiLCJ4IiwidG9TdHJpbmciLCJwYWRTdGFydCIsImhleCIsInJlcGxhY2UiLCJwYWRTdHJpbmciLCJsZW5ndGgiLCJsZWZ0IiwicGFkZGluZyIsImRpZmYiLCJyZXN1bHQiLCJwYWQiLCJyZXBlYXQiLCJieXRlU2l6ZSIsInJlbWFpbmRlciIsInRleHQiLCJ0ZXN0Iiwic3BsaXQiLCJqb2luIiwidG9VcHBlckNhc2UiLCJCYXNlVXJsMiIsIk5ldHdvcmtOYW1lMiIsIlN0YXJrbmV0Q2hhaW5JZDQiLCJUcmFuc2FjdGlvbkhhc2hQcmVmaXgyIiwiQUREUkVTUyIsIkVOVFJZUE9JTlQiLCJTTl9HT0VSTEkiLCJTTl9NQUlOIiwiU05fU0VQT0xJQSIsInR5cGVzX2V4cG9ydHMiLCJCbG9ja1N0YXR1cyIsIkJsb2NrVGFnIiwiRW50cnlQb2ludFR5cGUiLCJMaXRlcmFsIiwiUlBDIiwicnBjX2V4cG9ydHMiLCJTSU1VTEFUSU9OX0ZMQUciLCJTZXF1ZW5jZXIiLCJzZXF1ZW5jZXJfZXhwb3J0cyIsIlRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25UeXBlIiwiVHlwZWREYXRhUmV2aXNpb24iLCJVaW50IiwiVmFsaWRhdGVUeXBlIiwiU0lNVUxBVElPTl9GTEFHMiIsIlZhbGlkYXRlVHlwZTIiLCJVaW50MiIsIkxpdGVyYWwyIiwiRW50cnlQb2ludFR5cGUyIiwiVHJhbnNhY3Rpb25UeXBlMiIsIlRyYW5zYWN0aW9uU3RhdHVzMiIsIlRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyIiwiVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyIiwiQmxvY2tTdGF0dXMyIiwiQmxvY2tUYWcyIiwiVHlwZWREYXRhUmV2aXNpb24yIiwiRUJsb2NrVGFnIiwiRURhdGFBdmFpbGFiaWxpdHlNb2RlIiwiRVNpbXVsYXRpb25GbGFnIiwiRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMiLCJFVHJhbnNhY3Rpb25TdGF0dXMiLCJFVHJhbnNhY3Rpb25UeXBlIiwiRXJyb3JzIiwiZXJyb3JzX2V4cG9ydHMiLCJKUlBDIiwianNvbnJwY19leHBvcnRzIiwiU1BFQyIsImNvbXBvbmVudHNfZXhwb3J0cyIsIkVUcmFuc2FjdGlvblR5cGUyIiwiRVNpbXVsYXRpb25GbGFnMiIsIkVUcmFuc2FjdGlvblN0YXR1czIiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyIiwiRUJsb2NrVGFnMiIsIkVEYXRhQXZhaWxhYmlsaXR5TW9kZTIiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJudW1fZXhwb3J0cyIsImFzc2VydEluUmFuZ2UiLCJiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5IiwiYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkiLCJjbGVhbkhleCIsImdldERlY2ltYWxTdHJpbmciLCJnZXRIZXhTdHJpbmciLCJnZXRIZXhTdHJpbmdBcnJheSIsImhleFRvQnl0ZXMiLCJoZXhUb0RlY2ltYWxTdHJpbmciLCJpc0JpZ0ludCIsImlzSGV4IiwiaXNTdHJpbmdXaG9sZU51bWJlciIsInRvQmlnSW50IiwidG9DYWlyb0Jvb2wiLCJ0b0hleCIsInRvSGV4U3RyaW5nIiwidG9TdG9yYWdlS2V5IiwiaGV4VG9CeXRlc05vYmxlIiwidmFsdWUiLCJCaWdJbnQiLCJudW1iZXIyIiwicmVzIiwidG9Mb3dlckNhc2UiLCJpbnB1dCIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaW5wdXROYW1lIiwibWVzc2FnZVN1ZmZpeCIsImlucHV0QmlnSW50IiwibG93ZXJCb3VuZEJpZ0ludCIsInVwcGVyQm91bmRCaWdJbnQiLCJyYXdDYWxsZGF0YSIsIm1hcCIsImVsIiwiYWRhcHRlZFZhbHVlIiwic2VsZWN0b3JfZXhwb3J0cyIsImdldFNlbGVjdG9yIiwiZ2V0U2VsZWN0b3JGcm9tTmFtZSIsImtlY2Nha0JuIiwic3RhcmtuZXRLZWNjYWsiLCJrZWNjYWsiLCJoZXhXaXRob3V0UHJlZml4IiwiZXZlbkhleCIsImtlY2Nha0hleCIsImhhc2giLCJmdW5jTmFtZSIsInNob3J0U3RyaW5nX2V4cG9ydHMiLCJkZWNvZGVTaG9ydFN0cmluZyIsImVuY29kZVNob3J0U3RyaW5nIiwiaXNBU0NJSSIsImlzRGVjaW1hbFN0cmluZyIsImlzTG9uZ1RleHQiLCJpc1Nob3J0U3RyaW5nIiwiaXNTaG9ydFRleHQiLCJpc1RleHQiLCJzcGxpdExvbmdTdHJpbmciLCJ2YWwiLCJsb25nU3RyIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImNoYXIiLCJjaGFyQ29kZUF0IiwicGFyc2VJbnQiLCJjb25jYXQiLCJjYWlyb19leHBvcnRzIiwiZmVsdCIsImdldEFiaUNvbnRyYWN0VmVyc2lvbiIsImdldEFycmF5VHlwZSIsImlzQ2Fpcm8xQWJpIiwiaXNDYWlybzFUeXBlIiwiaXNMZW4iLCJpc1R5cGVBcnJheSIsImlzVHlwZUJvb2wiLCJpc1R5cGVDb250cmFjdEFkZHJlc3MiLCJpc1R5cGVFbnVtIiwiaXNUeXBlRXRoQWRkcmVzcyIsImlzVHlwZUZlbHQiLCJpc1R5cGVMaXRlcmFsIiwiaXNUeXBlTmFtZWRUdXBsZSIsImlzVHlwZU9wdGlvbiIsImlzVHlwZVJlc3VsdCIsImlzVHlwZVN0cnVjdCIsImlzVHlwZVR1cGxlIiwiaXNUeXBlVWludCIsImlzVHlwZVVpbnQyNTYiLCJ0dXBsZSIsInVpbnQyNTYiLCJ1aW50MjU2X2V4cG9ydHMiLCJVSU5UXzEyOF9NQVgiLCJVSU5UXzI1Nl9NQVgiLCJiblRvVWludDI1NiIsImlzVWludDI1NiIsInVpbnQyNTZUb0JOIiwidWludDI1NjIiLCJoaWdoIiwibG93IiwiYm4iLCJiaSIsInR5cGUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJzdHJ1Y3RzIiwiZW51bXMiLCJ2YWx1ZXMiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJhYmkiLCJjYWlybyIsImZpbmQiLCJpdCIsImNvbXBpbGVyIiwidGVzdEZ1bmN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsImlvIiwiYXJncyIsIk51bWJlciIsImlzSW50ZWdlciIsImVuY29kZWQiLCJDYWlyb0N1c3RvbUVudW0iLCJjb25zdHJ1Y3RvciIsImVudW1Db250ZW50IiwidmFyaWFudHNMaXN0IiwibmJBY3RpdmVWYXJpYW50cyIsImZpbHRlciIsImNvbnRlbnQiLCJ2YXJpYW50IiwidW53cmFwIiwidmFyaWFudHMiLCJlbnRyaWVzIiwiYWN0aXZlVmFyaWFudCIsIml0ZW0iLCJDYWlyb09wdGlvblZhcmlhbnQiLCJDYWlyb09wdGlvblZhcmlhbnQyIiwiQ2Fpcm9PcHRpb24iLCJzb21lQ29udGVudCIsIlNvbWUiLCJOb25lIiwiaXNTb21lIiwiaXNOb25lIiwiQ2Fpcm9SZXN1bHRWYXJpYW50IiwiQ2Fpcm9SZXN1bHRWYXJpYW50MiIsIkNhaXJvUmVzdWx0IiwicmVzdWx0Q29udGVudCIsIk9rIiwiRXJyIiwiaXNPayIsImlzRXJyIiwiZ3VhcmQiLCJpc0JOIiwia2V5IiwidW5rbm93biIsImZvcm1hdHRlciIsInNhbWVUeXBlIiwiYWNjIiwiZWxUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlTdHIiLCJfIiwiYXJyYXlPYmoiLCJBYmlQYXJzZXIxIiwibWV0aG9kSW5wdXRzTGVuZ3RoIiwiYWJpTWV0aG9kIiwiZ2V0TWV0aG9kIiwiZ2V0TGVnYWN5Rm9ybWF0IiwiQWJpUGFyc2VyMiIsImludGYiLCJpdGVtcyIsImZsYXRNYXAiLCJlIiwiY3JlYXRlQWJpUGFyc2VyIiwidmVyc2lvbiIsImdldEFiaVZlcnNpb24iLCJpc05vQ29uc3RydWN0b3JWYWxpZCIsIm1ldGhvZCIsImFyZ3NDYWxsZGF0YSIsInBhcnNlTmFtZWRUdXBsZSIsIm5hbWVkVHVwbGUiLCJwYXJzZVN1YlR1cGxlIiwicyIsInN1YlR1cGxlIiwiaSIsImNvdW50ZXIiLCJsQnJhY2tldCIsInB1c2giLCJleHRyYWN0Q2Fpcm8wVHVwbGUiLCJjbGVhblR5cGUiLCJzbGljZSIsInJlY29tcG9zZWQiLCJzaGlmdCIsImV4dHJhY3RDYWlybzFUdXBsZSIsImV4dHJhY3RUdXBsZU1lbWJlclR5cGVzIiwiZXJyb3JVMjU2Iiwib3JkZXJQcm9wc0J5QWJpIiwidW5vcmRlcmVkT2JqZWN0IiwiYWJpT2ZPYmplY3QiLCJvcmRlcklucHV0IiwidW5vcmRlcmVkSXRlbSIsImFiaVR5cGUiLCJvcmRlckFycmF5IiwiYWJpT2JqIiwib3JkZXJFbnVtIiwib3JkZXJUdXBsZSIsInUyNTYiLCJhYmlPZlN0cnVjdCIsIm1lbWJlcnMiLCJvcmRlclN0cnVjdCIsInVub3JkZXJlZE9iamVjdDIiLCJhYmlPYmplY3QiLCJvcmRlcmVkT2JqZWN0MiIsIm9yZGVyZWRPYmplY3QiLCJhYmlQYXJhbSIsInNldFByb3BlcnR5IiwibXlBcnJheSIsInR5cGVJbkFycmF5IiwibXlFbGVtIiwidHlwZUxpc3QiLCJhYmlUeXBlQ2Fpcm9YIiwiaW5kZXgiLCJteU9iaktleXMiLCJrZXlzIiwidW5vcmRlcmVkUmVzdWx0IiwicmVzdWx0T2tUeXBlIiwicmVzdWx0RXJyVHlwZSIsInVub3JkZXJlZE9wdGlvbiIsInJlc3VsdFNvbWVUeXBlIiwidW5vcmRlcmVkQ3VzdG9tRW51bSIsIm5ld0VudHJpZXMiLCJ2YXJpYW50VHlwZSIsImZyb21FbnRyaWVzIiwiZmluYWxPcmRlcmVkT2JqZWN0IiwicGFyc2VCYXNlVHlwZXMiLCJlbF91aW50MjU2IiwicGFyc2VUdXBsZSIsImVsZW1lbnQiLCJ0eXBlU3RyIiwibWVtYmVyVHlwZXMiLCJlbGVtZW50cyIsImR4IiwicGFyc2VVaW50MjU2IiwicGFyc2VDYWxsZGF0YVZhbHVlIiwiYXJyYXlUeXBlIiwic3ViRWxlbWVudCIsInR1cGxlZCIsInBhcnNlZERhdGEiLCJteU9wdGlvbiIsImxpc3RUeXBlVmFyaWFudDIiLCJ0eXBlVmFyaWFudFNvbWUiLCJwYXJzZWRQYXJhbWV0ZXIyIiwibXlSZXN1bHQiLCJsaXN0VHlwZVZhcmlhbnQzIiwidHlwZVZhcmlhbnRPayIsInBhcnNlZFBhcmFtZXRlcjMiLCJ0eXBlVmFyaWFudEVyciIsIm15RW51bSIsImxpc3RUeXBlVmFyaWFudCIsInR5cGVBY3RpdmVWYXJpYW50IiwibnVtQWN0aXZlVmFyaWFudCIsImZpbmRJbmRleCIsInBhcnNlZFBhcmFtZXRlciIsInBhcnNlQ2FsbGRhdGFGaWVsZCIsImFyZ3NJdGVyYXRvciIsIm5leHQiLCJwYXJzZUJhc2VUeXBlczIiLCJ0ZW1wIiwiQm9vbGVhbiIsInBhcnNlUmVzcG9uc2VWYWx1ZSIsInJlc3BvbnNlSXRlcmF0b3IiLCJwYXJzZWREYXRhQXJyIiwibGVuIiwidmFyaWFudE51bSIsInJhd0VudW0iLCJudW0iLCJjdXN0b21FbnVtIiwiaWR4IiwicmVzcG9uc2VQYXJzZXIiLCJvdXRwdXQiLCJwYXJzZWRSZXN1bHQiLCJhcnJMZW4iLCJ2YWxpZGF0ZUZlbHQiLCJwYXJhbWV0ZXIiLCJwYXJhbSIsInZhbGlkYXRlVWludCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ2YWxpZGF0ZUJvb2wiLCJ2YWxpZGF0ZVN0cnVjdCIsImZvckVhY2giLCJ2YWxpZGF0ZUVudW0iLCJtZXRob2RzS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsInZhbGlkYXRlVHVwbGUiLCJ2YWxpZGF0ZUFycmF5IiwiYmFzZVR5cGUiLCJ2YWxpZGF0ZUZpZWxkcyIsIkNhbGxEYXRhIiwiZ2V0QWJpU3RydWN0IiwiZ2V0QWJpRW51bSIsInBhcnNlciIsInZhbGlkYXRlIiwiaW52b2NhYmxlRnVuY3Rpb25OYW1lcyIsImlzVmlldyIsInN0YXRlTXV0YWJpbGl0eSIsInN0YXRlX211dGFiaWxpdHkiLCJpbnB1dHNMZW5ndGgiLCJjb21waWxlIiwiYWJpRnVuY3Rpb24iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNhbGxBcnJheSIsIndyaXRhYmxlIiwicmF3QXJncyIsImNyZWF0ZVRyZWUiLCJvYmoiLCJnZXRFbnRyaWVzIiwibyIsInByZWZpeCIsIm9lIiwiayIsInYiLCJrayIsInZhcmlhbnROYiIsImxpc3RWYXJpYW50cyIsImFjdGl2ZVZhcmlhbnROYiIsImNhbGxUcmVlQXJyYXkiLCJjYWxsVHJlZSIsImNhbGxPYmoiLCJwYXJzZSIsInJlc3BvbnNlIiwiZmxhdCIsInBhcnNlZCIsInByb3BOYW1lIiwiZm9ybWF0IiwiYWJpRW50cnkiLCJmdWxsRW51bUxpc3QiLCJ0b0NhbGxkYXRhIiwicmF3IiwiY2FsbGRhdGEiLCJkZWNvZGVQYXJhbWV0ZXJzIiwidHlwZUNhaXJvIiwidHlwZUNhaXJvQXJyYXkiLCJkZWNvZGVkQXJyYXkiLCJ0eXBlUGFyYW0iLCJoYXNoX2V4cG9ydHMiLCJjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCIsImNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uIiwiY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoIiwiY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoIiwiY29tcHV0ZUhhc2hPbkVsZW1lbnRzIiwiY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoIiwiY29tcHV0ZVBlZGVyc2VuSGFzaCIsImNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzIiwiY29tcHV0ZVBvc2VpZG9uSGFzaCIsImNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzIiwiY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoIiwiZGVmYXVsdCIsImNvbXB1dGVIaW50ZWRDbGFzc0hhc2giLCJmZWVUcmFuc2FjdGlvblZlcnNpb24iLCJmZWVUcmFuc2FjdGlvblZlcnNpb25fMiIsImZvcm1hdFNwYWNlcyIsImdldFZlcnNpb25zQnlUeXBlIiwicG9zZWlkb24iLCJ0cmFuc2FjdGlvblZlcnNpb24iLCJ0cmFuc2FjdGlvblZlcnNpb25fMiIsInBvc2VpZG9uSGFzaE1hbnkiLCJlY19leHBvcnRzIiwic3RhcmtDdXJ2ZSIsIndlaWVyc3RyYXNzIiwianNvbl9leHBvcnRzIiwicGFyc2UyIiwicGFyc2VBbHdheXNBc0JpZyIsInN0cmluZ2lmeSIsInN0cmluZ2lmeTIiLCJzdHJpbmdpZnlBbHdheXNBc0JpZyIsImpzb24iLCJwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQiLCJwYXJzZUZsb2F0IiwiaXNTYWZlSW50ZWdlciIsInBhcnNlTnVtYmVyQW5kQmlnSW50IiwicmVwbGFjZXIiLCJzcGFjZSIsIm51bWJlclN0cmluZ2lmaWVycyIsInZlcnNpb25UeXBlIiwidjEiLCJ2MiIsInBlZGVyc2VuIiwicG9zZWlkb25IYXNoIiwieSIsInR4SGFzaFByZWZpeCIsImNvbnRyYWN0QWRkcmVzcyIsImVudHJ5UG9pbnRTZWxlY3RvciIsIm1heEZlZSIsImNoYWluSWQiLCJhZGRpdGlvbmFsRGF0YSIsImNhbGxkYXRhSGFzaCIsImRhdGFUb0hhc2giLCJjb25zdHJ1Y3RvckNhbGxkYXRhIiwiY29uc3RydWN0b3JOYW1lIiwiY2xhc3NIYXNoIiwic2VuZGVyQWRkcmVzcyIsIm5vbmNlIiwiY29tcGlsZWRDbGFzc0hhc2giLCJzYWx0IiwiZGVwbG95ZXJBZGRyZXNzIiwiY29tcGlsZWRDYWxsZGF0YSIsImNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoIiwiQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgiLCJudWxsU2tpcFJlcGxhY2VyIiwianNvbjIiLCJpbnNpZGVRdW90ZXMiLCJuZXdTdHJpbmciLCJjb21waWxlZENvbnRyYWN0IiwicHJvZ3JhbSIsImNvbnRyYWN0Q2xhc3MiLCJzZXJpYWxpemVkSnNvbiIsImNvbnRyYWN0IiwiYXBpVmVyc2lvbiIsImV4dGVybmFsRW50cnlQb2ludHNIYXNoIiwiZW50cnlfcG9pbnRzX2J5X3R5cGUiLCJFWFRFUk5BTCIsInNlbGVjdG9yIiwib2Zmc2V0IiwibDFIYW5kbGVyRW50cnlQb2ludHNIYXNoIiwiTDFfSEFORExFUiIsImNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2giLCJDT05TVFJVQ1RPUiIsImJ1aWx0aW5zSGFzaCIsImJ1aWx0aW5zIiwiaGludGVkQ2xhc3NIYXNoIiwiZGF0YUhhc2giLCJoYXNoQnVpbHRpbnMiLCJoYXNoRW50cnlQb2ludCIsImJhc2UiLCJjYXNtIiwiQ09NUElMRURfQ0xBU1NfVkVSU0lPTiIsImNvbXBpbGVkQ2xhc3NWZXJzaW9uIiwibDFIYW5kbGVycyIsImJ5dGVjb2RlIiwiaGFzaEVudHJ5UG9pbnRTaWVycmEiLCJmdW5jdGlvbl9pZHgiLCJoYXNoQWJpIiwic2llcnJhIiwiaW5kZW50U3RyaW5nIiwiQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTiIsImFiaUhhc2giLCJzaWVycmFQcm9ncmFtIiwic2llcnJhX3Byb2dyYW0iLCJzdGFya19leHBvcnRzIiwiY29tcHJlc3NQcm9ncmFtIiwiZGVjb21wcmVzc1Byb2dyYW0iLCJlc3RpbWF0ZWRGZWVUb01heEZlZSIsImZvcm1hdFNpZ25hdHVyZSIsIm1ha2VBZGRyZXNzIiwicmFuZG9tQWRkcmVzcyIsInNpZ25hdHVyZVRvRGVjaW1hbEFycmF5Iiwic2lnbmF0dXJlVG9IZXhBcnJheSIsImdldFN0YXJrS2V5IiwidXRpbHMiLCJnemlwIiwidW5nemlwIiwianNvblByb2dyYW0iLCJzdHJpbmdpZmllZCIsImNvbXByZXNzZWRQcm9ncmFtIiwiYmFzZTY0MiIsImRlY29tcHJlc3NlZCIsInJhbmRvbUtleVBhaXIiLCJyYW5kb21Qcml2YXRlS2V5Iiwic2lnIiwiZXN0aW1hdGVkRmVlIiwib3ZlcmhlYWQiLCJvdmVySGVhZFBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJpc1NpZXJyYSIsImV4dHJhY3RDb250cmFjdEhhc2hlcyIsInBheWxvYWQiLCJjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QiLCJjY3IiLCJpc29tb3JwaGljRmV0Y2giLCJmZXRjaFBvbnlmaWxsX2RlZmF1bHQiLCJ3aW5kb3ciLCJmZXRjaCIsImdsb2JhbCIsInByb3ZpZGVyX2V4cG9ydHMiLCJjcmVhdGVTaWVycmFDb250cmFjdENsYXNzIiwicGFyc2VDb250cmFjdCIsIndhaXQiLCJkZWxheSIsIlByb21pc2UiLCJzZXRUaW1lb3V0Iiwic2llcnJhX3Byb2dyYW1fZGVidWdfaW5mbyIsInBhcnNlZENvbnRyYWN0IiwiUlBDUmVzcG9uc2VQYXJzZXIiLCJwYXJzZUdldEJsb2NrUmVzcG9uc2UiLCJ0aW1lc3RhbXAiLCJibG9ja19oYXNoIiwiYmxvY2tfbnVtYmVyIiwibmV3X3Jvb3QiLCJwYXJlbnRfaGFzaCIsInN0YXR1cyIsInRyYW5zYWN0aW9ucyIsInBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZSIsImNvbnRyYWN0X2FkZHJlc3MiLCJzZW5kZXJfYWRkcmVzcyIsIm1heF9mZWUiLCJzaWduYXR1cmUiLCJ0cmFuc2FjdGlvbl9oYXNoIiwicGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlIiwib3ZlcmFsbF9mZWUiLCJnYXNfY29uc3VtZWQiLCJnYXNfcHJpY2UiLCJwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlIiwicGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZSIsInBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlIiwic3VnZ2VzdGVkTWF4RmVlIiwiZmVlX2VzdGltYXRpb24iLCJwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSIsIkpTT04iLCJmaXhTdGFjayIsImZuIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJmaXhQcm90byIsInByb3RvdHlwZSIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ3VzdG9tRXJyb3IiLCJjb25maWd1cmFibGUiLCJMaWJyYXJ5RXJyb3IiLCJHYXRld2F5RXJyb3IiLCJlcnJvckNvZGUiLCJIdHRwRXJyb3IiLCJzdGFya25ldElkX2V4cG9ydHMiLCJTdGFya25ldElkQ29udHJhY3QiLCJnZXRTdGFya25ldElkQ29udHJhY3QiLCJ1c2VEZWNvZGVkIiwidXNlRW5jb2RlZCIsImJhc2ljQWxwaGFiZXQiLCJiYXNpY1NpemVQbHVzT25lIiwiYmlnQWxwaGFiZXQiLCJiYXNpY0FscGhhYmV0U2l6ZSIsImJpZ0FscGhhYmV0U2l6ZSIsImJpZ0FscGhhYmV0U2l6ZVBsdXNPbmUiLCJleHRyYWN0U3RhcnMiLCJlbmRzV2l0aCIsImRlY29kZWQiLCJzdWJkb21haW4iLCJjb2RlIiwibmV4dFN1YmRvbWFpbiIsImNvZGUyIiwibXVsdGlwbGllciIsImJuSW5kZXgiLCJuZXdpZCIsIlN0YXJrbmV0SWRDb250cmFjdDIiLCJnZXRTdGFya05hbWUiLCJwcm92aWRlciIsImFkZHJlc3MiLCJnZXRDaGFpbklkIiwiaGV4RG9tYWluIiwiY2FsbENvbnRyYWN0IiwiZW50cnlwb2ludCIsImRlY2ltYWxEb21haW4iLCJzdHJpbmdEb21haW4iLCJnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSIsImFkZHJlc3NEYXRhIiwiZG9tYWluIiwidmFsaWRCbG9ja1RhZ3MiLCJCbG9jayIsInNldElkZW50aWZpZXIiLCJfX2lkZW50aWZpZXIiLCJudW1iZXIiLCJ0YWciLCJfaWRlbnRpZmllciIsInZhbHVlT2YiLCJxdWVyeUlkZW50aWZpZXIiLCJpZGVudGlmaWVyIiwic2VxdWVuY2VySWRlbnRpZmllciIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwiZ2V0RGVmYXVsdE5vZGVVcmwiLCJuZXR3b3JrTmFtZSIsIm11dGUiLCJjb25zb2xlIiwid2FybiIsIm5vZGVzIiwicmFuZElkeCIsImZsb29yIiwicmFuZG9tIiwiZGVmYXVsdE9wdGlvbnMiLCJoZWFkZXJzIiwiYmxvY2tJZGVudGlmaWVyIiwicmV0cmllcyIsIlJwY1Byb3ZpZGVyIiwib3B0aW9uc09yUHJvdmlkZXIiLCJnZXRCbG9ja0hhc2hBbmROdW1iZXIiLCJnZXRCbG9ja0xhdGVzdEFjY2VwdGVkIiwiZ2V0U3RhdGVVcGRhdGUiLCJnZXRCbG9ja1N0YXRlVXBkYXRlIiwidHJhY2VCbG9ja1RyYW5zYWN0aW9ucyIsImdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCIsInRyYWNlVHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblRyYWNlIiwiZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJub2RlVXJsIiwicnBjVmVyc2lvbiIsInBhcmFtcyIsImlkIiwicnBjUmVxdWVzdEJvZHkiLCJqc29ucnBjIiwiYm9keSIsImVycm9ySGFuZGxlciIsInJwY0Vycm9yIiwib3RoZXJFcnJvciIsImZldGNoRW5kcG9pbnQiLCJyYXdSZXN1bHQiLCJlcnJvciIsImdldFNwZWNWZXJzaW9uIiwiZ2V0Tm9uY2VGb3JBZGRyZXNzIiwiYmxvY2tfaWQiLCJnZXRCbG9jayIsImdldEJsb2NrV2l0aFR4SGFzaGVzIiwidGhlbiIsImdldEJsb2NrTnVtYmVyIiwiZ2V0QmxvY2tXaXRoVHhzIiwiZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9uQnlIYXNoIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0eEhhc2giLCJnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4IiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiZ2V0VHJhbnNhY3Rpb25TdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJpbnZvY2F0aW9ucyIsInNraXBWYWxpZGF0ZSIsInNraXBGZWVDaGFyZ2UiLCJzaW11bGF0aW9uRmxhZ3MiLCJTS0lQX1ZBTElEQVRFIiwiU0tJUF9GRUVfQ0hBUkdFIiwiYnVpbGRUcmFuc2FjdGlvbiIsInNpbXVsYXRpb25fZmxhZ3MiLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJvcHRpb25zIiwib25jaGFpbiIsImlzRXJyb3JTdGF0ZSIsInJldHJ5SW50ZXJ2YWwiLCJlcnJvclN0YXRlcyIsIlJFSkVDVEVEIiwic3VjY2Vzc1N0YXRlcyIsIlNVQ0NFRURFRCIsIkFDQ0VQVEVEX09OX0wyIiwiQUNDRVBURURfT05fTDEiLCJ0eFN0YXR1cyIsImV4ZWN1dGlvblN0YXR1cyIsImV4ZWN1dGlvbl9zdGF0dXMiLCJmaW5hbGl0eVN0YXR1cyIsImZpbmFsaXR5X3N0YXR1cyIsInR4UmVjZWlwdCIsImdldFN0b3JhZ2VBdCIsInBhcnNlZEtleSIsImdldENsYXNzSGFzaEF0IiwiZ2V0Q2xhc3NCeUhhc2giLCJnZXRDbGFzcyIsImNsYXNzX2hhc2giLCJnZXRDbGFzc0F0IiwiZ2V0Q29kZSIsIl9jb250cmFjdEFkZHJlc3MiLCJfYmxvY2tJZGVudGlmaWVyIiwiZ2V0Q29udHJhY3RWZXJzaW9uIiwiYWJpVGVzdCIsImdldEVzdGltYXRlRmVlIiwiaW52b2NhdGlvbiIsImludm9jYXRpb25EZXRhaWxzIiwiZ2V0SW52b2tlRXN0aW1hdGVGZWUiLCJ0cmFuc2FjdGlvbiIsInJlcXVlc3QiLCJnZXREZWNsYXJlRXN0aW1hdGVGZWUiLCJkZXRhaWxzIiwiZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlIiwiZ2V0RXN0aW1hdGVGZWVCdWxrIiwiaW52b2tlRnVuY3Rpb24iLCJmdW5jdGlvbkludm9jYXRpb24iLCJpbnZva2VfdHJhbnNhY3Rpb24iLCJJTlZPS0UiLCJkZWNsYXJlQ29udHJhY3QiLCJkZWNsYXJlX3RyYW5zYWN0aW9uIiwiREVDTEFSRSIsImNvbnRyYWN0X2NsYXNzIiwiY29udHJhY3RfY2xhc3NfdmVyc2lvbiIsImNvbXBpbGVkX2NsYXNzX2hhc2giLCJkZXBsb3lBY2NvdW50Q29udHJhY3QiLCJhZGRyZXNzU2FsdCIsImRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uIiwiY29uc3RydWN0b3JfY2FsbGRhdGEiLCJjb250cmFjdF9hZGRyZXNzX3NhbHQiLCJERVBMT1lfQUNDT1VOVCIsImNhbGwiLCJlbnRyeV9wb2ludF9zZWxlY3RvciIsImVzdGltYXRlTWVzc2FnZUZlZSIsImZyb21fYWRkcmVzcyIsInRvX2FkZHJlc3MiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZ2V0U3luY2luZ1N0YXRzIiwiZ2V0RXZlbnRzIiwiZXZlbnRGaWx0ZXIiLCJkZWZhdWx0VmVyc2lvbnMiLCJ1cmxqb2luMiIsIlJlc3BvbnNlUGFyc2VyIiwiU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIiLCJzdGF0ZV9yb290IiwicGFyZW50X2Jsb2NrX2hhc2giLCJwYXJzZUdldFRyYW5zYWN0aW9uUmVjZWlwdFJlc3BvbnNlIiwibWVzc2FnZXNfc2VudCIsImwyX3RvX2wxX21lc3NhZ2VzIiwicmV2ZXJ0X3JlYXNvbiIsInJldmVydF9lcnJvciIsImdhc0luZm8iLCJnYXNfdXNhZ2UiLCJhbW91bnQiLCJ0cmFuc2FjdGlvbl90cmFjZSIsInRyYWNlIiwicGFyc2VJbnZva2VGdW5jdGlvblJlc3BvbnNlIiwicGFyc2VEZXBsb3lDb250cmFjdFJlc3BvbnNlIiwicGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZSIsInBhcnNlR2V0U3RhdGVVcGRhdGVSZXNwb25zZSIsIm5vbmNlcyIsInN0YXRlX2RpZmYiLCJzdG9yYWdlX2RpZmZzIiwic3RvcmFnZV9lbnRyaWVzIiwidXJsam9pbiIsInByb3RvY29sQW5kRG9tYWluUkUiLCJsb2NhbGhvc3REb21haW5SRSIsIm5vbkxvY2FsaG9zdERvbWFpblJFIiwiaXNVcmwiLCJldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCIsImJ1aWxkVXJsIiwiYmFzZVVybCIsImRlZmF1bHRQYXRoIiwidXJsT3JQYXRoIiwiaXNFbXB0eVF1ZXJ5T2JqZWN0IiwiZXZlcnkiLCJkZWZhdWx0T3B0aW9uczIiLCJuZXR3b3JrIiwiU2VxdWVuY2VyUHJvdmlkZXIiLCJnZXROZXR3b3JrRnJvbU5hbWUiLCJmZWVkZXJHYXRld2F5VXJsIiwiZ2F0ZXdheVVybCIsImdldENoYWluSWRGcm9tQmFzZVVybCIsInVybCIsIlVSTCIsImhvc3QiLCJnZXRGZXRjaFVybCIsImVuZHBvaW50IiwiZ2F0ZXdheVVybEVuZHBvaW50cyIsImdldEZldGNoTWV0aG9kIiwicG9zdE1ldGhvZEVuZHBvaW50cyIsImdldFF1ZXJ5U3RyaW5nIiwicXVlcnkiLCJxdWVyeVN0cmluZyIsImJsb2NrIiwiZ2V0SGVhZGVycyIsInRleHRSZXNwb25zZSIsIm9rIiwicmVzcG9uc2VCb2R5Iiwic3RhdHVzVGV4dCIsInBhcnNlQ2hvaWNlIiwicGFyc2VBbHdheXNBc0JpZ0ludCIsInJlc29sdmUiLCJ0eEhhc2hIZXgiLCJnZXRDb21waWxlZENsYXNzQnlDbGFzc0hhc2giLCJjb21wbGV0ZWQiLCJ0eF9mYWlsdXJlX3JlYXNvbiIsInR4X3N0YXR1cyIsImVycm9yX21lc3NhZ2UiLCJ0eF9yZXZlcnRfcmVhc29uIiwiZ2V0Q29udHJhY3RBZGRyZXNzZXMiLCJ2YWxpZENhbGxMMUhhbmRsZXIiLCJza2lwRXhlY3V0ZSIsImdldEJsb2NrVHJhY2VzIiwiUHJvdmlkZXIiLCJwcm92aWRlck9yT3B0aW9ucyIsInJwYyIsInNlcXVlbmNlciIsImludm9jYXRpb25XaXRoVHhUeXBlIiwiU2lnbmVySW50ZXJmYWNlIiwidHJhbnNhY3Rpb25fZXhwb3J0cyIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2UiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEiLCJnZXRFeGVjdXRlQ2FsbGRhdGEiLCJ0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzIiwidHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEiLCJjYWxscyIsInRvIiwiZGF0YV9vZmZzZXQiLCJkYXRhX2xlbiIsImNvbXBpbGVkQ2FsbHMiLCJvcmRlckNhbGxzIiwiY2Fpcm9WZXJzaW9uIiwidHlwZWREYXRhX2V4cG9ydHMiLCJieXRlQXJyYXlGcm9tU3RyaW5nIiwiZW5jb2RlRGF0YSIsImVuY29kZVR5cGUiLCJlbmNvZGVWYWx1ZSIsImdldERlcGVuZGVuY2llcyIsImdldE1lc3NhZ2VIYXNoIiwiZ2V0U3RydWN0SGFzaCIsImdldFR5cGVIYXNoIiwiaXNNZXJrbGVUcmVlVHlwZSIsInByZXBhcmVTZWxlY3RvciIsIm1lcmtsZV9leHBvcnRzIiwiTWVya2xlVHJlZSIsInByb29mTWVya2xlUGF0aCIsImxlYWZIYXNoZXMiLCJoYXNoTWV0aG9kIiwiYnJhbmNoZXMiLCJsZWF2ZXMiLCJyb290IiwiYnVpbGQiLCJuZXdMZWF2ZXMiLCJhU29ydGVkIiwiYlNvcnRlZCIsInNvcnQiLCJnZXRQcm9vZiIsImxlYWYiLCJicmFuY2giLCJoYXNoUGF0aCIsImlzTGVmdCIsIm5lZWRlZEJyYW5jaCIsIm5ld0hhc2hQYXRoIiwiY3VycmVudEJyYW5jaExldmVsSW5kZXgiLCJuZXh0QnJhbmNoIiwicGF0aCIsInJlc3QiLCJwcmVzZXRUeXBlcyIsIlRva2VuQW1vdW50IiwiTmZ0SWQiLCJyZXZpc2lvbkNvbmZpZ3VyYXRpb24iLCJoYXNoTWVya2xlTWV0aG9kIiwiZXNjYXBlVHlwZVN0cmluZyIsInRhcmdldFN0cmluZyIsInNob3J0U3RyaW5ncyIsInNob3J0U3RyaW5nc0VuY29kZWQiLCJwZW5kaW5nV29yZCIsInBlbmRpbmdXb3JkTGVuZ3RoIiwicG9wIiwicGVuZGluZ193b3JkIiwicGVuZGluZ193b3JkX2xlbiIsImlkZW50aWZ5UmV2aXNpb24iLCJ0eXBlcyIsInJldmlzaW9uIiwiZ2V0SGV4IiwidmFsaWRhdGVUeXBlZERhdGEiLCJ0eXBlZERhdGEiLCJwcmltYXJ5VHlwZSIsImRlcGVuZGVuY2llcyIsImNvbnRhaW5zIiwicHJldmlvdXMiLCJ0IiwiZGVwZW5kZW5jeSIsImdldE1lcmtsZVRyZWVUeXBlIiwiY3R4IiwicGFyZW50IiwicGFyZW50VHlwZSIsIm1lcmtsZVR5cGUiLCJpc01lcmtsZVRyZWUiLCJwcmltYXJ5IiwibmV3VHlwZXMiLCJlc2MiLCJkZXBlbmRlbmN5RWxlbWVudHMiLCJ0YXJnZXRUeXBlIiwidHlwZVN0cmluZyIsImhhc2hlcyIsImVudHJ5IiwidmFyaWFudEtleSIsInZhcmlhbnREYXRhIiwiZW51bVR5cGUiLCJ2YXJpYW50SW5kZXgiLCJlbmNvZGVkU3VidHlwZXMiLCJzdWJ0eXBlIiwic3VidHlwZURhdGEiLCJtZXJrbGVUcmVlVHlwZSIsInN0cnVjdEhhc2hlcyIsInN0cnVjdCIsImJ5dGVBcnJheSIsInJldHVyblR5cGVzIiwidHMiLCJ2cyIsImZpZWxkIiwiZW5jb2RlZFZhbHVlIiwiYWNjb3VudCIsIlNpZ25lciIsInBrIiwiZ2V0UHViS2V5Iiwic2lnbk1lc3NhZ2UiLCJhY2NvdW50QWRkcmVzcyIsIm1zZ0hhc2giLCJzaWduIiwic2lnblRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zRGV0YWlsIiwiYWJpcyIsIndhbGxldEFkZHJlc3MiLCJzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIiwic2lnbkRlY2xhcmVUcmFuc2FjdGlvbiIsInBhcnNlVURDRXZlbnQiLCJldmVudHMiLCJldmVudCIsImRlcGxveWVyIiwidW5pcXVlIiwiY2FsbGRhdGFfbGVuIiwiQWNjb3VudCIsInBrT3JTaWduZXIiLCJkZXBsb3lTZWxmIiwiZGVwbG95QWNjb3VudCIsInNpZ25lciIsImdldE5vbmNlIiwiZ2V0Tm9uY2VTYWZlIiwiZ2V0Q2Fpcm9WZXJzaW9uIiwiZXN0aW1hdGVGZWUiLCJlc3RpbWF0ZUZlZURldGFpbHMiLCJlc3RpbWF0ZUludm9rZUZlZSIsInByb3ZpZGVkTm9uY2UiLCJzaWduZXJEZXRhaWxzIiwiYnVpbGRJbnZvY2F0aW9uIiwiZXN0aW1hdGVEZWNsYXJlRmVlIiwicHJvdmlkZWRDbGFzc0hhc2giLCJkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiIsImJ1aWxkRGVjbGFyZVBheWxvYWQiLCJlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUiLCJwcm92aWRlZENvbnRyYWN0QWRkcmVzcyIsImJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQiLCJlc3RpbWF0ZURlcGxveUZlZSIsImJ1aWxkVURDQ29udHJhY3RQYXlsb2FkIiwiZXN0aW1hdGVGZWVCdWxrIiwiYWNjb3VudEludm9jYXRpb25zIiwiYWNjb3VudEludm9jYXRpb25zRmFjdG9yeSIsInZlcnNpb25zIiwiZWxlbSIsImV4ZWN1dGUiLCJnZXRTdWdnZXN0ZWRNYXhGZWUiLCJkZWNsYXJlSWZOb3QiLCJkZWNsYXJlQ29udHJhY3RQYXlsb2FkIiwiZGVjbGFyZSIsImRlcGxveSIsImNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSIsImRlcGxveVNhbHQiLCJhZGRyZXNzZXMiLCJpbnZva2VSZXNwb25zZSIsImRlcGxveUNvbnRyYWN0IiwiZGVwbG95VHgiLCJkZWNsYXJlQW5kRGVwbG95IiwidHgiLCJoYXNoTWVzc2FnZSIsInZlcmlmeU1lc3NhZ2VIYXNoIiwidmVyaWZ5TWVzc2FnZSIsImZlZUVzdGltYXRlIiwiY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QiLCJzYWZlTm9uY2UiLCJ0eDBQYXlsb2FkIiwidHhQYXlsb2FkIiwiY29tbW9uIiwiUHJvdmlkZXJJbnRlcmZhY2UiLCJkZWZhdWx0UHJvdmlkZXIiLCJBY2NvdW50SW50ZXJmYWNlIiwiZXZlbnRzX2V4cG9ydHMiLCJnZXRBYmlFdmVudHMiLCJwYXJzZUV2ZW50cyIsInNpemUiLCJraW5kIiwiZW50cnlOYW1lIiwiYWJpRW50cnlNb2QiLCJwcm92aWRlclJlY2VpdmVkRXZlbnRzIiwiYWJpRXZlbnRzIiwiYWJpU3RydWN0cyIsImFiaUVudW1zIiwicmV0IiwicmVjRXZlbnQiLCJhYmlFdmVudCIsInBhcnNlZEV2ZW50Iiwia2V5c0l0ZXIiLCJkYXRhSXRlciIsImFiaUV2ZW50S2V5cyIsImFiaUV2ZW50RGF0YSIsInNwbGl0QXJnc0FuZE9wdGlvbnMiLCJsYXN0QXJnIiwic29tZSIsImJ1aWxkQ2FsbCIsImZ1bmN0aW9uQWJpIiwicGFyc2VSZXF1ZXN0IiwicGFyc2VSZXNwb25zZSIsImJ1aWxkSW52b2tlIiwiaW52b2tlIiwiYnVpbGREZWZhdWx0IiwiYnVpbGRQb3B1bGF0ZSIsInBvcHVsYXRlIiwiYnVpbGRFc3RpbWF0ZSIsImVzdGltYXRlIiwiZ2V0Q2FsbGRhdGEiLCJjYWxsYmFjayIsIkNvbnRyYWN0IiwicHJvdmlkZXJPckFjY291bnQiLCJjYWxsRGF0YSIsImRlZmluZVByb3BlcnRpZXMiLCJmdW5jdGlvbnMiLCJjYWxsU3RhdGljIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsImFiaUVsZW1lbnQiLCJhdHRhY2giLCJjb25uZWN0IiwiZGVwbG95ZWQiLCJkZXBsb3lUcmFuc2FjdGlvbkhhc2giLCJmb3JtYXRSZXNwb25zZSIsInJlY2VpcHQiLCJpc0NhaXJvMSIsImdldFZlcnNpb24iLCJ0eXBlZHYxIiwidEFiaSIsInR5cGVkdjIiLCJDb250cmFjdEludGVyZmFjZSIsIkNvbnRyYWN0RmFjdG9yeSIsImNvbnRyYWN0SW5zdGFuY2UiLCJoZXhUb0J5dGVzMiIsImFkZEFkZHJlc3NQYWRkaW5nIiwidmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MiLCJnZXRDaGVja3N1bUFkZHJlc3MiLCJjaGFycyIsImhhc2hlZCIsInZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzIiwiY29uc3RhbnRzIiwiZWMiLCJtZXJrbGUiLCJzaG9ydFN0cmluZyIsInN0YXJrIiwic3RhcmtuZXRJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;